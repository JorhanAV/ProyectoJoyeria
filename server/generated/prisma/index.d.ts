
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Categoria
 * 
 */
export type Categoria = $Result.DefaultSelection<Prisma.$CategoriaPayload>
/**
 * Model Etiqueta
 * 
 */
export type Etiqueta = $Result.DefaultSelection<Prisma.$EtiquetaPayload>
/**
 * Model Producto
 * 
 */
export type Producto = $Result.DefaultSelection<Prisma.$ProductoPayload>
/**
 * Model ImagenProducto
 * 
 */
export type ImagenProducto = $Result.DefaultSelection<Prisma.$ImagenProductoPayload>
/**
 * Model ProductoEtiqueta
 * 
 */
export type ProductoEtiqueta = $Result.DefaultSelection<Prisma.$ProductoEtiquetaPayload>
/**
 * Model Resena
 * 
 */
export type Resena = $Result.DefaultSelection<Prisma.$ResenaPayload>
/**
 * Model ProductoPersonalizable
 * 
 */
export type ProductoPersonalizable = $Result.DefaultSelection<Prisma.$ProductoPersonalizablePayload>
/**
 * Model Atributo
 * 
 */
export type Atributo = $Result.DefaultSelection<Prisma.$AtributoPayload>
/**
 * Model ValorAtributo
 * 
 */
export type ValorAtributo = $Result.DefaultSelection<Prisma.$ValorAtributoPayload>
/**
 * Model VarianteDetalle
 * 
 */
export type VarianteDetalle = $Result.DefaultSelection<Prisma.$VarianteDetallePayload>
/**
 * Model Promocion
 * 
 */
export type Promocion = $Result.DefaultSelection<Prisma.$PromocionPayload>
/**
 * Model HistorialPromocionAplicada
 * 
 */
export type HistorialPromocionAplicada = $Result.DefaultSelection<Prisma.$HistorialPromocionAplicadaPayload>
/**
 * Model Pedido
 * 
 */
export type Pedido = $Result.DefaultSelection<Prisma.$PedidoPayload>
/**
 * Model PedidoItem
 * 
 */
export type PedidoItem = $Result.DefaultSelection<Prisma.$PedidoItemPayload>
/**
 * Model TransicionEstadoPedido
 * 
 */
export type TransicionEstadoPedido = $Result.DefaultSelection<Prisma.$TransicionEstadoPedidoPayload>
/**
 * Model ReporteResena
 * 
 */
export type ReporteResena = $Result.DefaultSelection<Prisma.$ReporteResenaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Rol: {
  ADMIN: 'ADMIN',
  CLIENTE: 'CLIENTE'
};

export type Rol = (typeof Rol)[keyof typeof Rol]


export const TipoPromocion: {
  Porcentaje: 'Porcentaje',
  CantidadFija: 'CantidadFija'
};

export type TipoPromocion = (typeof TipoPromocion)[keyof typeof TipoPromocion]


export const EstadoCarrito: {
  Activo: 'Activo',
  Inactivo: 'Inactivo'
};

export type EstadoCarrito = (typeof EstadoCarrito)[keyof typeof EstadoCarrito]


export const MetodoPago: {
  Efectivo: 'Efectivo',
  Tarjeta: 'Tarjeta'
};

export type MetodoPago = (typeof MetodoPago)[keyof typeof MetodoPago]


export const EstadoPedido: {
  PendienteDePago: 'PendienteDePago',
  Pagado: 'Pagado',
  EnPreparacion: 'EnPreparacion',
  Entregado: 'Entregado'
};

export type EstadoPedido = (typeof EstadoPedido)[keyof typeof EstadoPedido]

}

export type Rol = $Enums.Rol

export const Rol: typeof $Enums.Rol

export type TipoPromocion = $Enums.TipoPromocion

export const TipoPromocion: typeof $Enums.TipoPromocion

export type EstadoCarrito = $Enums.EstadoCarrito

export const EstadoCarrito: typeof $Enums.EstadoCarrito

export type MetodoPago = $Enums.MetodoPago

export const MetodoPago: typeof $Enums.MetodoPago

export type EstadoPedido = $Enums.EstadoPedido

export const EstadoPedido: typeof $Enums.EstadoPedido

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoria`: Exposes CRUD operations for the **Categoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categoria.findMany()
    * ```
    */
  get categoria(): Prisma.CategoriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.etiqueta`: Exposes CRUD operations for the **Etiqueta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Etiquetas
    * const etiquetas = await prisma.etiqueta.findMany()
    * ```
    */
  get etiqueta(): Prisma.EtiquetaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.producto`: Exposes CRUD operations for the **Producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos
    * const productos = await prisma.producto.findMany()
    * ```
    */
  get producto(): Prisma.ProductoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.imagenProducto`: Exposes CRUD operations for the **ImagenProducto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImagenProductos
    * const imagenProductos = await prisma.imagenProducto.findMany()
    * ```
    */
  get imagenProducto(): Prisma.ImagenProductoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productoEtiqueta`: Exposes CRUD operations for the **ProductoEtiqueta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductoEtiquetas
    * const productoEtiquetas = await prisma.productoEtiqueta.findMany()
    * ```
    */
  get productoEtiqueta(): Prisma.ProductoEtiquetaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resena`: Exposes CRUD operations for the **Resena** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resenas
    * const resenas = await prisma.resena.findMany()
    * ```
    */
  get resena(): Prisma.ResenaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productoPersonalizable`: Exposes CRUD operations for the **ProductoPersonalizable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductoPersonalizables
    * const productoPersonalizables = await prisma.productoPersonalizable.findMany()
    * ```
    */
  get productoPersonalizable(): Prisma.ProductoPersonalizableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.atributo`: Exposes CRUD operations for the **Atributo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Atributos
    * const atributos = await prisma.atributo.findMany()
    * ```
    */
  get atributo(): Prisma.AtributoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.valorAtributo`: Exposes CRUD operations for the **ValorAtributo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ValorAtributos
    * const valorAtributos = await prisma.valorAtributo.findMany()
    * ```
    */
  get valorAtributo(): Prisma.ValorAtributoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.varianteDetalle`: Exposes CRUD operations for the **VarianteDetalle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VarianteDetalles
    * const varianteDetalles = await prisma.varianteDetalle.findMany()
    * ```
    */
  get varianteDetalle(): Prisma.VarianteDetalleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promocion`: Exposes CRUD operations for the **Promocion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promocions
    * const promocions = await prisma.promocion.findMany()
    * ```
    */
  get promocion(): Prisma.PromocionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.historialPromocionAplicada`: Exposes CRUD operations for the **HistorialPromocionAplicada** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistorialPromocionAplicadas
    * const historialPromocionAplicadas = await prisma.historialPromocionAplicada.findMany()
    * ```
    */
  get historialPromocionAplicada(): Prisma.HistorialPromocionAplicadaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pedido`: Exposes CRUD operations for the **Pedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedidos
    * const pedidos = await prisma.pedido.findMany()
    * ```
    */
  get pedido(): Prisma.PedidoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pedidoItem`: Exposes CRUD operations for the **PedidoItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PedidoItems
    * const pedidoItems = await prisma.pedidoItem.findMany()
    * ```
    */
  get pedidoItem(): Prisma.PedidoItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transicionEstadoPedido`: Exposes CRUD operations for the **TransicionEstadoPedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransicionEstadoPedidos
    * const transicionEstadoPedidos = await prisma.transicionEstadoPedido.findMany()
    * ```
    */
  get transicionEstadoPedido(): Prisma.TransicionEstadoPedidoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reporteResena`: Exposes CRUD operations for the **ReporteResena** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReporteResenas
    * const reporteResenas = await prisma.reporteResena.findMany()
    * ```
    */
  get reporteResena(): Prisma.ReporteResenaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Categoria: 'Categoria',
    Etiqueta: 'Etiqueta',
    Producto: 'Producto',
    ImagenProducto: 'ImagenProducto',
    ProductoEtiqueta: 'ProductoEtiqueta',
    Resena: 'Resena',
    ProductoPersonalizable: 'ProductoPersonalizable',
    Atributo: 'Atributo',
    ValorAtributo: 'ValorAtributo',
    VarianteDetalle: 'VarianteDetalle',
    Promocion: 'Promocion',
    HistorialPromocionAplicada: 'HistorialPromocionAplicada',
    Pedido: 'Pedido',
    PedidoItem: 'PedidoItem',
    TransicionEstadoPedido: 'TransicionEstadoPedido',
    ReporteResena: 'ReporteResena'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "usuario" | "categoria" | "etiqueta" | "producto" | "imagenProducto" | "productoEtiqueta" | "resena" | "productoPersonalizable" | "atributo" | "valorAtributo" | "varianteDetalle" | "promocion" | "historialPromocionAplicada" | "pedido" | "pedidoItem" | "transicionEstadoPedido" | "reporteResena"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Categoria: {
        payload: Prisma.$CategoriaPayload<ExtArgs>
        fields: Prisma.CategoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          findFirst: {
            args: Prisma.CategoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          findMany: {
            args: Prisma.CategoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>[]
          }
          create: {
            args: Prisma.CategoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          createMany: {
            args: Prisma.CategoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          update: {
            args: Prisma.CategoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          deleteMany: {
            args: Prisma.CategoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          aggregate: {
            args: Prisma.CategoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoria>
          }
          groupBy: {
            args: Prisma.CategoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriaCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriaCountAggregateOutputType> | number
          }
        }
      }
      Etiqueta: {
        payload: Prisma.$EtiquetaPayload<ExtArgs>
        fields: Prisma.EtiquetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EtiquetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EtiquetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>
          }
          findFirst: {
            args: Prisma.EtiquetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EtiquetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>
          }
          findMany: {
            args: Prisma.EtiquetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>[]
          }
          create: {
            args: Prisma.EtiquetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>
          }
          createMany: {
            args: Prisma.EtiquetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EtiquetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>
          }
          update: {
            args: Prisma.EtiquetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>
          }
          deleteMany: {
            args: Prisma.EtiquetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EtiquetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EtiquetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtiquetaPayload>
          }
          aggregate: {
            args: Prisma.EtiquetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEtiqueta>
          }
          groupBy: {
            args: Prisma.EtiquetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EtiquetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EtiquetaCountArgs<ExtArgs>
            result: $Utils.Optional<EtiquetaCountAggregateOutputType> | number
          }
        }
      }
      Producto: {
        payload: Prisma.$ProductoPayload<ExtArgs>
        fields: Prisma.ProductoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          findFirst: {
            args: Prisma.ProductoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          findMany: {
            args: Prisma.ProductoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>[]
          }
          create: {
            args: Prisma.ProductoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          createMany: {
            args: Prisma.ProductoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          update: {
            args: Prisma.ProductoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          deleteMany: {
            args: Prisma.ProductoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          aggregate: {
            args: Prisma.ProductoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducto>
          }
          groupBy: {
            args: Prisma.ProductoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductoCountArgs<ExtArgs>
            result: $Utils.Optional<ProductoCountAggregateOutputType> | number
          }
        }
      }
      ImagenProducto: {
        payload: Prisma.$ImagenProductoPayload<ExtArgs>
        fields: Prisma.ImagenProductoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImagenProductoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenProductoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImagenProductoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenProductoPayload>
          }
          findFirst: {
            args: Prisma.ImagenProductoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenProductoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImagenProductoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenProductoPayload>
          }
          findMany: {
            args: Prisma.ImagenProductoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenProductoPayload>[]
          }
          create: {
            args: Prisma.ImagenProductoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenProductoPayload>
          }
          createMany: {
            args: Prisma.ImagenProductoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ImagenProductoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenProductoPayload>
          }
          update: {
            args: Prisma.ImagenProductoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenProductoPayload>
          }
          deleteMany: {
            args: Prisma.ImagenProductoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImagenProductoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImagenProductoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagenProductoPayload>
          }
          aggregate: {
            args: Prisma.ImagenProductoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImagenProducto>
          }
          groupBy: {
            args: Prisma.ImagenProductoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImagenProductoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImagenProductoCountArgs<ExtArgs>
            result: $Utils.Optional<ImagenProductoCountAggregateOutputType> | number
          }
        }
      }
      ProductoEtiqueta: {
        payload: Prisma.$ProductoEtiquetaPayload<ExtArgs>
        fields: Prisma.ProductoEtiquetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductoEtiquetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoEtiquetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductoEtiquetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoEtiquetaPayload>
          }
          findFirst: {
            args: Prisma.ProductoEtiquetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoEtiquetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductoEtiquetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoEtiquetaPayload>
          }
          findMany: {
            args: Prisma.ProductoEtiquetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoEtiquetaPayload>[]
          }
          create: {
            args: Prisma.ProductoEtiquetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoEtiquetaPayload>
          }
          createMany: {
            args: Prisma.ProductoEtiquetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductoEtiquetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoEtiquetaPayload>
          }
          update: {
            args: Prisma.ProductoEtiquetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoEtiquetaPayload>
          }
          deleteMany: {
            args: Prisma.ProductoEtiquetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductoEtiquetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductoEtiquetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoEtiquetaPayload>
          }
          aggregate: {
            args: Prisma.ProductoEtiquetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductoEtiqueta>
          }
          groupBy: {
            args: Prisma.ProductoEtiquetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductoEtiquetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductoEtiquetaCountArgs<ExtArgs>
            result: $Utils.Optional<ProductoEtiquetaCountAggregateOutputType> | number
          }
        }
      }
      Resena: {
        payload: Prisma.$ResenaPayload<ExtArgs>
        fields: Prisma.ResenaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResenaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResenaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          findFirst: {
            args: Prisma.ResenaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResenaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          findMany: {
            args: Prisma.ResenaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>[]
          }
          create: {
            args: Prisma.ResenaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          createMany: {
            args: Prisma.ResenaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ResenaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          update: {
            args: Prisma.ResenaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          deleteMany: {
            args: Prisma.ResenaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResenaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResenaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          aggregate: {
            args: Prisma.ResenaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResena>
          }
          groupBy: {
            args: Prisma.ResenaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResenaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResenaCountArgs<ExtArgs>
            result: $Utils.Optional<ResenaCountAggregateOutputType> | number
          }
        }
      }
      ProductoPersonalizable: {
        payload: Prisma.$ProductoPersonalizablePayload<ExtArgs>
        fields: Prisma.ProductoPersonalizableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductoPersonalizableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPersonalizablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductoPersonalizableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPersonalizablePayload>
          }
          findFirst: {
            args: Prisma.ProductoPersonalizableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPersonalizablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductoPersonalizableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPersonalizablePayload>
          }
          findMany: {
            args: Prisma.ProductoPersonalizableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPersonalizablePayload>[]
          }
          create: {
            args: Prisma.ProductoPersonalizableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPersonalizablePayload>
          }
          createMany: {
            args: Prisma.ProductoPersonalizableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductoPersonalizableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPersonalizablePayload>
          }
          update: {
            args: Prisma.ProductoPersonalizableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPersonalizablePayload>
          }
          deleteMany: {
            args: Prisma.ProductoPersonalizableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductoPersonalizableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductoPersonalizableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPersonalizablePayload>
          }
          aggregate: {
            args: Prisma.ProductoPersonalizableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductoPersonalizable>
          }
          groupBy: {
            args: Prisma.ProductoPersonalizableGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductoPersonalizableGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductoPersonalizableCountArgs<ExtArgs>
            result: $Utils.Optional<ProductoPersonalizableCountAggregateOutputType> | number
          }
        }
      }
      Atributo: {
        payload: Prisma.$AtributoPayload<ExtArgs>
        fields: Prisma.AtributoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AtributoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtributoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AtributoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtributoPayload>
          }
          findFirst: {
            args: Prisma.AtributoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtributoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AtributoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtributoPayload>
          }
          findMany: {
            args: Prisma.AtributoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtributoPayload>[]
          }
          create: {
            args: Prisma.AtributoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtributoPayload>
          }
          createMany: {
            args: Prisma.AtributoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AtributoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtributoPayload>
          }
          update: {
            args: Prisma.AtributoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtributoPayload>
          }
          deleteMany: {
            args: Prisma.AtributoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AtributoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AtributoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtributoPayload>
          }
          aggregate: {
            args: Prisma.AtributoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAtributo>
          }
          groupBy: {
            args: Prisma.AtributoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AtributoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AtributoCountArgs<ExtArgs>
            result: $Utils.Optional<AtributoCountAggregateOutputType> | number
          }
        }
      }
      ValorAtributo: {
        payload: Prisma.$ValorAtributoPayload<ExtArgs>
        fields: Prisma.ValorAtributoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ValorAtributoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValorAtributoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ValorAtributoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValorAtributoPayload>
          }
          findFirst: {
            args: Prisma.ValorAtributoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValorAtributoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ValorAtributoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValorAtributoPayload>
          }
          findMany: {
            args: Prisma.ValorAtributoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValorAtributoPayload>[]
          }
          create: {
            args: Prisma.ValorAtributoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValorAtributoPayload>
          }
          createMany: {
            args: Prisma.ValorAtributoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ValorAtributoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValorAtributoPayload>
          }
          update: {
            args: Prisma.ValorAtributoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValorAtributoPayload>
          }
          deleteMany: {
            args: Prisma.ValorAtributoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ValorAtributoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ValorAtributoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValorAtributoPayload>
          }
          aggregate: {
            args: Prisma.ValorAtributoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateValorAtributo>
          }
          groupBy: {
            args: Prisma.ValorAtributoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ValorAtributoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ValorAtributoCountArgs<ExtArgs>
            result: $Utils.Optional<ValorAtributoCountAggregateOutputType> | number
          }
        }
      }
      VarianteDetalle: {
        payload: Prisma.$VarianteDetallePayload<ExtArgs>
        fields: Prisma.VarianteDetalleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VarianteDetalleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianteDetallePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VarianteDetalleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianteDetallePayload>
          }
          findFirst: {
            args: Prisma.VarianteDetalleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianteDetallePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VarianteDetalleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianteDetallePayload>
          }
          findMany: {
            args: Prisma.VarianteDetalleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianteDetallePayload>[]
          }
          create: {
            args: Prisma.VarianteDetalleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianteDetallePayload>
          }
          createMany: {
            args: Prisma.VarianteDetalleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VarianteDetalleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianteDetallePayload>
          }
          update: {
            args: Prisma.VarianteDetalleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianteDetallePayload>
          }
          deleteMany: {
            args: Prisma.VarianteDetalleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VarianteDetalleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VarianteDetalleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VarianteDetallePayload>
          }
          aggregate: {
            args: Prisma.VarianteDetalleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVarianteDetalle>
          }
          groupBy: {
            args: Prisma.VarianteDetalleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VarianteDetalleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VarianteDetalleCountArgs<ExtArgs>
            result: $Utils.Optional<VarianteDetalleCountAggregateOutputType> | number
          }
        }
      }
      Promocion: {
        payload: Prisma.$PromocionPayload<ExtArgs>
        fields: Prisma.PromocionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromocionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromocionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload>
          }
          findFirst: {
            args: Prisma.PromocionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromocionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload>
          }
          findMany: {
            args: Prisma.PromocionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload>[]
          }
          create: {
            args: Prisma.PromocionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload>
          }
          createMany: {
            args: Prisma.PromocionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PromocionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload>
          }
          update: {
            args: Prisma.PromocionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload>
          }
          deleteMany: {
            args: Prisma.PromocionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromocionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromocionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload>
          }
          aggregate: {
            args: Prisma.PromocionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromocion>
          }
          groupBy: {
            args: Prisma.PromocionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromocionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromocionCountArgs<ExtArgs>
            result: $Utils.Optional<PromocionCountAggregateOutputType> | number
          }
        }
      }
      HistorialPromocionAplicada: {
        payload: Prisma.$HistorialPromocionAplicadaPayload<ExtArgs>
        fields: Prisma.HistorialPromocionAplicadaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistorialPromocionAplicadaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPromocionAplicadaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistorialPromocionAplicadaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPromocionAplicadaPayload>
          }
          findFirst: {
            args: Prisma.HistorialPromocionAplicadaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPromocionAplicadaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistorialPromocionAplicadaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPromocionAplicadaPayload>
          }
          findMany: {
            args: Prisma.HistorialPromocionAplicadaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPromocionAplicadaPayload>[]
          }
          create: {
            args: Prisma.HistorialPromocionAplicadaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPromocionAplicadaPayload>
          }
          createMany: {
            args: Prisma.HistorialPromocionAplicadaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HistorialPromocionAplicadaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPromocionAplicadaPayload>
          }
          update: {
            args: Prisma.HistorialPromocionAplicadaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPromocionAplicadaPayload>
          }
          deleteMany: {
            args: Prisma.HistorialPromocionAplicadaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HistorialPromocionAplicadaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HistorialPromocionAplicadaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPromocionAplicadaPayload>
          }
          aggregate: {
            args: Prisma.HistorialPromocionAplicadaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistorialPromocionAplicada>
          }
          groupBy: {
            args: Prisma.HistorialPromocionAplicadaGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistorialPromocionAplicadaGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistorialPromocionAplicadaCountArgs<ExtArgs>
            result: $Utils.Optional<HistorialPromocionAplicadaCountAggregateOutputType> | number
          }
        }
      }
      Pedido: {
        payload: Prisma.$PedidoPayload<ExtArgs>
        fields: Prisma.PedidoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PedidoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PedidoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          findFirst: {
            args: Prisma.PedidoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PedidoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          findMany: {
            args: Prisma.PedidoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>[]
          }
          create: {
            args: Prisma.PedidoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          createMany: {
            args: Prisma.PedidoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PedidoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          update: {
            args: Prisma.PedidoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          deleteMany: {
            args: Prisma.PedidoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PedidoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PedidoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          aggregate: {
            args: Prisma.PedidoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePedido>
          }
          groupBy: {
            args: Prisma.PedidoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PedidoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PedidoCountArgs<ExtArgs>
            result: $Utils.Optional<PedidoCountAggregateOutputType> | number
          }
        }
      }
      PedidoItem: {
        payload: Prisma.$PedidoItemPayload<ExtArgs>
        fields: Prisma.PedidoItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PedidoItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PedidoItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          findFirst: {
            args: Prisma.PedidoItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PedidoItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          findMany: {
            args: Prisma.PedidoItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>[]
          }
          create: {
            args: Prisma.PedidoItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          createMany: {
            args: Prisma.PedidoItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PedidoItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          update: {
            args: Prisma.PedidoItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          deleteMany: {
            args: Prisma.PedidoItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PedidoItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PedidoItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoItemPayload>
          }
          aggregate: {
            args: Prisma.PedidoItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePedidoItem>
          }
          groupBy: {
            args: Prisma.PedidoItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PedidoItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PedidoItemCountArgs<ExtArgs>
            result: $Utils.Optional<PedidoItemCountAggregateOutputType> | number
          }
        }
      }
      TransicionEstadoPedido: {
        payload: Prisma.$TransicionEstadoPedidoPayload<ExtArgs>
        fields: Prisma.TransicionEstadoPedidoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransicionEstadoPedidoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransicionEstadoPedidoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransicionEstadoPedidoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransicionEstadoPedidoPayload>
          }
          findFirst: {
            args: Prisma.TransicionEstadoPedidoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransicionEstadoPedidoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransicionEstadoPedidoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransicionEstadoPedidoPayload>
          }
          findMany: {
            args: Prisma.TransicionEstadoPedidoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransicionEstadoPedidoPayload>[]
          }
          create: {
            args: Prisma.TransicionEstadoPedidoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransicionEstadoPedidoPayload>
          }
          createMany: {
            args: Prisma.TransicionEstadoPedidoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransicionEstadoPedidoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransicionEstadoPedidoPayload>
          }
          update: {
            args: Prisma.TransicionEstadoPedidoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransicionEstadoPedidoPayload>
          }
          deleteMany: {
            args: Prisma.TransicionEstadoPedidoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransicionEstadoPedidoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransicionEstadoPedidoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransicionEstadoPedidoPayload>
          }
          aggregate: {
            args: Prisma.TransicionEstadoPedidoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransicionEstadoPedido>
          }
          groupBy: {
            args: Prisma.TransicionEstadoPedidoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransicionEstadoPedidoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransicionEstadoPedidoCountArgs<ExtArgs>
            result: $Utils.Optional<TransicionEstadoPedidoCountAggregateOutputType> | number
          }
        }
      }
      ReporteResena: {
        payload: Prisma.$ReporteResenaPayload<ExtArgs>
        fields: Prisma.ReporteResenaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReporteResenaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReporteResenaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReporteResenaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReporteResenaPayload>
          }
          findFirst: {
            args: Prisma.ReporteResenaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReporteResenaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReporteResenaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReporteResenaPayload>
          }
          findMany: {
            args: Prisma.ReporteResenaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReporteResenaPayload>[]
          }
          create: {
            args: Prisma.ReporteResenaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReporteResenaPayload>
          }
          createMany: {
            args: Prisma.ReporteResenaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReporteResenaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReporteResenaPayload>
          }
          update: {
            args: Prisma.ReporteResenaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReporteResenaPayload>
          }
          deleteMany: {
            args: Prisma.ReporteResenaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReporteResenaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReporteResenaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReporteResenaPayload>
          }
          aggregate: {
            args: Prisma.ReporteResenaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReporteResena>
          }
          groupBy: {
            args: Prisma.ReporteResenaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReporteResenaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReporteResenaCountArgs<ExtArgs>
            result: $Utils.Optional<ReporteResenaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    usuario?: UsuarioOmit
    categoria?: CategoriaOmit
    etiqueta?: EtiquetaOmit
    producto?: ProductoOmit
    imagenProducto?: ImagenProductoOmit
    productoEtiqueta?: ProductoEtiquetaOmit
    resena?: ResenaOmit
    productoPersonalizable?: ProductoPersonalizableOmit
    atributo?: AtributoOmit
    valorAtributo?: ValorAtributoOmit
    varianteDetalle?: VarianteDetalleOmit
    promocion?: PromocionOmit
    historialPromocionAplicada?: HistorialPromocionAplicadaOmit
    pedido?: PedidoOmit
    pedidoItem?: PedidoItemOmit
    transicionEstadoPedido?: TransicionEstadoPedidoOmit
    reporteResena?: ReporteResenaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    resenas: number
    pedidos: number
    transiciones_estado: number
    reportes_resena: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resenas?: boolean | UsuarioCountOutputTypeCountResenasArgs
    pedidos?: boolean | UsuarioCountOutputTypeCountPedidosArgs
    transiciones_estado?: boolean | UsuarioCountOutputTypeCountTransiciones_estadoArgs
    reportes_resena?: boolean | UsuarioCountOutputTypeCountReportes_resenaArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountResenasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResenaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountTransiciones_estadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransicionEstadoPedidoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountReportes_resenaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReporteResenaWhereInput
  }


  /**
   * Count Type CategoriaCountOutputType
   */

  export type CategoriaCountOutputType = {
    productos: number
    promociones: number
    productosPersonalizables: number
  }

  export type CategoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productos?: boolean | CategoriaCountOutputTypeCountProductosArgs
    promociones?: boolean | CategoriaCountOutputTypeCountPromocionesArgs
    productosPersonalizables?: boolean | CategoriaCountOutputTypeCountProductosPersonalizablesArgs
  }

  // Custom InputTypes
  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCountOutputType
     */
    select?: CategoriaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoWhereInput
  }

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountPromocionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromocionWhereInput
  }

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountProductosPersonalizablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoPersonalizableWhereInput
  }


  /**
   * Count Type EtiquetaCountOutputType
   */

  export type EtiquetaCountOutputType = {
    productos: number
  }

  export type EtiquetaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productos?: boolean | EtiquetaCountOutputTypeCountProductosArgs
  }

  // Custom InputTypes
  /**
   * EtiquetaCountOutputType without action
   */
  export type EtiquetaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtiquetaCountOutputType
     */
    select?: EtiquetaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EtiquetaCountOutputType without action
   */
  export type EtiquetaCountOutputTypeCountProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoEtiquetaWhereInput
  }


  /**
   * Count Type ProductoCountOutputType
   */

  export type ProductoCountOutputType = {
    imagenes: number
    etiquetas: number
    resenas: number
    pedidoItems: number
    promociones: number
    productosPersonalizables: number
  }

  export type ProductoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    imagenes?: boolean | ProductoCountOutputTypeCountImagenesArgs
    etiquetas?: boolean | ProductoCountOutputTypeCountEtiquetasArgs
    resenas?: boolean | ProductoCountOutputTypeCountResenasArgs
    pedidoItems?: boolean | ProductoCountOutputTypeCountPedidoItemsArgs
    promociones?: boolean | ProductoCountOutputTypeCountPromocionesArgs
    productosPersonalizables?: boolean | ProductoCountOutputTypeCountProductosPersonalizablesArgs
  }

  // Custom InputTypes
  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoCountOutputType
     */
    select?: ProductoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountImagenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImagenProductoWhereInput
  }

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountEtiquetasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoEtiquetaWhereInput
  }

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountResenasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResenaWhereInput
  }

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountPedidoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoItemWhereInput
  }

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountPromocionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromocionWhereInput
  }

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeCountProductosPersonalizablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoPersonalizableWhereInput
  }


  /**
   * Count Type ResenaCountOutputType
   */

  export type ResenaCountOutputType = {
    reportes: number
  }

  export type ResenaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reportes?: boolean | ResenaCountOutputTypeCountReportesArgs
  }

  // Custom InputTypes
  /**
   * ResenaCountOutputType without action
   */
  export type ResenaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResenaCountOutputType
     */
    select?: ResenaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResenaCountOutputType without action
   */
  export type ResenaCountOutputTypeCountReportesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReporteResenaWhereInput
  }


  /**
   * Count Type ProductoPersonalizableCountOutputType
   */

  export type ProductoPersonalizableCountOutputType = {
    pedidoItems: number
    variantes: number
  }

  export type ProductoPersonalizableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidoItems?: boolean | ProductoPersonalizableCountOutputTypeCountPedidoItemsArgs
    variantes?: boolean | ProductoPersonalizableCountOutputTypeCountVariantesArgs
  }

  // Custom InputTypes
  /**
   * ProductoPersonalizableCountOutputType without action
   */
  export type ProductoPersonalizableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoPersonalizableCountOutputType
     */
    select?: ProductoPersonalizableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductoPersonalizableCountOutputType without action
   */
  export type ProductoPersonalizableCountOutputTypeCountPedidoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoItemWhereInput
  }

  /**
   * ProductoPersonalizableCountOutputType without action
   */
  export type ProductoPersonalizableCountOutputTypeCountVariantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VarianteDetalleWhereInput
  }


  /**
   * Count Type AtributoCountOutputType
   */

  export type AtributoCountOutputType = {
    valores: number
  }

  export type AtributoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    valores?: boolean | AtributoCountOutputTypeCountValoresArgs
  }

  // Custom InputTypes
  /**
   * AtributoCountOutputType without action
   */
  export type AtributoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AtributoCountOutputType
     */
    select?: AtributoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AtributoCountOutputType without action
   */
  export type AtributoCountOutputTypeCountValoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValorAtributoWhereInput
  }


  /**
   * Count Type ValorAtributoCountOutputType
   */

  export type ValorAtributoCountOutputType = {
    varianteDetalles: number
  }

  export type ValorAtributoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    varianteDetalles?: boolean | ValorAtributoCountOutputTypeCountVarianteDetallesArgs
  }

  // Custom InputTypes
  /**
   * ValorAtributoCountOutputType without action
   */
  export type ValorAtributoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValorAtributoCountOutputType
     */
    select?: ValorAtributoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ValorAtributoCountOutputType without action
   */
  export type ValorAtributoCountOutputTypeCountVarianteDetallesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VarianteDetalleWhereInput
  }


  /**
   * Count Type PromocionCountOutputType
   */

  export type PromocionCountOutputType = {
    historial: number
  }

  export type PromocionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    historial?: boolean | PromocionCountOutputTypeCountHistorialArgs
  }

  // Custom InputTypes
  /**
   * PromocionCountOutputType without action
   */
  export type PromocionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromocionCountOutputType
     */
    select?: PromocionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromocionCountOutputType without action
   */
  export type PromocionCountOutputTypeCountHistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialPromocionAplicadaWhereInput
  }


  /**
   * Count Type PedidoCountOutputType
   */

  export type PedidoCountOutputType = {
    items: number
    transiciones: number
    promociones_aplicadas: number
  }

  export type PedidoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PedidoCountOutputTypeCountItemsArgs
    transiciones?: boolean | PedidoCountOutputTypeCountTransicionesArgs
    promociones_aplicadas?: boolean | PedidoCountOutputTypeCountPromociones_aplicadasArgs
  }

  // Custom InputTypes
  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoCountOutputType
     */
    select?: PedidoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoItemWhereInput
  }

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeCountTransicionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransicionEstadoPedidoWhereInput
  }

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeCountPromociones_aplicadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialPromocionAplicadaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nombre_usuario: string | null
    correo: string | null
    contraseña: string | null
    rol: $Enums.Rol | null
    ultimo_inicio_sesion: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nombre_usuario: string | null
    correo: string | null
    contraseña: string | null
    rol: $Enums.Rol | null
    ultimo_inicio_sesion: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre_usuario: number
    correo: number
    contraseña: number
    rol: number
    ultimo_inicio_sesion: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre_usuario?: true
    correo?: true
    contraseña?: true
    rol?: true
    ultimo_inicio_sesion?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre_usuario?: true
    correo?: true
    contraseña?: true
    rol?: true
    ultimo_inicio_sesion?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre_usuario?: true
    correo?: true
    contraseña?: true
    rol?: true
    ultimo_inicio_sesion?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    nombre_usuario: string
    correo: string
    contraseña: string
    rol: $Enums.Rol
    ultimo_inicio_sesion: Date | null
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_usuario?: boolean
    correo?: boolean
    contraseña?: boolean
    rol?: boolean
    ultimo_inicio_sesion?: boolean
    resenas?: boolean | Usuario$resenasArgs<ExtArgs>
    pedidos?: boolean | Usuario$pedidosArgs<ExtArgs>
    transiciones_estado?: boolean | Usuario$transiciones_estadoArgs<ExtArgs>
    reportes_resena?: boolean | Usuario$reportes_resenaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>



  export type UsuarioSelectScalar = {
    id?: boolean
    nombre_usuario?: boolean
    correo?: boolean
    contraseña?: boolean
    rol?: boolean
    ultimo_inicio_sesion?: boolean
  }

  export type UsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre_usuario" | "correo" | "contraseña" | "rol" | "ultimo_inicio_sesion", ExtArgs["result"]["usuario"]>
  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resenas?: boolean | Usuario$resenasArgs<ExtArgs>
    pedidos?: boolean | Usuario$pedidosArgs<ExtArgs>
    transiciones_estado?: boolean | Usuario$transiciones_estadoArgs<ExtArgs>
    reportes_resena?: boolean | Usuario$reportes_resenaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      resenas: Prisma.$ResenaPayload<ExtArgs>[]
      pedidos: Prisma.$PedidoPayload<ExtArgs>[]
      transiciones_estado: Prisma.$TransicionEstadoPedidoPayload<ExtArgs>[]
      reportes_resena: Prisma.$ReporteResenaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre_usuario: string
      correo: string
      contraseña: string
      rol: $Enums.Rol
      ultimo_inicio_sesion: Date | null
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resenas<T extends Usuario$resenasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$resenasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pedidos<T extends Usuario$pedidosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$pedidosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transiciones_estado<T extends Usuario$transiciones_estadoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$transiciones_estadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransicionEstadoPedidoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportes_resena<T extends Usuario$reportes_resenaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$reportes_resenaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReporteResenaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly nombre_usuario: FieldRef<"Usuario", 'String'>
    readonly correo: FieldRef<"Usuario", 'String'>
    readonly contraseña: FieldRef<"Usuario", 'String'>
    readonly rol: FieldRef<"Usuario", 'Rol'>
    readonly ultimo_inicio_sesion: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuario.resenas
   */
  export type Usuario$resenasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    where?: ResenaWhereInput
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    cursor?: ResenaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[]
  }

  /**
   * Usuario.pedidos
   */
  export type Usuario$pedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Usuario.transiciones_estado
   */
  export type Usuario$transiciones_estadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransicionEstadoPedido
     */
    select?: TransicionEstadoPedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransicionEstadoPedido
     */
    omit?: TransicionEstadoPedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransicionEstadoPedidoInclude<ExtArgs> | null
    where?: TransicionEstadoPedidoWhereInput
    orderBy?: TransicionEstadoPedidoOrderByWithRelationInput | TransicionEstadoPedidoOrderByWithRelationInput[]
    cursor?: TransicionEstadoPedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransicionEstadoPedidoScalarFieldEnum | TransicionEstadoPedidoScalarFieldEnum[]
  }

  /**
   * Usuario.reportes_resena
   */
  export type Usuario$reportes_resenaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReporteResena
     */
    select?: ReporteResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReporteResena
     */
    omit?: ReporteResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteResenaInclude<ExtArgs> | null
    where?: ReporteResenaWhereInput
    orderBy?: ReporteResenaOrderByWithRelationInput | ReporteResenaOrderByWithRelationInput[]
    cursor?: ReporteResenaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReporteResenaScalarFieldEnum | ReporteResenaScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Categoria
   */

  export type AggregateCategoria = {
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  export type CategoriaAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriaSumAggregateOutputType = {
    id: number | null
  }

  export type CategoriaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
  }

  export type CategoriaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
  }

  export type CategoriaCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    _all: number
  }


  export type CategoriaAvgAggregateInputType = {
    id?: true
  }

  export type CategoriaSumAggregateInputType = {
    id?: true
  }

  export type CategoriaMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
  }

  export type CategoriaMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
  }

  export type CategoriaCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    _all?: true
  }

  export type CategoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categoria to aggregate.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categorias
    **/
    _count?: true | CategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaMaxAggregateInputType
  }

  export type GetCategoriaAggregateType<T extends CategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria[P]>
      : GetScalarType<T[P], AggregateCategoria[P]>
  }




  export type CategoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaWhereInput
    orderBy?: CategoriaOrderByWithAggregationInput | CategoriaOrderByWithAggregationInput[]
    by: CategoriaScalarFieldEnum[] | CategoriaScalarFieldEnum
    having?: CategoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaCountAggregateInputType | true
    _avg?: CategoriaAvgAggregateInputType
    _sum?: CategoriaSumAggregateInputType
    _min?: CategoriaMinAggregateInputType
    _max?: CategoriaMaxAggregateInputType
  }

  export type CategoriaGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  type GetCategoriaGroupByPayload<T extends CategoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
        }
      >
    >


  export type CategoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    productos?: boolean | Categoria$productosArgs<ExtArgs>
    promociones?: boolean | Categoria$promocionesArgs<ExtArgs>
    productosPersonalizables?: boolean | Categoria$productosPersonalizablesArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria"]>



  export type CategoriaSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
  }

  export type CategoriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion", ExtArgs["result"]["categoria"]>
  export type CategoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productos?: boolean | Categoria$productosArgs<ExtArgs>
    promociones?: boolean | Categoria$promocionesArgs<ExtArgs>
    productosPersonalizables?: boolean | Categoria$productosPersonalizablesArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Categoria"
    objects: {
      productos: Prisma.$ProductoPayload<ExtArgs>[]
      promociones: Prisma.$PromocionPayload<ExtArgs>[]
      productosPersonalizables: Prisma.$ProductoPersonalizablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string
    }, ExtArgs["result"]["categoria"]>
    composites: {}
  }

  type CategoriaGetPayload<S extends boolean | null | undefined | CategoriaDefaultArgs> = $Result.GetResult<Prisma.$CategoriaPayload, S>

  type CategoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriaCountAggregateInputType | true
    }

  export interface CategoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Categoria'], meta: { name: 'Categoria' } }
    /**
     * Find zero or one Categoria that matches the filter.
     * @param {CategoriaFindUniqueArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoriaFindUniqueArgs>(args: SelectSubset<T, CategoriaFindUniqueArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categoria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoriaFindUniqueOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoriaFindFirstArgs>(args?: SelectSubset<T, CategoriaFindFirstArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categoria.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriaWithIdOnly = await prisma.categoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoriaFindManyArgs>(args?: SelectSubset<T, CategoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categoria.
     * @param {CategoriaCreateArgs} args - Arguments to create a Categoria.
     * @example
     * // Create one Categoria
     * const Categoria = await prisma.categoria.create({
     *   data: {
     *     // ... data to create a Categoria
     *   }
     * })
     * 
     */
    create<T extends CategoriaCreateArgs>(args: SelectSubset<T, CategoriaCreateArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categorias.
     * @param {CategoriaCreateManyArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categoria = await prisma.categoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoriaCreateManyArgs>(args?: SelectSubset<T, CategoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categoria.
     * @param {CategoriaDeleteArgs} args - Arguments to delete one Categoria.
     * @example
     * // Delete one Categoria
     * const Categoria = await prisma.categoria.delete({
     *   where: {
     *     // ... filter to delete one Categoria
     *   }
     * })
     * 
     */
    delete<T extends CategoriaDeleteArgs>(args: SelectSubset<T, CategoriaDeleteArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categoria.
     * @param {CategoriaUpdateArgs} args - Arguments to update one Categoria.
     * @example
     * // Update one Categoria
     * const categoria = await prisma.categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoriaUpdateArgs>(args: SelectSubset<T, CategoriaUpdateArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categorias.
     * @param {CategoriaDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoriaDeleteManyArgs>(args?: SelectSubset<T, CategoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoriaUpdateManyArgs>(args: SelectSubset<T, CategoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categoria.
     * @param {CategoriaUpsertArgs} args - Arguments to update or create a Categoria.
     * @example
     * // Update or create a Categoria
     * const categoria = await prisma.categoria.upsert({
     *   create: {
     *     // ... data to create a Categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria we want to update
     *   }
     * })
     */
    upsert<T extends CategoriaUpsertArgs>(args: SelectSubset<T, CategoriaUpsertArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categoria.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends CategoriaCountArgs>(
      args?: Subset<T, CategoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaAggregateArgs>(args: Subset<T, CategoriaAggregateArgs>): Prisma.PrismaPromise<GetCategoriaAggregateType<T>>

    /**
     * Group by Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriaGroupByArgs['orderBy'] }
        : { orderBy?: CategoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Categoria model
   */
  readonly fields: CategoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productos<T extends Categoria$productosArgs<ExtArgs> = {}>(args?: Subset<T, Categoria$productosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promociones<T extends Categoria$promocionesArgs<ExtArgs> = {}>(args?: Subset<T, Categoria$promocionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productosPersonalizables<T extends Categoria$productosPersonalizablesArgs<ExtArgs> = {}>(args?: Subset<T, Categoria$productosPersonalizablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPersonalizablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Categoria model
   */
  interface CategoriaFieldRefs {
    readonly id: FieldRef<"Categoria", 'Int'>
    readonly nombre: FieldRef<"Categoria", 'String'>
    readonly descripcion: FieldRef<"Categoria", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Categoria findUnique
   */
  export type CategoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria findUniqueOrThrow
   */
  export type CategoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria findFirst
   */
  export type CategoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria findFirstOrThrow
   */
  export type CategoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria findMany
   */
  export type CategoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categorias to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria create
   */
  export type CategoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Categoria.
     */
    data: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
  }

  /**
   * Categoria createMany
   */
  export type CategoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categorias.
     */
    data: CategoriaCreateManyInput | CategoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categoria update
   */
  export type CategoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Categoria.
     */
    data: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
    /**
     * Choose, which Categoria to update.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria updateMany
   */
  export type CategoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categorias.
     */
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyInput>
    /**
     * Filter which Categorias to update
     */
    where?: CategoriaWhereInput
    /**
     * Limit how many Categorias to update.
     */
    limit?: number
  }

  /**
   * Categoria upsert
   */
  export type CategoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Categoria to update in case it exists.
     */
    where: CategoriaWhereUniqueInput
    /**
     * In case the Categoria found by the `where` argument doesn't exist, create a new Categoria with this data.
     */
    create: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
    /**
     * In case the Categoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
  }

  /**
   * Categoria delete
   */
  export type CategoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter which Categoria to delete.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria deleteMany
   */
  export type CategoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categorias to delete
     */
    where?: CategoriaWhereInput
    /**
     * Limit how many Categorias to delete.
     */
    limit?: number
  }

  /**
   * Categoria.productos
   */
  export type Categoria$productosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    where?: ProductoWhereInput
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    cursor?: ProductoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Categoria.promociones
   */
  export type Categoria$promocionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promocion
     */
    omit?: PromocionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    where?: PromocionWhereInput
    orderBy?: PromocionOrderByWithRelationInput | PromocionOrderByWithRelationInput[]
    cursor?: PromocionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromocionScalarFieldEnum | PromocionScalarFieldEnum[]
  }

  /**
   * Categoria.productosPersonalizables
   */
  export type Categoria$productosPersonalizablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoPersonalizable
     */
    select?: ProductoPersonalizableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoPersonalizable
     */
    omit?: ProductoPersonalizableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoPersonalizableInclude<ExtArgs> | null
    where?: ProductoPersonalizableWhereInput
    orderBy?: ProductoPersonalizableOrderByWithRelationInput | ProductoPersonalizableOrderByWithRelationInput[]
    cursor?: ProductoPersonalizableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductoPersonalizableScalarFieldEnum | ProductoPersonalizableScalarFieldEnum[]
  }

  /**
   * Categoria without action
   */
  export type CategoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
  }


  /**
   * Model Etiqueta
   */

  export type AggregateEtiqueta = {
    _count: EtiquetaCountAggregateOutputType | null
    _avg: EtiquetaAvgAggregateOutputType | null
    _sum: EtiquetaSumAggregateOutputType | null
    _min: EtiquetaMinAggregateOutputType | null
    _max: EtiquetaMaxAggregateOutputType | null
  }

  export type EtiquetaAvgAggregateOutputType = {
    id: number | null
  }

  export type EtiquetaSumAggregateOutputType = {
    id: number | null
  }

  export type EtiquetaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type EtiquetaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type EtiquetaCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type EtiquetaAvgAggregateInputType = {
    id?: true
  }

  export type EtiquetaSumAggregateInputType = {
    id?: true
  }

  export type EtiquetaMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type EtiquetaMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type EtiquetaCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type EtiquetaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Etiqueta to aggregate.
     */
    where?: EtiquetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etiquetas to fetch.
     */
    orderBy?: EtiquetaOrderByWithRelationInput | EtiquetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EtiquetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etiquetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etiquetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Etiquetas
    **/
    _count?: true | EtiquetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EtiquetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EtiquetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EtiquetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EtiquetaMaxAggregateInputType
  }

  export type GetEtiquetaAggregateType<T extends EtiquetaAggregateArgs> = {
        [P in keyof T & keyof AggregateEtiqueta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtiqueta[P]>
      : GetScalarType<T[P], AggregateEtiqueta[P]>
  }




  export type EtiquetaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtiquetaWhereInput
    orderBy?: EtiquetaOrderByWithAggregationInput | EtiquetaOrderByWithAggregationInput[]
    by: EtiquetaScalarFieldEnum[] | EtiquetaScalarFieldEnum
    having?: EtiquetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EtiquetaCountAggregateInputType | true
    _avg?: EtiquetaAvgAggregateInputType
    _sum?: EtiquetaSumAggregateInputType
    _min?: EtiquetaMinAggregateInputType
    _max?: EtiquetaMaxAggregateInputType
  }

  export type EtiquetaGroupByOutputType = {
    id: number
    nombre: string
    _count: EtiquetaCountAggregateOutputType | null
    _avg: EtiquetaAvgAggregateOutputType | null
    _sum: EtiquetaSumAggregateOutputType | null
    _min: EtiquetaMinAggregateOutputType | null
    _max: EtiquetaMaxAggregateOutputType | null
  }

  type GetEtiquetaGroupByPayload<T extends EtiquetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EtiquetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EtiquetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EtiquetaGroupByOutputType[P]>
            : GetScalarType<T[P], EtiquetaGroupByOutputType[P]>
        }
      >
    >


  export type EtiquetaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    productos?: boolean | Etiqueta$productosArgs<ExtArgs>
    _count?: boolean | EtiquetaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["etiqueta"]>



  export type EtiquetaSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type EtiquetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre", ExtArgs["result"]["etiqueta"]>
  export type EtiquetaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productos?: boolean | Etiqueta$productosArgs<ExtArgs>
    _count?: boolean | EtiquetaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EtiquetaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Etiqueta"
    objects: {
      productos: Prisma.$ProductoEtiquetaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["etiqueta"]>
    composites: {}
  }

  type EtiquetaGetPayload<S extends boolean | null | undefined | EtiquetaDefaultArgs> = $Result.GetResult<Prisma.$EtiquetaPayload, S>

  type EtiquetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EtiquetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EtiquetaCountAggregateInputType | true
    }

  export interface EtiquetaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Etiqueta'], meta: { name: 'Etiqueta' } }
    /**
     * Find zero or one Etiqueta that matches the filter.
     * @param {EtiquetaFindUniqueArgs} args - Arguments to find a Etiqueta
     * @example
     * // Get one Etiqueta
     * const etiqueta = await prisma.etiqueta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EtiquetaFindUniqueArgs>(args: SelectSubset<T, EtiquetaFindUniqueArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Etiqueta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EtiquetaFindUniqueOrThrowArgs} args - Arguments to find a Etiqueta
     * @example
     * // Get one Etiqueta
     * const etiqueta = await prisma.etiqueta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EtiquetaFindUniqueOrThrowArgs>(args: SelectSubset<T, EtiquetaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Etiqueta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtiquetaFindFirstArgs} args - Arguments to find a Etiqueta
     * @example
     * // Get one Etiqueta
     * const etiqueta = await prisma.etiqueta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EtiquetaFindFirstArgs>(args?: SelectSubset<T, EtiquetaFindFirstArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Etiqueta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtiquetaFindFirstOrThrowArgs} args - Arguments to find a Etiqueta
     * @example
     * // Get one Etiqueta
     * const etiqueta = await prisma.etiqueta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EtiquetaFindFirstOrThrowArgs>(args?: SelectSubset<T, EtiquetaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Etiquetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtiquetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Etiquetas
     * const etiquetas = await prisma.etiqueta.findMany()
     * 
     * // Get first 10 Etiquetas
     * const etiquetas = await prisma.etiqueta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const etiquetaWithIdOnly = await prisma.etiqueta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EtiquetaFindManyArgs>(args?: SelectSubset<T, EtiquetaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Etiqueta.
     * @param {EtiquetaCreateArgs} args - Arguments to create a Etiqueta.
     * @example
     * // Create one Etiqueta
     * const Etiqueta = await prisma.etiqueta.create({
     *   data: {
     *     // ... data to create a Etiqueta
     *   }
     * })
     * 
     */
    create<T extends EtiquetaCreateArgs>(args: SelectSubset<T, EtiquetaCreateArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Etiquetas.
     * @param {EtiquetaCreateManyArgs} args - Arguments to create many Etiquetas.
     * @example
     * // Create many Etiquetas
     * const etiqueta = await prisma.etiqueta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EtiquetaCreateManyArgs>(args?: SelectSubset<T, EtiquetaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Etiqueta.
     * @param {EtiquetaDeleteArgs} args - Arguments to delete one Etiqueta.
     * @example
     * // Delete one Etiqueta
     * const Etiqueta = await prisma.etiqueta.delete({
     *   where: {
     *     // ... filter to delete one Etiqueta
     *   }
     * })
     * 
     */
    delete<T extends EtiquetaDeleteArgs>(args: SelectSubset<T, EtiquetaDeleteArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Etiqueta.
     * @param {EtiquetaUpdateArgs} args - Arguments to update one Etiqueta.
     * @example
     * // Update one Etiqueta
     * const etiqueta = await prisma.etiqueta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EtiquetaUpdateArgs>(args: SelectSubset<T, EtiquetaUpdateArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Etiquetas.
     * @param {EtiquetaDeleteManyArgs} args - Arguments to filter Etiquetas to delete.
     * @example
     * // Delete a few Etiquetas
     * const { count } = await prisma.etiqueta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EtiquetaDeleteManyArgs>(args?: SelectSubset<T, EtiquetaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Etiquetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtiquetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Etiquetas
     * const etiqueta = await prisma.etiqueta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EtiquetaUpdateManyArgs>(args: SelectSubset<T, EtiquetaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Etiqueta.
     * @param {EtiquetaUpsertArgs} args - Arguments to update or create a Etiqueta.
     * @example
     * // Update or create a Etiqueta
     * const etiqueta = await prisma.etiqueta.upsert({
     *   create: {
     *     // ... data to create a Etiqueta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Etiqueta we want to update
     *   }
     * })
     */
    upsert<T extends EtiquetaUpsertArgs>(args: SelectSubset<T, EtiquetaUpsertArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Etiquetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtiquetaCountArgs} args - Arguments to filter Etiquetas to count.
     * @example
     * // Count the number of Etiquetas
     * const count = await prisma.etiqueta.count({
     *   where: {
     *     // ... the filter for the Etiquetas we want to count
     *   }
     * })
    **/
    count<T extends EtiquetaCountArgs>(
      args?: Subset<T, EtiquetaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EtiquetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Etiqueta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtiquetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EtiquetaAggregateArgs>(args: Subset<T, EtiquetaAggregateArgs>): Prisma.PrismaPromise<GetEtiquetaAggregateType<T>>

    /**
     * Group by Etiqueta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtiquetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EtiquetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EtiquetaGroupByArgs['orderBy'] }
        : { orderBy?: EtiquetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EtiquetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtiquetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Etiqueta model
   */
  readonly fields: EtiquetaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Etiqueta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EtiquetaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productos<T extends Etiqueta$productosArgs<ExtArgs> = {}>(args?: Subset<T, Etiqueta$productosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoEtiquetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Etiqueta model
   */
  interface EtiquetaFieldRefs {
    readonly id: FieldRef<"Etiqueta", 'Int'>
    readonly nombre: FieldRef<"Etiqueta", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Etiqueta findUnique
   */
  export type EtiquetaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etiqueta
     */
    omit?: EtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which Etiqueta to fetch.
     */
    where: EtiquetaWhereUniqueInput
  }

  /**
   * Etiqueta findUniqueOrThrow
   */
  export type EtiquetaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etiqueta
     */
    omit?: EtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which Etiqueta to fetch.
     */
    where: EtiquetaWhereUniqueInput
  }

  /**
   * Etiqueta findFirst
   */
  export type EtiquetaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etiqueta
     */
    omit?: EtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which Etiqueta to fetch.
     */
    where?: EtiquetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etiquetas to fetch.
     */
    orderBy?: EtiquetaOrderByWithRelationInput | EtiquetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Etiquetas.
     */
    cursor?: EtiquetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etiquetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etiquetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Etiquetas.
     */
    distinct?: EtiquetaScalarFieldEnum | EtiquetaScalarFieldEnum[]
  }

  /**
   * Etiqueta findFirstOrThrow
   */
  export type EtiquetaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etiqueta
     */
    omit?: EtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which Etiqueta to fetch.
     */
    where?: EtiquetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etiquetas to fetch.
     */
    orderBy?: EtiquetaOrderByWithRelationInput | EtiquetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Etiquetas.
     */
    cursor?: EtiquetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etiquetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etiquetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Etiquetas.
     */
    distinct?: EtiquetaScalarFieldEnum | EtiquetaScalarFieldEnum[]
  }

  /**
   * Etiqueta findMany
   */
  export type EtiquetaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etiqueta
     */
    omit?: EtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which Etiquetas to fetch.
     */
    where?: EtiquetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etiquetas to fetch.
     */
    orderBy?: EtiquetaOrderByWithRelationInput | EtiquetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Etiquetas.
     */
    cursor?: EtiquetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etiquetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etiquetas.
     */
    skip?: number
    distinct?: EtiquetaScalarFieldEnum | EtiquetaScalarFieldEnum[]
  }

  /**
   * Etiqueta create
   */
  export type EtiquetaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etiqueta
     */
    omit?: EtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * The data needed to create a Etiqueta.
     */
    data: XOR<EtiquetaCreateInput, EtiquetaUncheckedCreateInput>
  }

  /**
   * Etiqueta createMany
   */
  export type EtiquetaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Etiquetas.
     */
    data: EtiquetaCreateManyInput | EtiquetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Etiqueta update
   */
  export type EtiquetaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etiqueta
     */
    omit?: EtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * The data needed to update a Etiqueta.
     */
    data: XOR<EtiquetaUpdateInput, EtiquetaUncheckedUpdateInput>
    /**
     * Choose, which Etiqueta to update.
     */
    where: EtiquetaWhereUniqueInput
  }

  /**
   * Etiqueta updateMany
   */
  export type EtiquetaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Etiquetas.
     */
    data: XOR<EtiquetaUpdateManyMutationInput, EtiquetaUncheckedUpdateManyInput>
    /**
     * Filter which Etiquetas to update
     */
    where?: EtiquetaWhereInput
    /**
     * Limit how many Etiquetas to update.
     */
    limit?: number
  }

  /**
   * Etiqueta upsert
   */
  export type EtiquetaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etiqueta
     */
    omit?: EtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * The filter to search for the Etiqueta to update in case it exists.
     */
    where: EtiquetaWhereUniqueInput
    /**
     * In case the Etiqueta found by the `where` argument doesn't exist, create a new Etiqueta with this data.
     */
    create: XOR<EtiquetaCreateInput, EtiquetaUncheckedCreateInput>
    /**
     * In case the Etiqueta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EtiquetaUpdateInput, EtiquetaUncheckedUpdateInput>
  }

  /**
   * Etiqueta delete
   */
  export type EtiquetaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etiqueta
     */
    omit?: EtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
    /**
     * Filter which Etiqueta to delete.
     */
    where: EtiquetaWhereUniqueInput
  }

  /**
   * Etiqueta deleteMany
   */
  export type EtiquetaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Etiquetas to delete
     */
    where?: EtiquetaWhereInput
    /**
     * Limit how many Etiquetas to delete.
     */
    limit?: number
  }

  /**
   * Etiqueta.productos
   */
  export type Etiqueta$productosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoEtiqueta
     */
    select?: ProductoEtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoEtiqueta
     */
    omit?: ProductoEtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoEtiquetaInclude<ExtArgs> | null
    where?: ProductoEtiquetaWhereInput
    orderBy?: ProductoEtiquetaOrderByWithRelationInput | ProductoEtiquetaOrderByWithRelationInput[]
    cursor?: ProductoEtiquetaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductoEtiquetaScalarFieldEnum | ProductoEtiquetaScalarFieldEnum[]
  }

  /**
   * Etiqueta without action
   */
  export type EtiquetaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etiqueta
     */
    select?: EtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etiqueta
     */
    omit?: EtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtiquetaInclude<ExtArgs> | null
  }


  /**
   * Model Producto
   */

  export type AggregateProducto = {
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  export type ProductoAvgAggregateOutputType = {
    id: number | null
    precio_base: number | null
    stock: number | null
    categoria_id: number | null
    promedio_valoracion: number | null
  }

  export type ProductoSumAggregateOutputType = {
    id: number | null
    precio_base: number | null
    stock: number | null
    categoria_id: number | null
    promedio_valoracion: number | null
  }

  export type ProductoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    precio_base: number | null
    stock: number | null
    categoria_id: number | null
    promedio_valoracion: number | null
    activo: boolean | null
  }

  export type ProductoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    precio_base: number | null
    stock: number | null
    categoria_id: number | null
    promedio_valoracion: number | null
    activo: boolean | null
  }

  export type ProductoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    precio_base: number
    stock: number
    categoria_id: number
    promedio_valoracion: number
    activo: number
    _all: number
  }


  export type ProductoAvgAggregateInputType = {
    id?: true
    precio_base?: true
    stock?: true
    categoria_id?: true
    promedio_valoracion?: true
  }

  export type ProductoSumAggregateInputType = {
    id?: true
    precio_base?: true
    stock?: true
    categoria_id?: true
    promedio_valoracion?: true
  }

  export type ProductoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    precio_base?: true
    stock?: true
    categoria_id?: true
    promedio_valoracion?: true
    activo?: true
  }

  export type ProductoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    precio_base?: true
    stock?: true
    categoria_id?: true
    promedio_valoracion?: true
    activo?: true
  }

  export type ProductoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    precio_base?: true
    stock?: true
    categoria_id?: true
    promedio_valoracion?: true
    activo?: true
    _all?: true
  }

  export type ProductoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Producto to aggregate.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Productos
    **/
    _count?: true | ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductoMaxAggregateInputType
  }

  export type GetProductoAggregateType<T extends ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateProducto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducto[P]>
      : GetScalarType<T[P], AggregateProducto[P]>
  }




  export type ProductoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoWhereInput
    orderBy?: ProductoOrderByWithAggregationInput | ProductoOrderByWithAggregationInput[]
    by: ProductoScalarFieldEnum[] | ProductoScalarFieldEnum
    having?: ProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductoCountAggregateInputType | true
    _avg?: ProductoAvgAggregateInputType
    _sum?: ProductoSumAggregateInputType
    _min?: ProductoMinAggregateInputType
    _max?: ProductoMaxAggregateInputType
  }

  export type ProductoGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    categoria_id: number
    promedio_valoracion: number
    activo: boolean
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  type GetProductoGroupByPayload<T extends ProductoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], ProductoGroupByOutputType[P]>
        }
      >
    >


  export type ProductoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    precio_base?: boolean
    stock?: boolean
    categoria_id?: boolean
    promedio_valoracion?: boolean
    activo?: boolean
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    imagenes?: boolean | Producto$imagenesArgs<ExtArgs>
    etiquetas?: boolean | Producto$etiquetasArgs<ExtArgs>
    resenas?: boolean | Producto$resenasArgs<ExtArgs>
    pedidoItems?: boolean | Producto$pedidoItemsArgs<ExtArgs>
    promociones?: boolean | Producto$promocionesArgs<ExtArgs>
    productosPersonalizables?: boolean | Producto$productosPersonalizablesArgs<ExtArgs>
    _count?: boolean | ProductoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["producto"]>



  export type ProductoSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    precio_base?: boolean
    stock?: boolean
    categoria_id?: boolean
    promedio_valoracion?: boolean
    activo?: boolean
  }

  export type ProductoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "precio_base" | "stock" | "categoria_id" | "promedio_valoracion" | "activo", ExtArgs["result"]["producto"]>
  export type ProductoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    imagenes?: boolean | Producto$imagenesArgs<ExtArgs>
    etiquetas?: boolean | Producto$etiquetasArgs<ExtArgs>
    resenas?: boolean | Producto$resenasArgs<ExtArgs>
    pedidoItems?: boolean | Producto$pedidoItemsArgs<ExtArgs>
    promociones?: boolean | Producto$promocionesArgs<ExtArgs>
    productosPersonalizables?: boolean | Producto$productosPersonalizablesArgs<ExtArgs>
    _count?: boolean | ProductoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Producto"
    objects: {
      categoria: Prisma.$CategoriaPayload<ExtArgs>
      imagenes: Prisma.$ImagenProductoPayload<ExtArgs>[]
      etiquetas: Prisma.$ProductoEtiquetaPayload<ExtArgs>[]
      resenas: Prisma.$ResenaPayload<ExtArgs>[]
      pedidoItems: Prisma.$PedidoItemPayload<ExtArgs>[]
      promociones: Prisma.$PromocionPayload<ExtArgs>[]
      productosPersonalizables: Prisma.$ProductoPersonalizablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string
      precio_base: number
      stock: number
      categoria_id: number
      promedio_valoracion: number
      activo: boolean
    }, ExtArgs["result"]["producto"]>
    composites: {}
  }

  type ProductoGetPayload<S extends boolean | null | undefined | ProductoDefaultArgs> = $Result.GetResult<Prisma.$ProductoPayload, S>

  type ProductoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductoCountAggregateInputType | true
    }

  export interface ProductoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Producto'], meta: { name: 'Producto' } }
    /**
     * Find zero or one Producto that matches the filter.
     * @param {ProductoFindUniqueArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductoFindUniqueArgs>(args: SelectSubset<T, ProductoFindUniqueArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Producto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductoFindUniqueOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductoFindFirstArgs>(args?: SelectSubset<T, ProductoFindFirstArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Producto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.producto.findMany()
     * 
     * // Get first 10 Productos
     * const productos = await prisma.producto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productoWithIdOnly = await prisma.producto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductoFindManyArgs>(args?: SelectSubset<T, ProductoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Producto.
     * @param {ProductoCreateArgs} args - Arguments to create a Producto.
     * @example
     * // Create one Producto
     * const Producto = await prisma.producto.create({
     *   data: {
     *     // ... data to create a Producto
     *   }
     * })
     * 
     */
    create<T extends ProductoCreateArgs>(args: SelectSubset<T, ProductoCreateArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Productos.
     * @param {ProductoCreateManyArgs} args - Arguments to create many Productos.
     * @example
     * // Create many Productos
     * const producto = await prisma.producto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductoCreateManyArgs>(args?: SelectSubset<T, ProductoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Producto.
     * @param {ProductoDeleteArgs} args - Arguments to delete one Producto.
     * @example
     * // Delete one Producto
     * const Producto = await prisma.producto.delete({
     *   where: {
     *     // ... filter to delete one Producto
     *   }
     * })
     * 
     */
    delete<T extends ProductoDeleteArgs>(args: SelectSubset<T, ProductoDeleteArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Producto.
     * @param {ProductoUpdateArgs} args - Arguments to update one Producto.
     * @example
     * // Update one Producto
     * const producto = await prisma.producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductoUpdateArgs>(args: SelectSubset<T, ProductoUpdateArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Productos.
     * @param {ProductoDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductoDeleteManyArgs>(args?: SelectSubset<T, ProductoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const producto = await prisma.producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductoUpdateManyArgs>(args: SelectSubset<T, ProductoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Producto.
     * @param {ProductoUpsertArgs} args - Arguments to update or create a Producto.
     * @example
     * // Update or create a Producto
     * const producto = await prisma.producto.upsert({
     *   create: {
     *     // ... data to create a Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producto we want to update
     *   }
     * })
     */
    upsert<T extends ProductoUpsertArgs>(args: SelectSubset<T, ProductoUpsertArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.producto.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
    **/
    count<T extends ProductoCountArgs>(
      args?: Subset<T, ProductoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductoAggregateArgs>(args: Subset<T, ProductoAggregateArgs>): Prisma.PrismaPromise<GetProductoAggregateType<T>>

    /**
     * Group by Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductoGroupByArgs['orderBy'] }
        : { orderBy?: ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Producto model
   */
  readonly fields: ProductoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categoria<T extends CategoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoriaDefaultArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    imagenes<T extends Producto$imagenesArgs<ExtArgs> = {}>(args?: Subset<T, Producto$imagenesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagenProductoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    etiquetas<T extends Producto$etiquetasArgs<ExtArgs> = {}>(args?: Subset<T, Producto$etiquetasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoEtiquetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resenas<T extends Producto$resenasArgs<ExtArgs> = {}>(args?: Subset<T, Producto$resenasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pedidoItems<T extends Producto$pedidoItemsArgs<ExtArgs> = {}>(args?: Subset<T, Producto$pedidoItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promociones<T extends Producto$promocionesArgs<ExtArgs> = {}>(args?: Subset<T, Producto$promocionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productosPersonalizables<T extends Producto$productosPersonalizablesArgs<ExtArgs> = {}>(args?: Subset<T, Producto$productosPersonalizablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPersonalizablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Producto model
   */
  interface ProductoFieldRefs {
    readonly id: FieldRef<"Producto", 'Int'>
    readonly nombre: FieldRef<"Producto", 'String'>
    readonly descripcion: FieldRef<"Producto", 'String'>
    readonly precio_base: FieldRef<"Producto", 'Float'>
    readonly stock: FieldRef<"Producto", 'Int'>
    readonly categoria_id: FieldRef<"Producto", 'Int'>
    readonly promedio_valoracion: FieldRef<"Producto", 'Float'>
    readonly activo: FieldRef<"Producto", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Producto findUnique
   */
  export type ProductoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto findUniqueOrThrow
   */
  export type ProductoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto findFirst
   */
  export type ProductoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Producto findFirstOrThrow
   */
  export type ProductoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Producto findMany
   */
  export type ProductoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Productos to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Producto create
   */
  export type ProductoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The data needed to create a Producto.
     */
    data: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
  }

  /**
   * Producto createMany
   */
  export type ProductoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Productos.
     */
    data: ProductoCreateManyInput | ProductoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Producto update
   */
  export type ProductoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The data needed to update a Producto.
     */
    data: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
    /**
     * Choose, which Producto to update.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto updateMany
   */
  export type ProductoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Productos.
     */
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Productos to update
     */
    where?: ProductoWhereInput
    /**
     * Limit how many Productos to update.
     */
    limit?: number
  }

  /**
   * Producto upsert
   */
  export type ProductoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The filter to search for the Producto to update in case it exists.
     */
    where: ProductoWhereUniqueInput
    /**
     * In case the Producto found by the `where` argument doesn't exist, create a new Producto with this data.
     */
    create: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
    /**
     * In case the Producto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
  }

  /**
   * Producto delete
   */
  export type ProductoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter which Producto to delete.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto deleteMany
   */
  export type ProductoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Productos to delete
     */
    where?: ProductoWhereInput
    /**
     * Limit how many Productos to delete.
     */
    limit?: number
  }

  /**
   * Producto.imagenes
   */
  export type Producto$imagenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenProducto
     */
    select?: ImagenProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenProducto
     */
    omit?: ImagenProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenProductoInclude<ExtArgs> | null
    where?: ImagenProductoWhereInput
    orderBy?: ImagenProductoOrderByWithRelationInput | ImagenProductoOrderByWithRelationInput[]
    cursor?: ImagenProductoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImagenProductoScalarFieldEnum | ImagenProductoScalarFieldEnum[]
  }

  /**
   * Producto.etiquetas
   */
  export type Producto$etiquetasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoEtiqueta
     */
    select?: ProductoEtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoEtiqueta
     */
    omit?: ProductoEtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoEtiquetaInclude<ExtArgs> | null
    where?: ProductoEtiquetaWhereInput
    orderBy?: ProductoEtiquetaOrderByWithRelationInput | ProductoEtiquetaOrderByWithRelationInput[]
    cursor?: ProductoEtiquetaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductoEtiquetaScalarFieldEnum | ProductoEtiquetaScalarFieldEnum[]
  }

  /**
   * Producto.resenas
   */
  export type Producto$resenasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    where?: ResenaWhereInput
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    cursor?: ResenaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[]
  }

  /**
   * Producto.pedidoItems
   */
  export type Producto$pedidoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    where?: PedidoItemWhereInput
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    cursor?: PedidoItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * Producto.promociones
   */
  export type Producto$promocionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promocion
     */
    omit?: PromocionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    where?: PromocionWhereInput
    orderBy?: PromocionOrderByWithRelationInput | PromocionOrderByWithRelationInput[]
    cursor?: PromocionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromocionScalarFieldEnum | PromocionScalarFieldEnum[]
  }

  /**
   * Producto.productosPersonalizables
   */
  export type Producto$productosPersonalizablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoPersonalizable
     */
    select?: ProductoPersonalizableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoPersonalizable
     */
    omit?: ProductoPersonalizableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoPersonalizableInclude<ExtArgs> | null
    where?: ProductoPersonalizableWhereInput
    orderBy?: ProductoPersonalizableOrderByWithRelationInput | ProductoPersonalizableOrderByWithRelationInput[]
    cursor?: ProductoPersonalizableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductoPersonalizableScalarFieldEnum | ProductoPersonalizableScalarFieldEnum[]
  }

  /**
   * Producto without action
   */
  export type ProductoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
  }


  /**
   * Model ImagenProducto
   */

  export type AggregateImagenProducto = {
    _count: ImagenProductoCountAggregateOutputType | null
    _avg: ImagenProductoAvgAggregateOutputType | null
    _sum: ImagenProductoSumAggregateOutputType | null
    _min: ImagenProductoMinAggregateOutputType | null
    _max: ImagenProductoMaxAggregateOutputType | null
  }

  export type ImagenProductoAvgAggregateOutputType = {
    id: number | null
    producto_id: number | null
  }

  export type ImagenProductoSumAggregateOutputType = {
    id: number | null
    producto_id: number | null
  }

  export type ImagenProductoMinAggregateOutputType = {
    id: number | null
    producto_id: number | null
    url: string | null
  }

  export type ImagenProductoMaxAggregateOutputType = {
    id: number | null
    producto_id: number | null
    url: string | null
  }

  export type ImagenProductoCountAggregateOutputType = {
    id: number
    producto_id: number
    url: number
    _all: number
  }


  export type ImagenProductoAvgAggregateInputType = {
    id?: true
    producto_id?: true
  }

  export type ImagenProductoSumAggregateInputType = {
    id?: true
    producto_id?: true
  }

  export type ImagenProductoMinAggregateInputType = {
    id?: true
    producto_id?: true
    url?: true
  }

  export type ImagenProductoMaxAggregateInputType = {
    id?: true
    producto_id?: true
    url?: true
  }

  export type ImagenProductoCountAggregateInputType = {
    id?: true
    producto_id?: true
    url?: true
    _all?: true
  }

  export type ImagenProductoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImagenProducto to aggregate.
     */
    where?: ImagenProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagenProductos to fetch.
     */
    orderBy?: ImagenProductoOrderByWithRelationInput | ImagenProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImagenProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagenProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagenProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImagenProductos
    **/
    _count?: true | ImagenProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImagenProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImagenProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImagenProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImagenProductoMaxAggregateInputType
  }

  export type GetImagenProductoAggregateType<T extends ImagenProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateImagenProducto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImagenProducto[P]>
      : GetScalarType<T[P], AggregateImagenProducto[P]>
  }




  export type ImagenProductoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImagenProductoWhereInput
    orderBy?: ImagenProductoOrderByWithAggregationInput | ImagenProductoOrderByWithAggregationInput[]
    by: ImagenProductoScalarFieldEnum[] | ImagenProductoScalarFieldEnum
    having?: ImagenProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImagenProductoCountAggregateInputType | true
    _avg?: ImagenProductoAvgAggregateInputType
    _sum?: ImagenProductoSumAggregateInputType
    _min?: ImagenProductoMinAggregateInputType
    _max?: ImagenProductoMaxAggregateInputType
  }

  export type ImagenProductoGroupByOutputType = {
    id: number
    producto_id: number
    url: string
    _count: ImagenProductoCountAggregateOutputType | null
    _avg: ImagenProductoAvgAggregateOutputType | null
    _sum: ImagenProductoSumAggregateOutputType | null
    _min: ImagenProductoMinAggregateOutputType | null
    _max: ImagenProductoMaxAggregateOutputType | null
  }

  type GetImagenProductoGroupByPayload<T extends ImagenProductoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImagenProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImagenProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImagenProductoGroupByOutputType[P]>
            : GetScalarType<T[P], ImagenProductoGroupByOutputType[P]>
        }
      >
    >


  export type ImagenProductoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    producto_id?: boolean
    url?: boolean
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imagenProducto"]>



  export type ImagenProductoSelectScalar = {
    id?: boolean
    producto_id?: boolean
    url?: boolean
  }

  export type ImagenProductoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "producto_id" | "url", ExtArgs["result"]["imagenProducto"]>
  export type ImagenProductoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
  }

  export type $ImagenProductoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImagenProducto"
    objects: {
      producto: Prisma.$ProductoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      producto_id: number
      url: string
    }, ExtArgs["result"]["imagenProducto"]>
    composites: {}
  }

  type ImagenProductoGetPayload<S extends boolean | null | undefined | ImagenProductoDefaultArgs> = $Result.GetResult<Prisma.$ImagenProductoPayload, S>

  type ImagenProductoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImagenProductoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImagenProductoCountAggregateInputType | true
    }

  export interface ImagenProductoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImagenProducto'], meta: { name: 'ImagenProducto' } }
    /**
     * Find zero or one ImagenProducto that matches the filter.
     * @param {ImagenProductoFindUniqueArgs} args - Arguments to find a ImagenProducto
     * @example
     * // Get one ImagenProducto
     * const imagenProducto = await prisma.imagenProducto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImagenProductoFindUniqueArgs>(args: SelectSubset<T, ImagenProductoFindUniqueArgs<ExtArgs>>): Prisma__ImagenProductoClient<$Result.GetResult<Prisma.$ImagenProductoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImagenProducto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImagenProductoFindUniqueOrThrowArgs} args - Arguments to find a ImagenProducto
     * @example
     * // Get one ImagenProducto
     * const imagenProducto = await prisma.imagenProducto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImagenProductoFindUniqueOrThrowArgs>(args: SelectSubset<T, ImagenProductoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImagenProductoClient<$Result.GetResult<Prisma.$ImagenProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImagenProducto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenProductoFindFirstArgs} args - Arguments to find a ImagenProducto
     * @example
     * // Get one ImagenProducto
     * const imagenProducto = await prisma.imagenProducto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImagenProductoFindFirstArgs>(args?: SelectSubset<T, ImagenProductoFindFirstArgs<ExtArgs>>): Prisma__ImagenProductoClient<$Result.GetResult<Prisma.$ImagenProductoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImagenProducto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenProductoFindFirstOrThrowArgs} args - Arguments to find a ImagenProducto
     * @example
     * // Get one ImagenProducto
     * const imagenProducto = await prisma.imagenProducto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImagenProductoFindFirstOrThrowArgs>(args?: SelectSubset<T, ImagenProductoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImagenProductoClient<$Result.GetResult<Prisma.$ImagenProductoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImagenProductos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenProductoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImagenProductos
     * const imagenProductos = await prisma.imagenProducto.findMany()
     * 
     * // Get first 10 ImagenProductos
     * const imagenProductos = await prisma.imagenProducto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imagenProductoWithIdOnly = await prisma.imagenProducto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImagenProductoFindManyArgs>(args?: SelectSubset<T, ImagenProductoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagenProductoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImagenProducto.
     * @param {ImagenProductoCreateArgs} args - Arguments to create a ImagenProducto.
     * @example
     * // Create one ImagenProducto
     * const ImagenProducto = await prisma.imagenProducto.create({
     *   data: {
     *     // ... data to create a ImagenProducto
     *   }
     * })
     * 
     */
    create<T extends ImagenProductoCreateArgs>(args: SelectSubset<T, ImagenProductoCreateArgs<ExtArgs>>): Prisma__ImagenProductoClient<$Result.GetResult<Prisma.$ImagenProductoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImagenProductos.
     * @param {ImagenProductoCreateManyArgs} args - Arguments to create many ImagenProductos.
     * @example
     * // Create many ImagenProductos
     * const imagenProducto = await prisma.imagenProducto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImagenProductoCreateManyArgs>(args?: SelectSubset<T, ImagenProductoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ImagenProducto.
     * @param {ImagenProductoDeleteArgs} args - Arguments to delete one ImagenProducto.
     * @example
     * // Delete one ImagenProducto
     * const ImagenProducto = await prisma.imagenProducto.delete({
     *   where: {
     *     // ... filter to delete one ImagenProducto
     *   }
     * })
     * 
     */
    delete<T extends ImagenProductoDeleteArgs>(args: SelectSubset<T, ImagenProductoDeleteArgs<ExtArgs>>): Prisma__ImagenProductoClient<$Result.GetResult<Prisma.$ImagenProductoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImagenProducto.
     * @param {ImagenProductoUpdateArgs} args - Arguments to update one ImagenProducto.
     * @example
     * // Update one ImagenProducto
     * const imagenProducto = await prisma.imagenProducto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImagenProductoUpdateArgs>(args: SelectSubset<T, ImagenProductoUpdateArgs<ExtArgs>>): Prisma__ImagenProductoClient<$Result.GetResult<Prisma.$ImagenProductoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImagenProductos.
     * @param {ImagenProductoDeleteManyArgs} args - Arguments to filter ImagenProductos to delete.
     * @example
     * // Delete a few ImagenProductos
     * const { count } = await prisma.imagenProducto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImagenProductoDeleteManyArgs>(args?: SelectSubset<T, ImagenProductoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImagenProductos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImagenProductos
     * const imagenProducto = await prisma.imagenProducto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImagenProductoUpdateManyArgs>(args: SelectSubset<T, ImagenProductoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImagenProducto.
     * @param {ImagenProductoUpsertArgs} args - Arguments to update or create a ImagenProducto.
     * @example
     * // Update or create a ImagenProducto
     * const imagenProducto = await prisma.imagenProducto.upsert({
     *   create: {
     *     // ... data to create a ImagenProducto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImagenProducto we want to update
     *   }
     * })
     */
    upsert<T extends ImagenProductoUpsertArgs>(args: SelectSubset<T, ImagenProductoUpsertArgs<ExtArgs>>): Prisma__ImagenProductoClient<$Result.GetResult<Prisma.$ImagenProductoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImagenProductos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenProductoCountArgs} args - Arguments to filter ImagenProductos to count.
     * @example
     * // Count the number of ImagenProductos
     * const count = await prisma.imagenProducto.count({
     *   where: {
     *     // ... the filter for the ImagenProductos we want to count
     *   }
     * })
    **/
    count<T extends ImagenProductoCountArgs>(
      args?: Subset<T, ImagenProductoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImagenProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImagenProducto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImagenProductoAggregateArgs>(args: Subset<T, ImagenProductoAggregateArgs>): Prisma.PrismaPromise<GetImagenProductoAggregateType<T>>

    /**
     * Group by ImagenProducto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagenProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImagenProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImagenProductoGroupByArgs['orderBy'] }
        : { orderBy?: ImagenProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImagenProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImagenProductoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImagenProducto model
   */
  readonly fields: ImagenProductoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImagenProducto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImagenProductoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImagenProducto model
   */
  interface ImagenProductoFieldRefs {
    readonly id: FieldRef<"ImagenProducto", 'Int'>
    readonly producto_id: FieldRef<"ImagenProducto", 'Int'>
    readonly url: FieldRef<"ImagenProducto", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ImagenProducto findUnique
   */
  export type ImagenProductoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenProducto
     */
    select?: ImagenProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenProducto
     */
    omit?: ImagenProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenProductoInclude<ExtArgs> | null
    /**
     * Filter, which ImagenProducto to fetch.
     */
    where: ImagenProductoWhereUniqueInput
  }

  /**
   * ImagenProducto findUniqueOrThrow
   */
  export type ImagenProductoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenProducto
     */
    select?: ImagenProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenProducto
     */
    omit?: ImagenProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenProductoInclude<ExtArgs> | null
    /**
     * Filter, which ImagenProducto to fetch.
     */
    where: ImagenProductoWhereUniqueInput
  }

  /**
   * ImagenProducto findFirst
   */
  export type ImagenProductoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenProducto
     */
    select?: ImagenProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenProducto
     */
    omit?: ImagenProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenProductoInclude<ExtArgs> | null
    /**
     * Filter, which ImagenProducto to fetch.
     */
    where?: ImagenProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagenProductos to fetch.
     */
    orderBy?: ImagenProductoOrderByWithRelationInput | ImagenProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImagenProductos.
     */
    cursor?: ImagenProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagenProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagenProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImagenProductos.
     */
    distinct?: ImagenProductoScalarFieldEnum | ImagenProductoScalarFieldEnum[]
  }

  /**
   * ImagenProducto findFirstOrThrow
   */
  export type ImagenProductoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenProducto
     */
    select?: ImagenProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenProducto
     */
    omit?: ImagenProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenProductoInclude<ExtArgs> | null
    /**
     * Filter, which ImagenProducto to fetch.
     */
    where?: ImagenProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagenProductos to fetch.
     */
    orderBy?: ImagenProductoOrderByWithRelationInput | ImagenProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImagenProductos.
     */
    cursor?: ImagenProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagenProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagenProductos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImagenProductos.
     */
    distinct?: ImagenProductoScalarFieldEnum | ImagenProductoScalarFieldEnum[]
  }

  /**
   * ImagenProducto findMany
   */
  export type ImagenProductoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenProducto
     */
    select?: ImagenProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenProducto
     */
    omit?: ImagenProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenProductoInclude<ExtArgs> | null
    /**
     * Filter, which ImagenProductos to fetch.
     */
    where?: ImagenProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImagenProductos to fetch.
     */
    orderBy?: ImagenProductoOrderByWithRelationInput | ImagenProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImagenProductos.
     */
    cursor?: ImagenProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImagenProductos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImagenProductos.
     */
    skip?: number
    distinct?: ImagenProductoScalarFieldEnum | ImagenProductoScalarFieldEnum[]
  }

  /**
   * ImagenProducto create
   */
  export type ImagenProductoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenProducto
     */
    select?: ImagenProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenProducto
     */
    omit?: ImagenProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenProductoInclude<ExtArgs> | null
    /**
     * The data needed to create a ImagenProducto.
     */
    data: XOR<ImagenProductoCreateInput, ImagenProductoUncheckedCreateInput>
  }

  /**
   * ImagenProducto createMany
   */
  export type ImagenProductoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImagenProductos.
     */
    data: ImagenProductoCreateManyInput | ImagenProductoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImagenProducto update
   */
  export type ImagenProductoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenProducto
     */
    select?: ImagenProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenProducto
     */
    omit?: ImagenProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenProductoInclude<ExtArgs> | null
    /**
     * The data needed to update a ImagenProducto.
     */
    data: XOR<ImagenProductoUpdateInput, ImagenProductoUncheckedUpdateInput>
    /**
     * Choose, which ImagenProducto to update.
     */
    where: ImagenProductoWhereUniqueInput
  }

  /**
   * ImagenProducto updateMany
   */
  export type ImagenProductoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImagenProductos.
     */
    data: XOR<ImagenProductoUpdateManyMutationInput, ImagenProductoUncheckedUpdateManyInput>
    /**
     * Filter which ImagenProductos to update
     */
    where?: ImagenProductoWhereInput
    /**
     * Limit how many ImagenProductos to update.
     */
    limit?: number
  }

  /**
   * ImagenProducto upsert
   */
  export type ImagenProductoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenProducto
     */
    select?: ImagenProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenProducto
     */
    omit?: ImagenProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenProductoInclude<ExtArgs> | null
    /**
     * The filter to search for the ImagenProducto to update in case it exists.
     */
    where: ImagenProductoWhereUniqueInput
    /**
     * In case the ImagenProducto found by the `where` argument doesn't exist, create a new ImagenProducto with this data.
     */
    create: XOR<ImagenProductoCreateInput, ImagenProductoUncheckedCreateInput>
    /**
     * In case the ImagenProducto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImagenProductoUpdateInput, ImagenProductoUncheckedUpdateInput>
  }

  /**
   * ImagenProducto delete
   */
  export type ImagenProductoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenProducto
     */
    select?: ImagenProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenProducto
     */
    omit?: ImagenProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenProductoInclude<ExtArgs> | null
    /**
     * Filter which ImagenProducto to delete.
     */
    where: ImagenProductoWhereUniqueInput
  }

  /**
   * ImagenProducto deleteMany
   */
  export type ImagenProductoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImagenProductos to delete
     */
    where?: ImagenProductoWhereInput
    /**
     * Limit how many ImagenProductos to delete.
     */
    limit?: number
  }

  /**
   * ImagenProducto without action
   */
  export type ImagenProductoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImagenProducto
     */
    select?: ImagenProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImagenProducto
     */
    omit?: ImagenProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagenProductoInclude<ExtArgs> | null
  }


  /**
   * Model ProductoEtiqueta
   */

  export type AggregateProductoEtiqueta = {
    _count: ProductoEtiquetaCountAggregateOutputType | null
    _avg: ProductoEtiquetaAvgAggregateOutputType | null
    _sum: ProductoEtiquetaSumAggregateOutputType | null
    _min: ProductoEtiquetaMinAggregateOutputType | null
    _max: ProductoEtiquetaMaxAggregateOutputType | null
  }

  export type ProductoEtiquetaAvgAggregateOutputType = {
    producto_id: number | null
    etiqueta_id: number | null
  }

  export type ProductoEtiquetaSumAggregateOutputType = {
    producto_id: number | null
    etiqueta_id: number | null
  }

  export type ProductoEtiquetaMinAggregateOutputType = {
    producto_id: number | null
    etiqueta_id: number | null
  }

  export type ProductoEtiquetaMaxAggregateOutputType = {
    producto_id: number | null
    etiqueta_id: number | null
  }

  export type ProductoEtiquetaCountAggregateOutputType = {
    producto_id: number
    etiqueta_id: number
    _all: number
  }


  export type ProductoEtiquetaAvgAggregateInputType = {
    producto_id?: true
    etiqueta_id?: true
  }

  export type ProductoEtiquetaSumAggregateInputType = {
    producto_id?: true
    etiqueta_id?: true
  }

  export type ProductoEtiquetaMinAggregateInputType = {
    producto_id?: true
    etiqueta_id?: true
  }

  export type ProductoEtiquetaMaxAggregateInputType = {
    producto_id?: true
    etiqueta_id?: true
  }

  export type ProductoEtiquetaCountAggregateInputType = {
    producto_id?: true
    etiqueta_id?: true
    _all?: true
  }

  export type ProductoEtiquetaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductoEtiqueta to aggregate.
     */
    where?: ProductoEtiquetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductoEtiquetas to fetch.
     */
    orderBy?: ProductoEtiquetaOrderByWithRelationInput | ProductoEtiquetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductoEtiquetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductoEtiquetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductoEtiquetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductoEtiquetas
    **/
    _count?: true | ProductoEtiquetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductoEtiquetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductoEtiquetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductoEtiquetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductoEtiquetaMaxAggregateInputType
  }

  export type GetProductoEtiquetaAggregateType<T extends ProductoEtiquetaAggregateArgs> = {
        [P in keyof T & keyof AggregateProductoEtiqueta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductoEtiqueta[P]>
      : GetScalarType<T[P], AggregateProductoEtiqueta[P]>
  }




  export type ProductoEtiquetaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoEtiquetaWhereInput
    orderBy?: ProductoEtiquetaOrderByWithAggregationInput | ProductoEtiquetaOrderByWithAggregationInput[]
    by: ProductoEtiquetaScalarFieldEnum[] | ProductoEtiquetaScalarFieldEnum
    having?: ProductoEtiquetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductoEtiquetaCountAggregateInputType | true
    _avg?: ProductoEtiquetaAvgAggregateInputType
    _sum?: ProductoEtiquetaSumAggregateInputType
    _min?: ProductoEtiquetaMinAggregateInputType
    _max?: ProductoEtiquetaMaxAggregateInputType
  }

  export type ProductoEtiquetaGroupByOutputType = {
    producto_id: number
    etiqueta_id: number
    _count: ProductoEtiquetaCountAggregateOutputType | null
    _avg: ProductoEtiquetaAvgAggregateOutputType | null
    _sum: ProductoEtiquetaSumAggregateOutputType | null
    _min: ProductoEtiquetaMinAggregateOutputType | null
    _max: ProductoEtiquetaMaxAggregateOutputType | null
  }

  type GetProductoEtiquetaGroupByPayload<T extends ProductoEtiquetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductoEtiquetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductoEtiquetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductoEtiquetaGroupByOutputType[P]>
            : GetScalarType<T[P], ProductoEtiquetaGroupByOutputType[P]>
        }
      >
    >


  export type ProductoEtiquetaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    producto_id?: boolean
    etiqueta_id?: boolean
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
    etiqueta?: boolean | EtiquetaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productoEtiqueta"]>



  export type ProductoEtiquetaSelectScalar = {
    producto_id?: boolean
    etiqueta_id?: boolean
  }

  export type ProductoEtiquetaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"producto_id" | "etiqueta_id", ExtArgs["result"]["productoEtiqueta"]>
  export type ProductoEtiquetaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
    etiqueta?: boolean | EtiquetaDefaultArgs<ExtArgs>
  }

  export type $ProductoEtiquetaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductoEtiqueta"
    objects: {
      producto: Prisma.$ProductoPayload<ExtArgs>
      etiqueta: Prisma.$EtiquetaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      producto_id: number
      etiqueta_id: number
    }, ExtArgs["result"]["productoEtiqueta"]>
    composites: {}
  }

  type ProductoEtiquetaGetPayload<S extends boolean | null | undefined | ProductoEtiquetaDefaultArgs> = $Result.GetResult<Prisma.$ProductoEtiquetaPayload, S>

  type ProductoEtiquetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductoEtiquetaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductoEtiquetaCountAggregateInputType | true
    }

  export interface ProductoEtiquetaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductoEtiqueta'], meta: { name: 'ProductoEtiqueta' } }
    /**
     * Find zero or one ProductoEtiqueta that matches the filter.
     * @param {ProductoEtiquetaFindUniqueArgs} args - Arguments to find a ProductoEtiqueta
     * @example
     * // Get one ProductoEtiqueta
     * const productoEtiqueta = await prisma.productoEtiqueta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductoEtiquetaFindUniqueArgs>(args: SelectSubset<T, ProductoEtiquetaFindUniqueArgs<ExtArgs>>): Prisma__ProductoEtiquetaClient<$Result.GetResult<Prisma.$ProductoEtiquetaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductoEtiqueta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductoEtiquetaFindUniqueOrThrowArgs} args - Arguments to find a ProductoEtiqueta
     * @example
     * // Get one ProductoEtiqueta
     * const productoEtiqueta = await prisma.productoEtiqueta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductoEtiquetaFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductoEtiquetaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductoEtiquetaClient<$Result.GetResult<Prisma.$ProductoEtiquetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductoEtiqueta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoEtiquetaFindFirstArgs} args - Arguments to find a ProductoEtiqueta
     * @example
     * // Get one ProductoEtiqueta
     * const productoEtiqueta = await prisma.productoEtiqueta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductoEtiquetaFindFirstArgs>(args?: SelectSubset<T, ProductoEtiquetaFindFirstArgs<ExtArgs>>): Prisma__ProductoEtiquetaClient<$Result.GetResult<Prisma.$ProductoEtiquetaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductoEtiqueta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoEtiquetaFindFirstOrThrowArgs} args - Arguments to find a ProductoEtiqueta
     * @example
     * // Get one ProductoEtiqueta
     * const productoEtiqueta = await prisma.productoEtiqueta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductoEtiquetaFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductoEtiquetaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductoEtiquetaClient<$Result.GetResult<Prisma.$ProductoEtiquetaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductoEtiquetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoEtiquetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductoEtiquetas
     * const productoEtiquetas = await prisma.productoEtiqueta.findMany()
     * 
     * // Get first 10 ProductoEtiquetas
     * const productoEtiquetas = await prisma.productoEtiqueta.findMany({ take: 10 })
     * 
     * // Only select the `producto_id`
     * const productoEtiquetaWithProducto_idOnly = await prisma.productoEtiqueta.findMany({ select: { producto_id: true } })
     * 
     */
    findMany<T extends ProductoEtiquetaFindManyArgs>(args?: SelectSubset<T, ProductoEtiquetaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoEtiquetaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductoEtiqueta.
     * @param {ProductoEtiquetaCreateArgs} args - Arguments to create a ProductoEtiqueta.
     * @example
     * // Create one ProductoEtiqueta
     * const ProductoEtiqueta = await prisma.productoEtiqueta.create({
     *   data: {
     *     // ... data to create a ProductoEtiqueta
     *   }
     * })
     * 
     */
    create<T extends ProductoEtiquetaCreateArgs>(args: SelectSubset<T, ProductoEtiquetaCreateArgs<ExtArgs>>): Prisma__ProductoEtiquetaClient<$Result.GetResult<Prisma.$ProductoEtiquetaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductoEtiquetas.
     * @param {ProductoEtiquetaCreateManyArgs} args - Arguments to create many ProductoEtiquetas.
     * @example
     * // Create many ProductoEtiquetas
     * const productoEtiqueta = await prisma.productoEtiqueta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductoEtiquetaCreateManyArgs>(args?: SelectSubset<T, ProductoEtiquetaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductoEtiqueta.
     * @param {ProductoEtiquetaDeleteArgs} args - Arguments to delete one ProductoEtiqueta.
     * @example
     * // Delete one ProductoEtiqueta
     * const ProductoEtiqueta = await prisma.productoEtiqueta.delete({
     *   where: {
     *     // ... filter to delete one ProductoEtiqueta
     *   }
     * })
     * 
     */
    delete<T extends ProductoEtiquetaDeleteArgs>(args: SelectSubset<T, ProductoEtiquetaDeleteArgs<ExtArgs>>): Prisma__ProductoEtiquetaClient<$Result.GetResult<Prisma.$ProductoEtiquetaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductoEtiqueta.
     * @param {ProductoEtiquetaUpdateArgs} args - Arguments to update one ProductoEtiqueta.
     * @example
     * // Update one ProductoEtiqueta
     * const productoEtiqueta = await prisma.productoEtiqueta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductoEtiquetaUpdateArgs>(args: SelectSubset<T, ProductoEtiquetaUpdateArgs<ExtArgs>>): Prisma__ProductoEtiquetaClient<$Result.GetResult<Prisma.$ProductoEtiquetaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductoEtiquetas.
     * @param {ProductoEtiquetaDeleteManyArgs} args - Arguments to filter ProductoEtiquetas to delete.
     * @example
     * // Delete a few ProductoEtiquetas
     * const { count } = await prisma.productoEtiqueta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductoEtiquetaDeleteManyArgs>(args?: SelectSubset<T, ProductoEtiquetaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductoEtiquetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoEtiquetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductoEtiquetas
     * const productoEtiqueta = await prisma.productoEtiqueta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductoEtiquetaUpdateManyArgs>(args: SelectSubset<T, ProductoEtiquetaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductoEtiqueta.
     * @param {ProductoEtiquetaUpsertArgs} args - Arguments to update or create a ProductoEtiqueta.
     * @example
     * // Update or create a ProductoEtiqueta
     * const productoEtiqueta = await prisma.productoEtiqueta.upsert({
     *   create: {
     *     // ... data to create a ProductoEtiqueta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductoEtiqueta we want to update
     *   }
     * })
     */
    upsert<T extends ProductoEtiquetaUpsertArgs>(args: SelectSubset<T, ProductoEtiquetaUpsertArgs<ExtArgs>>): Prisma__ProductoEtiquetaClient<$Result.GetResult<Prisma.$ProductoEtiquetaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductoEtiquetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoEtiquetaCountArgs} args - Arguments to filter ProductoEtiquetas to count.
     * @example
     * // Count the number of ProductoEtiquetas
     * const count = await prisma.productoEtiqueta.count({
     *   where: {
     *     // ... the filter for the ProductoEtiquetas we want to count
     *   }
     * })
    **/
    count<T extends ProductoEtiquetaCountArgs>(
      args?: Subset<T, ProductoEtiquetaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductoEtiquetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductoEtiqueta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoEtiquetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductoEtiquetaAggregateArgs>(args: Subset<T, ProductoEtiquetaAggregateArgs>): Prisma.PrismaPromise<GetProductoEtiquetaAggregateType<T>>

    /**
     * Group by ProductoEtiqueta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoEtiquetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductoEtiquetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductoEtiquetaGroupByArgs['orderBy'] }
        : { orderBy?: ProductoEtiquetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductoEtiquetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductoEtiquetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductoEtiqueta model
   */
  readonly fields: ProductoEtiquetaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductoEtiqueta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductoEtiquetaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    etiqueta<T extends EtiquetaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtiquetaDefaultArgs<ExtArgs>>): Prisma__EtiquetaClient<$Result.GetResult<Prisma.$EtiquetaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductoEtiqueta model
   */
  interface ProductoEtiquetaFieldRefs {
    readonly producto_id: FieldRef<"ProductoEtiqueta", 'Int'>
    readonly etiqueta_id: FieldRef<"ProductoEtiqueta", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductoEtiqueta findUnique
   */
  export type ProductoEtiquetaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoEtiqueta
     */
    select?: ProductoEtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoEtiqueta
     */
    omit?: ProductoEtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoEtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which ProductoEtiqueta to fetch.
     */
    where: ProductoEtiquetaWhereUniqueInput
  }

  /**
   * ProductoEtiqueta findUniqueOrThrow
   */
  export type ProductoEtiquetaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoEtiqueta
     */
    select?: ProductoEtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoEtiqueta
     */
    omit?: ProductoEtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoEtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which ProductoEtiqueta to fetch.
     */
    where: ProductoEtiquetaWhereUniqueInput
  }

  /**
   * ProductoEtiqueta findFirst
   */
  export type ProductoEtiquetaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoEtiqueta
     */
    select?: ProductoEtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoEtiqueta
     */
    omit?: ProductoEtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoEtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which ProductoEtiqueta to fetch.
     */
    where?: ProductoEtiquetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductoEtiquetas to fetch.
     */
    orderBy?: ProductoEtiquetaOrderByWithRelationInput | ProductoEtiquetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductoEtiquetas.
     */
    cursor?: ProductoEtiquetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductoEtiquetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductoEtiquetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductoEtiquetas.
     */
    distinct?: ProductoEtiquetaScalarFieldEnum | ProductoEtiquetaScalarFieldEnum[]
  }

  /**
   * ProductoEtiqueta findFirstOrThrow
   */
  export type ProductoEtiquetaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoEtiqueta
     */
    select?: ProductoEtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoEtiqueta
     */
    omit?: ProductoEtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoEtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which ProductoEtiqueta to fetch.
     */
    where?: ProductoEtiquetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductoEtiquetas to fetch.
     */
    orderBy?: ProductoEtiquetaOrderByWithRelationInput | ProductoEtiquetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductoEtiquetas.
     */
    cursor?: ProductoEtiquetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductoEtiquetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductoEtiquetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductoEtiquetas.
     */
    distinct?: ProductoEtiquetaScalarFieldEnum | ProductoEtiquetaScalarFieldEnum[]
  }

  /**
   * ProductoEtiqueta findMany
   */
  export type ProductoEtiquetaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoEtiqueta
     */
    select?: ProductoEtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoEtiqueta
     */
    omit?: ProductoEtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoEtiquetaInclude<ExtArgs> | null
    /**
     * Filter, which ProductoEtiquetas to fetch.
     */
    where?: ProductoEtiquetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductoEtiquetas to fetch.
     */
    orderBy?: ProductoEtiquetaOrderByWithRelationInput | ProductoEtiquetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductoEtiquetas.
     */
    cursor?: ProductoEtiquetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductoEtiquetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductoEtiquetas.
     */
    skip?: number
    distinct?: ProductoEtiquetaScalarFieldEnum | ProductoEtiquetaScalarFieldEnum[]
  }

  /**
   * ProductoEtiqueta create
   */
  export type ProductoEtiquetaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoEtiqueta
     */
    select?: ProductoEtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoEtiqueta
     */
    omit?: ProductoEtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoEtiquetaInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductoEtiqueta.
     */
    data: XOR<ProductoEtiquetaCreateInput, ProductoEtiquetaUncheckedCreateInput>
  }

  /**
   * ProductoEtiqueta createMany
   */
  export type ProductoEtiquetaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductoEtiquetas.
     */
    data: ProductoEtiquetaCreateManyInput | ProductoEtiquetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductoEtiqueta update
   */
  export type ProductoEtiquetaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoEtiqueta
     */
    select?: ProductoEtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoEtiqueta
     */
    omit?: ProductoEtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoEtiquetaInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductoEtiqueta.
     */
    data: XOR<ProductoEtiquetaUpdateInput, ProductoEtiquetaUncheckedUpdateInput>
    /**
     * Choose, which ProductoEtiqueta to update.
     */
    where: ProductoEtiquetaWhereUniqueInput
  }

  /**
   * ProductoEtiqueta updateMany
   */
  export type ProductoEtiquetaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductoEtiquetas.
     */
    data: XOR<ProductoEtiquetaUpdateManyMutationInput, ProductoEtiquetaUncheckedUpdateManyInput>
    /**
     * Filter which ProductoEtiquetas to update
     */
    where?: ProductoEtiquetaWhereInput
    /**
     * Limit how many ProductoEtiquetas to update.
     */
    limit?: number
  }

  /**
   * ProductoEtiqueta upsert
   */
  export type ProductoEtiquetaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoEtiqueta
     */
    select?: ProductoEtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoEtiqueta
     */
    omit?: ProductoEtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoEtiquetaInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductoEtiqueta to update in case it exists.
     */
    where: ProductoEtiquetaWhereUniqueInput
    /**
     * In case the ProductoEtiqueta found by the `where` argument doesn't exist, create a new ProductoEtiqueta with this data.
     */
    create: XOR<ProductoEtiquetaCreateInput, ProductoEtiquetaUncheckedCreateInput>
    /**
     * In case the ProductoEtiqueta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductoEtiquetaUpdateInput, ProductoEtiquetaUncheckedUpdateInput>
  }

  /**
   * ProductoEtiqueta delete
   */
  export type ProductoEtiquetaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoEtiqueta
     */
    select?: ProductoEtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoEtiqueta
     */
    omit?: ProductoEtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoEtiquetaInclude<ExtArgs> | null
    /**
     * Filter which ProductoEtiqueta to delete.
     */
    where: ProductoEtiquetaWhereUniqueInput
  }

  /**
   * ProductoEtiqueta deleteMany
   */
  export type ProductoEtiquetaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductoEtiquetas to delete
     */
    where?: ProductoEtiquetaWhereInput
    /**
     * Limit how many ProductoEtiquetas to delete.
     */
    limit?: number
  }

  /**
   * ProductoEtiqueta without action
   */
  export type ProductoEtiquetaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoEtiqueta
     */
    select?: ProductoEtiquetaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoEtiqueta
     */
    omit?: ProductoEtiquetaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoEtiquetaInclude<ExtArgs> | null
  }


  /**
   * Model Resena
   */

  export type AggregateResena = {
    _count: ResenaCountAggregateOutputType | null
    _avg: ResenaAvgAggregateOutputType | null
    _sum: ResenaSumAggregateOutputType | null
    _min: ResenaMinAggregateOutputType | null
    _max: ResenaMaxAggregateOutputType | null
  }

  export type ResenaAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    producto_id: number | null
    valoracion: number | null
  }

  export type ResenaSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    producto_id: number | null
    valoracion: number | null
  }

  export type ResenaMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    producto_id: number | null
    comentario: string | null
    valoracion: number | null
    fecha: Date | null
    visible: boolean | null
  }

  export type ResenaMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    producto_id: number | null
    comentario: string | null
    valoracion: number | null
    fecha: Date | null
    visible: boolean | null
  }

  export type ResenaCountAggregateOutputType = {
    id: number
    usuario_id: number
    producto_id: number
    comentario: number
    valoracion: number
    fecha: number
    visible: number
    _all: number
  }


  export type ResenaAvgAggregateInputType = {
    id?: true
    usuario_id?: true
    producto_id?: true
    valoracion?: true
  }

  export type ResenaSumAggregateInputType = {
    id?: true
    usuario_id?: true
    producto_id?: true
    valoracion?: true
  }

  export type ResenaMinAggregateInputType = {
    id?: true
    usuario_id?: true
    producto_id?: true
    comentario?: true
    valoracion?: true
    fecha?: true
    visible?: true
  }

  export type ResenaMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    producto_id?: true
    comentario?: true
    valoracion?: true
    fecha?: true
    visible?: true
  }

  export type ResenaCountAggregateInputType = {
    id?: true
    usuario_id?: true
    producto_id?: true
    comentario?: true
    valoracion?: true
    fecha?: true
    visible?: true
    _all?: true
  }

  export type ResenaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resena to aggregate.
     */
    where?: ResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resenas
    **/
    _count?: true | ResenaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResenaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResenaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResenaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResenaMaxAggregateInputType
  }

  export type GetResenaAggregateType<T extends ResenaAggregateArgs> = {
        [P in keyof T & keyof AggregateResena]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResena[P]>
      : GetScalarType<T[P], AggregateResena[P]>
  }




  export type ResenaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResenaWhereInput
    orderBy?: ResenaOrderByWithAggregationInput | ResenaOrderByWithAggregationInput[]
    by: ResenaScalarFieldEnum[] | ResenaScalarFieldEnum
    having?: ResenaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResenaCountAggregateInputType | true
    _avg?: ResenaAvgAggregateInputType
    _sum?: ResenaSumAggregateInputType
    _min?: ResenaMinAggregateInputType
    _max?: ResenaMaxAggregateInputType
  }

  export type ResenaGroupByOutputType = {
    id: number
    usuario_id: number
    producto_id: number
    comentario: string
    valoracion: number
    fecha: Date
    visible: boolean
    _count: ResenaCountAggregateOutputType | null
    _avg: ResenaAvgAggregateOutputType | null
    _sum: ResenaSumAggregateOutputType | null
    _min: ResenaMinAggregateOutputType | null
    _max: ResenaMaxAggregateOutputType | null
  }

  type GetResenaGroupByPayload<T extends ResenaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResenaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResenaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResenaGroupByOutputType[P]>
            : GetScalarType<T[P], ResenaGroupByOutputType[P]>
        }
      >
    >


  export type ResenaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    producto_id?: boolean
    comentario?: boolean
    valoracion?: boolean
    fecha?: boolean
    visible?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
    reportes?: boolean | Resena$reportesArgs<ExtArgs>
    _count?: boolean | ResenaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resena"]>



  export type ResenaSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    producto_id?: boolean
    comentario?: boolean
    valoracion?: boolean
    fecha?: boolean
    visible?: boolean
  }

  export type ResenaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "producto_id" | "comentario" | "valoracion" | "fecha" | "visible", ExtArgs["result"]["resena"]>
  export type ResenaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
    reportes?: boolean | Resena$reportesArgs<ExtArgs>
    _count?: boolean | ResenaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ResenaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resena"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      producto: Prisma.$ProductoPayload<ExtArgs>
      reportes: Prisma.$ReporteResenaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      producto_id: number
      comentario: string
      valoracion: number
      fecha: Date
      visible: boolean
    }, ExtArgs["result"]["resena"]>
    composites: {}
  }

  type ResenaGetPayload<S extends boolean | null | undefined | ResenaDefaultArgs> = $Result.GetResult<Prisma.$ResenaPayload, S>

  type ResenaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResenaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResenaCountAggregateInputType | true
    }

  export interface ResenaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resena'], meta: { name: 'Resena' } }
    /**
     * Find zero or one Resena that matches the filter.
     * @param {ResenaFindUniqueArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResenaFindUniqueArgs>(args: SelectSubset<T, ResenaFindUniqueArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resena that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResenaFindUniqueOrThrowArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResenaFindUniqueOrThrowArgs>(args: SelectSubset<T, ResenaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resena that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaFindFirstArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResenaFindFirstArgs>(args?: SelectSubset<T, ResenaFindFirstArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resena that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaFindFirstOrThrowArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResenaFindFirstOrThrowArgs>(args?: SelectSubset<T, ResenaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resenas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resenas
     * const resenas = await prisma.resena.findMany()
     * 
     * // Get first 10 Resenas
     * const resenas = await prisma.resena.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resenaWithIdOnly = await prisma.resena.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResenaFindManyArgs>(args?: SelectSubset<T, ResenaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resena.
     * @param {ResenaCreateArgs} args - Arguments to create a Resena.
     * @example
     * // Create one Resena
     * const Resena = await prisma.resena.create({
     *   data: {
     *     // ... data to create a Resena
     *   }
     * })
     * 
     */
    create<T extends ResenaCreateArgs>(args: SelectSubset<T, ResenaCreateArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resenas.
     * @param {ResenaCreateManyArgs} args - Arguments to create many Resenas.
     * @example
     * // Create many Resenas
     * const resena = await prisma.resena.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResenaCreateManyArgs>(args?: SelectSubset<T, ResenaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Resena.
     * @param {ResenaDeleteArgs} args - Arguments to delete one Resena.
     * @example
     * // Delete one Resena
     * const Resena = await prisma.resena.delete({
     *   where: {
     *     // ... filter to delete one Resena
     *   }
     * })
     * 
     */
    delete<T extends ResenaDeleteArgs>(args: SelectSubset<T, ResenaDeleteArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resena.
     * @param {ResenaUpdateArgs} args - Arguments to update one Resena.
     * @example
     * // Update one Resena
     * const resena = await prisma.resena.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResenaUpdateArgs>(args: SelectSubset<T, ResenaUpdateArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resenas.
     * @param {ResenaDeleteManyArgs} args - Arguments to filter Resenas to delete.
     * @example
     * // Delete a few Resenas
     * const { count } = await prisma.resena.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResenaDeleteManyArgs>(args?: SelectSubset<T, ResenaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resenas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resenas
     * const resena = await prisma.resena.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResenaUpdateManyArgs>(args: SelectSubset<T, ResenaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Resena.
     * @param {ResenaUpsertArgs} args - Arguments to update or create a Resena.
     * @example
     * // Update or create a Resena
     * const resena = await prisma.resena.upsert({
     *   create: {
     *     // ... data to create a Resena
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resena we want to update
     *   }
     * })
     */
    upsert<T extends ResenaUpsertArgs>(args: SelectSubset<T, ResenaUpsertArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resenas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaCountArgs} args - Arguments to filter Resenas to count.
     * @example
     * // Count the number of Resenas
     * const count = await prisma.resena.count({
     *   where: {
     *     // ... the filter for the Resenas we want to count
     *   }
     * })
    **/
    count<T extends ResenaCountArgs>(
      args?: Subset<T, ResenaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResenaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resena.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResenaAggregateArgs>(args: Subset<T, ResenaAggregateArgs>): Prisma.PrismaPromise<GetResenaAggregateType<T>>

    /**
     * Group by Resena.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResenaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResenaGroupByArgs['orderBy'] }
        : { orderBy?: ResenaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResenaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResenaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resena model
   */
  readonly fields: ResenaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resena.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResenaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reportes<T extends Resena$reportesArgs<ExtArgs> = {}>(args?: Subset<T, Resena$reportesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReporteResenaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resena model
   */
  interface ResenaFieldRefs {
    readonly id: FieldRef<"Resena", 'Int'>
    readonly usuario_id: FieldRef<"Resena", 'Int'>
    readonly producto_id: FieldRef<"Resena", 'Int'>
    readonly comentario: FieldRef<"Resena", 'String'>
    readonly valoracion: FieldRef<"Resena", 'Int'>
    readonly fecha: FieldRef<"Resena", 'DateTime'>
    readonly visible: FieldRef<"Resena", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Resena findUnique
   */
  export type ResenaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resena to fetch.
     */
    where: ResenaWhereUniqueInput
  }

  /**
   * Resena findUniqueOrThrow
   */
  export type ResenaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resena to fetch.
     */
    where: ResenaWhereUniqueInput
  }

  /**
   * Resena findFirst
   */
  export type ResenaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resena to fetch.
     */
    where?: ResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resenas.
     */
    cursor?: ResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resenas.
     */
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[]
  }

  /**
   * Resena findFirstOrThrow
   */
  export type ResenaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resena to fetch.
     */
    where?: ResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resenas.
     */
    cursor?: ResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resenas.
     */
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[]
  }

  /**
   * Resena findMany
   */
  export type ResenaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resenas to fetch.
     */
    where?: ResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resenas.
     */
    cursor?: ResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resenas.
     */
    skip?: number
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[]
  }

  /**
   * Resena create
   */
  export type ResenaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * The data needed to create a Resena.
     */
    data: XOR<ResenaCreateInput, ResenaUncheckedCreateInput>
  }

  /**
   * Resena createMany
   */
  export type ResenaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resenas.
     */
    data: ResenaCreateManyInput | ResenaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resena update
   */
  export type ResenaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * The data needed to update a Resena.
     */
    data: XOR<ResenaUpdateInput, ResenaUncheckedUpdateInput>
    /**
     * Choose, which Resena to update.
     */
    where: ResenaWhereUniqueInput
  }

  /**
   * Resena updateMany
   */
  export type ResenaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resenas.
     */
    data: XOR<ResenaUpdateManyMutationInput, ResenaUncheckedUpdateManyInput>
    /**
     * Filter which Resenas to update
     */
    where?: ResenaWhereInput
    /**
     * Limit how many Resenas to update.
     */
    limit?: number
  }

  /**
   * Resena upsert
   */
  export type ResenaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * The filter to search for the Resena to update in case it exists.
     */
    where: ResenaWhereUniqueInput
    /**
     * In case the Resena found by the `where` argument doesn't exist, create a new Resena with this data.
     */
    create: XOR<ResenaCreateInput, ResenaUncheckedCreateInput>
    /**
     * In case the Resena was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResenaUpdateInput, ResenaUncheckedUpdateInput>
  }

  /**
   * Resena delete
   */
  export type ResenaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter which Resena to delete.
     */
    where: ResenaWhereUniqueInput
  }

  /**
   * Resena deleteMany
   */
  export type ResenaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resenas to delete
     */
    where?: ResenaWhereInput
    /**
     * Limit how many Resenas to delete.
     */
    limit?: number
  }

  /**
   * Resena.reportes
   */
  export type Resena$reportesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReporteResena
     */
    select?: ReporteResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReporteResena
     */
    omit?: ReporteResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteResenaInclude<ExtArgs> | null
    where?: ReporteResenaWhereInput
    orderBy?: ReporteResenaOrderByWithRelationInput | ReporteResenaOrderByWithRelationInput[]
    cursor?: ReporteResenaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReporteResenaScalarFieldEnum | ReporteResenaScalarFieldEnum[]
  }

  /**
   * Resena without action
   */
  export type ResenaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
  }


  /**
   * Model ProductoPersonalizable
   */

  export type AggregateProductoPersonalizable = {
    _count: ProductoPersonalizableCountAggregateOutputType | null
    _avg: ProductoPersonalizableAvgAggregateOutputType | null
    _sum: ProductoPersonalizableSumAggregateOutputType | null
    _min: ProductoPersonalizableMinAggregateOutputType | null
    _max: ProductoPersonalizableMaxAggregateOutputType | null
  }

  export type ProductoPersonalizableAvgAggregateOutputType = {
    id: number | null
    id_categoria: number | null
    id_producto_base: number | null
  }

  export type ProductoPersonalizableSumAggregateOutputType = {
    id: number | null
    id_categoria: number | null
    id_producto_base: number | null
  }

  export type ProductoPersonalizableMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion_general: string | null
    id_categoria: number | null
    id_producto_base: number | null
    activo: boolean | null
  }

  export type ProductoPersonalizableMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion_general: string | null
    id_categoria: number | null
    id_producto_base: number | null
    activo: boolean | null
  }

  export type ProductoPersonalizableCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion_general: number
    id_categoria: number
    id_producto_base: number
    activo: number
    _all: number
  }


  export type ProductoPersonalizableAvgAggregateInputType = {
    id?: true
    id_categoria?: true
    id_producto_base?: true
  }

  export type ProductoPersonalizableSumAggregateInputType = {
    id?: true
    id_categoria?: true
    id_producto_base?: true
  }

  export type ProductoPersonalizableMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion_general?: true
    id_categoria?: true
    id_producto_base?: true
    activo?: true
  }

  export type ProductoPersonalizableMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion_general?: true
    id_categoria?: true
    id_producto_base?: true
    activo?: true
  }

  export type ProductoPersonalizableCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion_general?: true
    id_categoria?: true
    id_producto_base?: true
    activo?: true
    _all?: true
  }

  export type ProductoPersonalizableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductoPersonalizable to aggregate.
     */
    where?: ProductoPersonalizableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductoPersonalizables to fetch.
     */
    orderBy?: ProductoPersonalizableOrderByWithRelationInput | ProductoPersonalizableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductoPersonalizableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductoPersonalizables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductoPersonalizables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductoPersonalizables
    **/
    _count?: true | ProductoPersonalizableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductoPersonalizableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductoPersonalizableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductoPersonalizableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductoPersonalizableMaxAggregateInputType
  }

  export type GetProductoPersonalizableAggregateType<T extends ProductoPersonalizableAggregateArgs> = {
        [P in keyof T & keyof AggregateProductoPersonalizable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductoPersonalizable[P]>
      : GetScalarType<T[P], AggregateProductoPersonalizable[P]>
  }




  export type ProductoPersonalizableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoPersonalizableWhereInput
    orderBy?: ProductoPersonalizableOrderByWithAggregationInput | ProductoPersonalizableOrderByWithAggregationInput[]
    by: ProductoPersonalizableScalarFieldEnum[] | ProductoPersonalizableScalarFieldEnum
    having?: ProductoPersonalizableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductoPersonalizableCountAggregateInputType | true
    _avg?: ProductoPersonalizableAvgAggregateInputType
    _sum?: ProductoPersonalizableSumAggregateInputType
    _min?: ProductoPersonalizableMinAggregateInputType
    _max?: ProductoPersonalizableMaxAggregateInputType
  }

  export type ProductoPersonalizableGroupByOutputType = {
    id: number
    nombre: string
    descripcion_general: string
    id_categoria: number
    id_producto_base: number
    activo: boolean
    _count: ProductoPersonalizableCountAggregateOutputType | null
    _avg: ProductoPersonalizableAvgAggregateOutputType | null
    _sum: ProductoPersonalizableSumAggregateOutputType | null
    _min: ProductoPersonalizableMinAggregateOutputType | null
    _max: ProductoPersonalizableMaxAggregateOutputType | null
  }

  type GetProductoPersonalizableGroupByPayload<T extends ProductoPersonalizableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductoPersonalizableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductoPersonalizableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductoPersonalizableGroupByOutputType[P]>
            : GetScalarType<T[P], ProductoPersonalizableGroupByOutputType[P]>
        }
      >
    >


  export type ProductoPersonalizableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion_general?: boolean
    id_categoria?: boolean
    id_producto_base?: boolean
    activo?: boolean
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    producto_base?: boolean | ProductoDefaultArgs<ExtArgs>
    pedidoItems?: boolean | ProductoPersonalizable$pedidoItemsArgs<ExtArgs>
    variantes?: boolean | ProductoPersonalizable$variantesArgs<ExtArgs>
    _count?: boolean | ProductoPersonalizableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productoPersonalizable"]>



  export type ProductoPersonalizableSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion_general?: boolean
    id_categoria?: boolean
    id_producto_base?: boolean
    activo?: boolean
  }

  export type ProductoPersonalizableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion_general" | "id_categoria" | "id_producto_base" | "activo", ExtArgs["result"]["productoPersonalizable"]>
  export type ProductoPersonalizableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    producto_base?: boolean | ProductoDefaultArgs<ExtArgs>
    pedidoItems?: boolean | ProductoPersonalizable$pedidoItemsArgs<ExtArgs>
    variantes?: boolean | ProductoPersonalizable$variantesArgs<ExtArgs>
    _count?: boolean | ProductoPersonalizableCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductoPersonalizablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductoPersonalizable"
    objects: {
      categoria: Prisma.$CategoriaPayload<ExtArgs>
      producto_base: Prisma.$ProductoPayload<ExtArgs>
      pedidoItems: Prisma.$PedidoItemPayload<ExtArgs>[]
      variantes: Prisma.$VarianteDetallePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion_general: string
      id_categoria: number
      id_producto_base: number
      activo: boolean
    }, ExtArgs["result"]["productoPersonalizable"]>
    composites: {}
  }

  type ProductoPersonalizableGetPayload<S extends boolean | null | undefined | ProductoPersonalizableDefaultArgs> = $Result.GetResult<Prisma.$ProductoPersonalizablePayload, S>

  type ProductoPersonalizableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductoPersonalizableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductoPersonalizableCountAggregateInputType | true
    }

  export interface ProductoPersonalizableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductoPersonalizable'], meta: { name: 'ProductoPersonalizable' } }
    /**
     * Find zero or one ProductoPersonalizable that matches the filter.
     * @param {ProductoPersonalizableFindUniqueArgs} args - Arguments to find a ProductoPersonalizable
     * @example
     * // Get one ProductoPersonalizable
     * const productoPersonalizable = await prisma.productoPersonalizable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductoPersonalizableFindUniqueArgs>(args: SelectSubset<T, ProductoPersonalizableFindUniqueArgs<ExtArgs>>): Prisma__ProductoPersonalizableClient<$Result.GetResult<Prisma.$ProductoPersonalizablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductoPersonalizable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductoPersonalizableFindUniqueOrThrowArgs} args - Arguments to find a ProductoPersonalizable
     * @example
     * // Get one ProductoPersonalizable
     * const productoPersonalizable = await prisma.productoPersonalizable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductoPersonalizableFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductoPersonalizableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductoPersonalizableClient<$Result.GetResult<Prisma.$ProductoPersonalizablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductoPersonalizable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoPersonalizableFindFirstArgs} args - Arguments to find a ProductoPersonalizable
     * @example
     * // Get one ProductoPersonalizable
     * const productoPersonalizable = await prisma.productoPersonalizable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductoPersonalizableFindFirstArgs>(args?: SelectSubset<T, ProductoPersonalizableFindFirstArgs<ExtArgs>>): Prisma__ProductoPersonalizableClient<$Result.GetResult<Prisma.$ProductoPersonalizablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductoPersonalizable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoPersonalizableFindFirstOrThrowArgs} args - Arguments to find a ProductoPersonalizable
     * @example
     * // Get one ProductoPersonalizable
     * const productoPersonalizable = await prisma.productoPersonalizable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductoPersonalizableFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductoPersonalizableFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductoPersonalizableClient<$Result.GetResult<Prisma.$ProductoPersonalizablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductoPersonalizables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoPersonalizableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductoPersonalizables
     * const productoPersonalizables = await prisma.productoPersonalizable.findMany()
     * 
     * // Get first 10 ProductoPersonalizables
     * const productoPersonalizables = await prisma.productoPersonalizable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productoPersonalizableWithIdOnly = await prisma.productoPersonalizable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductoPersonalizableFindManyArgs>(args?: SelectSubset<T, ProductoPersonalizableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPersonalizablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductoPersonalizable.
     * @param {ProductoPersonalizableCreateArgs} args - Arguments to create a ProductoPersonalizable.
     * @example
     * // Create one ProductoPersonalizable
     * const ProductoPersonalizable = await prisma.productoPersonalizable.create({
     *   data: {
     *     // ... data to create a ProductoPersonalizable
     *   }
     * })
     * 
     */
    create<T extends ProductoPersonalizableCreateArgs>(args: SelectSubset<T, ProductoPersonalizableCreateArgs<ExtArgs>>): Prisma__ProductoPersonalizableClient<$Result.GetResult<Prisma.$ProductoPersonalizablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductoPersonalizables.
     * @param {ProductoPersonalizableCreateManyArgs} args - Arguments to create many ProductoPersonalizables.
     * @example
     * // Create many ProductoPersonalizables
     * const productoPersonalizable = await prisma.productoPersonalizable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductoPersonalizableCreateManyArgs>(args?: SelectSubset<T, ProductoPersonalizableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductoPersonalizable.
     * @param {ProductoPersonalizableDeleteArgs} args - Arguments to delete one ProductoPersonalizable.
     * @example
     * // Delete one ProductoPersonalizable
     * const ProductoPersonalizable = await prisma.productoPersonalizable.delete({
     *   where: {
     *     // ... filter to delete one ProductoPersonalizable
     *   }
     * })
     * 
     */
    delete<T extends ProductoPersonalizableDeleteArgs>(args: SelectSubset<T, ProductoPersonalizableDeleteArgs<ExtArgs>>): Prisma__ProductoPersonalizableClient<$Result.GetResult<Prisma.$ProductoPersonalizablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductoPersonalizable.
     * @param {ProductoPersonalizableUpdateArgs} args - Arguments to update one ProductoPersonalizable.
     * @example
     * // Update one ProductoPersonalizable
     * const productoPersonalizable = await prisma.productoPersonalizable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductoPersonalizableUpdateArgs>(args: SelectSubset<T, ProductoPersonalizableUpdateArgs<ExtArgs>>): Prisma__ProductoPersonalizableClient<$Result.GetResult<Prisma.$ProductoPersonalizablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductoPersonalizables.
     * @param {ProductoPersonalizableDeleteManyArgs} args - Arguments to filter ProductoPersonalizables to delete.
     * @example
     * // Delete a few ProductoPersonalizables
     * const { count } = await prisma.productoPersonalizable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductoPersonalizableDeleteManyArgs>(args?: SelectSubset<T, ProductoPersonalizableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductoPersonalizables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoPersonalizableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductoPersonalizables
     * const productoPersonalizable = await prisma.productoPersonalizable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductoPersonalizableUpdateManyArgs>(args: SelectSubset<T, ProductoPersonalizableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductoPersonalizable.
     * @param {ProductoPersonalizableUpsertArgs} args - Arguments to update or create a ProductoPersonalizable.
     * @example
     * // Update or create a ProductoPersonalizable
     * const productoPersonalizable = await prisma.productoPersonalizable.upsert({
     *   create: {
     *     // ... data to create a ProductoPersonalizable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductoPersonalizable we want to update
     *   }
     * })
     */
    upsert<T extends ProductoPersonalizableUpsertArgs>(args: SelectSubset<T, ProductoPersonalizableUpsertArgs<ExtArgs>>): Prisma__ProductoPersonalizableClient<$Result.GetResult<Prisma.$ProductoPersonalizablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductoPersonalizables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoPersonalizableCountArgs} args - Arguments to filter ProductoPersonalizables to count.
     * @example
     * // Count the number of ProductoPersonalizables
     * const count = await prisma.productoPersonalizable.count({
     *   where: {
     *     // ... the filter for the ProductoPersonalizables we want to count
     *   }
     * })
    **/
    count<T extends ProductoPersonalizableCountArgs>(
      args?: Subset<T, ProductoPersonalizableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductoPersonalizableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductoPersonalizable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoPersonalizableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductoPersonalizableAggregateArgs>(args: Subset<T, ProductoPersonalizableAggregateArgs>): Prisma.PrismaPromise<GetProductoPersonalizableAggregateType<T>>

    /**
     * Group by ProductoPersonalizable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoPersonalizableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductoPersonalizableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductoPersonalizableGroupByArgs['orderBy'] }
        : { orderBy?: ProductoPersonalizableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductoPersonalizableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductoPersonalizableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductoPersonalizable model
   */
  readonly fields: ProductoPersonalizableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductoPersonalizable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductoPersonalizableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categoria<T extends CategoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoriaDefaultArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    producto_base<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pedidoItems<T extends ProductoPersonalizable$pedidoItemsArgs<ExtArgs> = {}>(args?: Subset<T, ProductoPersonalizable$pedidoItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    variantes<T extends ProductoPersonalizable$variantesArgs<ExtArgs> = {}>(args?: Subset<T, ProductoPersonalizable$variantesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VarianteDetallePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductoPersonalizable model
   */
  interface ProductoPersonalizableFieldRefs {
    readonly id: FieldRef<"ProductoPersonalizable", 'Int'>
    readonly nombre: FieldRef<"ProductoPersonalizable", 'String'>
    readonly descripcion_general: FieldRef<"ProductoPersonalizable", 'String'>
    readonly id_categoria: FieldRef<"ProductoPersonalizable", 'Int'>
    readonly id_producto_base: FieldRef<"ProductoPersonalizable", 'Int'>
    readonly activo: FieldRef<"ProductoPersonalizable", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ProductoPersonalizable findUnique
   */
  export type ProductoPersonalizableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoPersonalizable
     */
    select?: ProductoPersonalizableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoPersonalizable
     */
    omit?: ProductoPersonalizableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoPersonalizableInclude<ExtArgs> | null
    /**
     * Filter, which ProductoPersonalizable to fetch.
     */
    where: ProductoPersonalizableWhereUniqueInput
  }

  /**
   * ProductoPersonalizable findUniqueOrThrow
   */
  export type ProductoPersonalizableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoPersonalizable
     */
    select?: ProductoPersonalizableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoPersonalizable
     */
    omit?: ProductoPersonalizableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoPersonalizableInclude<ExtArgs> | null
    /**
     * Filter, which ProductoPersonalizable to fetch.
     */
    where: ProductoPersonalizableWhereUniqueInput
  }

  /**
   * ProductoPersonalizable findFirst
   */
  export type ProductoPersonalizableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoPersonalizable
     */
    select?: ProductoPersonalizableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoPersonalizable
     */
    omit?: ProductoPersonalizableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoPersonalizableInclude<ExtArgs> | null
    /**
     * Filter, which ProductoPersonalizable to fetch.
     */
    where?: ProductoPersonalizableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductoPersonalizables to fetch.
     */
    orderBy?: ProductoPersonalizableOrderByWithRelationInput | ProductoPersonalizableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductoPersonalizables.
     */
    cursor?: ProductoPersonalizableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductoPersonalizables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductoPersonalizables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductoPersonalizables.
     */
    distinct?: ProductoPersonalizableScalarFieldEnum | ProductoPersonalizableScalarFieldEnum[]
  }

  /**
   * ProductoPersonalizable findFirstOrThrow
   */
  export type ProductoPersonalizableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoPersonalizable
     */
    select?: ProductoPersonalizableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoPersonalizable
     */
    omit?: ProductoPersonalizableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoPersonalizableInclude<ExtArgs> | null
    /**
     * Filter, which ProductoPersonalizable to fetch.
     */
    where?: ProductoPersonalizableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductoPersonalizables to fetch.
     */
    orderBy?: ProductoPersonalizableOrderByWithRelationInput | ProductoPersonalizableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductoPersonalizables.
     */
    cursor?: ProductoPersonalizableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductoPersonalizables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductoPersonalizables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductoPersonalizables.
     */
    distinct?: ProductoPersonalizableScalarFieldEnum | ProductoPersonalizableScalarFieldEnum[]
  }

  /**
   * ProductoPersonalizable findMany
   */
  export type ProductoPersonalizableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoPersonalizable
     */
    select?: ProductoPersonalizableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoPersonalizable
     */
    omit?: ProductoPersonalizableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoPersonalizableInclude<ExtArgs> | null
    /**
     * Filter, which ProductoPersonalizables to fetch.
     */
    where?: ProductoPersonalizableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductoPersonalizables to fetch.
     */
    orderBy?: ProductoPersonalizableOrderByWithRelationInput | ProductoPersonalizableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductoPersonalizables.
     */
    cursor?: ProductoPersonalizableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductoPersonalizables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductoPersonalizables.
     */
    skip?: number
    distinct?: ProductoPersonalizableScalarFieldEnum | ProductoPersonalizableScalarFieldEnum[]
  }

  /**
   * ProductoPersonalizable create
   */
  export type ProductoPersonalizableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoPersonalizable
     */
    select?: ProductoPersonalizableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoPersonalizable
     */
    omit?: ProductoPersonalizableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoPersonalizableInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductoPersonalizable.
     */
    data: XOR<ProductoPersonalizableCreateInput, ProductoPersonalizableUncheckedCreateInput>
  }

  /**
   * ProductoPersonalizable createMany
   */
  export type ProductoPersonalizableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductoPersonalizables.
     */
    data: ProductoPersonalizableCreateManyInput | ProductoPersonalizableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductoPersonalizable update
   */
  export type ProductoPersonalizableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoPersonalizable
     */
    select?: ProductoPersonalizableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoPersonalizable
     */
    omit?: ProductoPersonalizableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoPersonalizableInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductoPersonalizable.
     */
    data: XOR<ProductoPersonalizableUpdateInput, ProductoPersonalizableUncheckedUpdateInput>
    /**
     * Choose, which ProductoPersonalizable to update.
     */
    where: ProductoPersonalizableWhereUniqueInput
  }

  /**
   * ProductoPersonalizable updateMany
   */
  export type ProductoPersonalizableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductoPersonalizables.
     */
    data: XOR<ProductoPersonalizableUpdateManyMutationInput, ProductoPersonalizableUncheckedUpdateManyInput>
    /**
     * Filter which ProductoPersonalizables to update
     */
    where?: ProductoPersonalizableWhereInput
    /**
     * Limit how many ProductoPersonalizables to update.
     */
    limit?: number
  }

  /**
   * ProductoPersonalizable upsert
   */
  export type ProductoPersonalizableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoPersonalizable
     */
    select?: ProductoPersonalizableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoPersonalizable
     */
    omit?: ProductoPersonalizableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoPersonalizableInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductoPersonalizable to update in case it exists.
     */
    where: ProductoPersonalizableWhereUniqueInput
    /**
     * In case the ProductoPersonalizable found by the `where` argument doesn't exist, create a new ProductoPersonalizable with this data.
     */
    create: XOR<ProductoPersonalizableCreateInput, ProductoPersonalizableUncheckedCreateInput>
    /**
     * In case the ProductoPersonalizable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductoPersonalizableUpdateInput, ProductoPersonalizableUncheckedUpdateInput>
  }

  /**
   * ProductoPersonalizable delete
   */
  export type ProductoPersonalizableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoPersonalizable
     */
    select?: ProductoPersonalizableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoPersonalizable
     */
    omit?: ProductoPersonalizableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoPersonalizableInclude<ExtArgs> | null
    /**
     * Filter which ProductoPersonalizable to delete.
     */
    where: ProductoPersonalizableWhereUniqueInput
  }

  /**
   * ProductoPersonalizable deleteMany
   */
  export type ProductoPersonalizableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductoPersonalizables to delete
     */
    where?: ProductoPersonalizableWhereInput
    /**
     * Limit how many ProductoPersonalizables to delete.
     */
    limit?: number
  }

  /**
   * ProductoPersonalizable.pedidoItems
   */
  export type ProductoPersonalizable$pedidoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    where?: PedidoItemWhereInput
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    cursor?: PedidoItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * ProductoPersonalizable.variantes
   */
  export type ProductoPersonalizable$variantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianteDetalle
     */
    select?: VarianteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianteDetalle
     */
    omit?: VarianteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianteDetalleInclude<ExtArgs> | null
    where?: VarianteDetalleWhereInput
    orderBy?: VarianteDetalleOrderByWithRelationInput | VarianteDetalleOrderByWithRelationInput[]
    cursor?: VarianteDetalleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VarianteDetalleScalarFieldEnum | VarianteDetalleScalarFieldEnum[]
  }

  /**
   * ProductoPersonalizable without action
   */
  export type ProductoPersonalizableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoPersonalizable
     */
    select?: ProductoPersonalizableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoPersonalizable
     */
    omit?: ProductoPersonalizableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoPersonalizableInclude<ExtArgs> | null
  }


  /**
   * Model Atributo
   */

  export type AggregateAtributo = {
    _count: AtributoCountAggregateOutputType | null
    _avg: AtributoAvgAggregateOutputType | null
    _sum: AtributoSumAggregateOutputType | null
    _min: AtributoMinAggregateOutputType | null
    _max: AtributoMaxAggregateOutputType | null
  }

  export type AtributoAvgAggregateOutputType = {
    id_atributo: number | null
  }

  export type AtributoSumAggregateOutputType = {
    id_atributo: number | null
  }

  export type AtributoMinAggregateOutputType = {
    id_atributo: number | null
    nombre: string | null
    tipo: string | null
  }

  export type AtributoMaxAggregateOutputType = {
    id_atributo: number | null
    nombre: string | null
    tipo: string | null
  }

  export type AtributoCountAggregateOutputType = {
    id_atributo: number
    nombre: number
    tipo: number
    _all: number
  }


  export type AtributoAvgAggregateInputType = {
    id_atributo?: true
  }

  export type AtributoSumAggregateInputType = {
    id_atributo?: true
  }

  export type AtributoMinAggregateInputType = {
    id_atributo?: true
    nombre?: true
    tipo?: true
  }

  export type AtributoMaxAggregateInputType = {
    id_atributo?: true
    nombre?: true
    tipo?: true
  }

  export type AtributoCountAggregateInputType = {
    id_atributo?: true
    nombre?: true
    tipo?: true
    _all?: true
  }

  export type AtributoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Atributo to aggregate.
     */
    where?: AtributoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Atributos to fetch.
     */
    orderBy?: AtributoOrderByWithRelationInput | AtributoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AtributoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Atributos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Atributos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Atributos
    **/
    _count?: true | AtributoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AtributoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AtributoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AtributoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AtributoMaxAggregateInputType
  }

  export type GetAtributoAggregateType<T extends AtributoAggregateArgs> = {
        [P in keyof T & keyof AggregateAtributo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtributo[P]>
      : GetScalarType<T[P], AggregateAtributo[P]>
  }




  export type AtributoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AtributoWhereInput
    orderBy?: AtributoOrderByWithAggregationInput | AtributoOrderByWithAggregationInput[]
    by: AtributoScalarFieldEnum[] | AtributoScalarFieldEnum
    having?: AtributoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AtributoCountAggregateInputType | true
    _avg?: AtributoAvgAggregateInputType
    _sum?: AtributoSumAggregateInputType
    _min?: AtributoMinAggregateInputType
    _max?: AtributoMaxAggregateInputType
  }

  export type AtributoGroupByOutputType = {
    id_atributo: number
    nombre: string
    tipo: string
    _count: AtributoCountAggregateOutputType | null
    _avg: AtributoAvgAggregateOutputType | null
    _sum: AtributoSumAggregateOutputType | null
    _min: AtributoMinAggregateOutputType | null
    _max: AtributoMaxAggregateOutputType | null
  }

  type GetAtributoGroupByPayload<T extends AtributoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AtributoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AtributoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AtributoGroupByOutputType[P]>
            : GetScalarType<T[P], AtributoGroupByOutputType[P]>
        }
      >
    >


  export type AtributoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_atributo?: boolean
    nombre?: boolean
    tipo?: boolean
    valores?: boolean | Atributo$valoresArgs<ExtArgs>
    _count?: boolean | AtributoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["atributo"]>



  export type AtributoSelectScalar = {
    id_atributo?: boolean
    nombre?: boolean
    tipo?: boolean
  }

  export type AtributoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_atributo" | "nombre" | "tipo", ExtArgs["result"]["atributo"]>
  export type AtributoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    valores?: boolean | Atributo$valoresArgs<ExtArgs>
    _count?: boolean | AtributoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AtributoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Atributo"
    objects: {
      valores: Prisma.$ValorAtributoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_atributo: number
      nombre: string
      tipo: string
    }, ExtArgs["result"]["atributo"]>
    composites: {}
  }

  type AtributoGetPayload<S extends boolean | null | undefined | AtributoDefaultArgs> = $Result.GetResult<Prisma.$AtributoPayload, S>

  type AtributoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AtributoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AtributoCountAggregateInputType | true
    }

  export interface AtributoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Atributo'], meta: { name: 'Atributo' } }
    /**
     * Find zero or one Atributo that matches the filter.
     * @param {AtributoFindUniqueArgs} args - Arguments to find a Atributo
     * @example
     * // Get one Atributo
     * const atributo = await prisma.atributo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AtributoFindUniqueArgs>(args: SelectSubset<T, AtributoFindUniqueArgs<ExtArgs>>): Prisma__AtributoClient<$Result.GetResult<Prisma.$AtributoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Atributo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AtributoFindUniqueOrThrowArgs} args - Arguments to find a Atributo
     * @example
     * // Get one Atributo
     * const atributo = await prisma.atributo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AtributoFindUniqueOrThrowArgs>(args: SelectSubset<T, AtributoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AtributoClient<$Result.GetResult<Prisma.$AtributoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Atributo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtributoFindFirstArgs} args - Arguments to find a Atributo
     * @example
     * // Get one Atributo
     * const atributo = await prisma.atributo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AtributoFindFirstArgs>(args?: SelectSubset<T, AtributoFindFirstArgs<ExtArgs>>): Prisma__AtributoClient<$Result.GetResult<Prisma.$AtributoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Atributo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtributoFindFirstOrThrowArgs} args - Arguments to find a Atributo
     * @example
     * // Get one Atributo
     * const atributo = await prisma.atributo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AtributoFindFirstOrThrowArgs>(args?: SelectSubset<T, AtributoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AtributoClient<$Result.GetResult<Prisma.$AtributoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Atributos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtributoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Atributos
     * const atributos = await prisma.atributo.findMany()
     * 
     * // Get first 10 Atributos
     * const atributos = await prisma.atributo.findMany({ take: 10 })
     * 
     * // Only select the `id_atributo`
     * const atributoWithId_atributoOnly = await prisma.atributo.findMany({ select: { id_atributo: true } })
     * 
     */
    findMany<T extends AtributoFindManyArgs>(args?: SelectSubset<T, AtributoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AtributoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Atributo.
     * @param {AtributoCreateArgs} args - Arguments to create a Atributo.
     * @example
     * // Create one Atributo
     * const Atributo = await prisma.atributo.create({
     *   data: {
     *     // ... data to create a Atributo
     *   }
     * })
     * 
     */
    create<T extends AtributoCreateArgs>(args: SelectSubset<T, AtributoCreateArgs<ExtArgs>>): Prisma__AtributoClient<$Result.GetResult<Prisma.$AtributoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Atributos.
     * @param {AtributoCreateManyArgs} args - Arguments to create many Atributos.
     * @example
     * // Create many Atributos
     * const atributo = await prisma.atributo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AtributoCreateManyArgs>(args?: SelectSubset<T, AtributoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Atributo.
     * @param {AtributoDeleteArgs} args - Arguments to delete one Atributo.
     * @example
     * // Delete one Atributo
     * const Atributo = await prisma.atributo.delete({
     *   where: {
     *     // ... filter to delete one Atributo
     *   }
     * })
     * 
     */
    delete<T extends AtributoDeleteArgs>(args: SelectSubset<T, AtributoDeleteArgs<ExtArgs>>): Prisma__AtributoClient<$Result.GetResult<Prisma.$AtributoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Atributo.
     * @param {AtributoUpdateArgs} args - Arguments to update one Atributo.
     * @example
     * // Update one Atributo
     * const atributo = await prisma.atributo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AtributoUpdateArgs>(args: SelectSubset<T, AtributoUpdateArgs<ExtArgs>>): Prisma__AtributoClient<$Result.GetResult<Prisma.$AtributoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Atributos.
     * @param {AtributoDeleteManyArgs} args - Arguments to filter Atributos to delete.
     * @example
     * // Delete a few Atributos
     * const { count } = await prisma.atributo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AtributoDeleteManyArgs>(args?: SelectSubset<T, AtributoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Atributos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtributoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Atributos
     * const atributo = await prisma.atributo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AtributoUpdateManyArgs>(args: SelectSubset<T, AtributoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Atributo.
     * @param {AtributoUpsertArgs} args - Arguments to update or create a Atributo.
     * @example
     * // Update or create a Atributo
     * const atributo = await prisma.atributo.upsert({
     *   create: {
     *     // ... data to create a Atributo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Atributo we want to update
     *   }
     * })
     */
    upsert<T extends AtributoUpsertArgs>(args: SelectSubset<T, AtributoUpsertArgs<ExtArgs>>): Prisma__AtributoClient<$Result.GetResult<Prisma.$AtributoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Atributos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtributoCountArgs} args - Arguments to filter Atributos to count.
     * @example
     * // Count the number of Atributos
     * const count = await prisma.atributo.count({
     *   where: {
     *     // ... the filter for the Atributos we want to count
     *   }
     * })
    **/
    count<T extends AtributoCountArgs>(
      args?: Subset<T, AtributoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AtributoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Atributo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtributoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AtributoAggregateArgs>(args: Subset<T, AtributoAggregateArgs>): Prisma.PrismaPromise<GetAtributoAggregateType<T>>

    /**
     * Group by Atributo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtributoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AtributoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AtributoGroupByArgs['orderBy'] }
        : { orderBy?: AtributoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AtributoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtributoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Atributo model
   */
  readonly fields: AtributoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Atributo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AtributoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    valores<T extends Atributo$valoresArgs<ExtArgs> = {}>(args?: Subset<T, Atributo$valoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValorAtributoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Atributo model
   */
  interface AtributoFieldRefs {
    readonly id_atributo: FieldRef<"Atributo", 'Int'>
    readonly nombre: FieldRef<"Atributo", 'String'>
    readonly tipo: FieldRef<"Atributo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Atributo findUnique
   */
  export type AtributoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atributo
     */
    select?: AtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atributo
     */
    omit?: AtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtributoInclude<ExtArgs> | null
    /**
     * Filter, which Atributo to fetch.
     */
    where: AtributoWhereUniqueInput
  }

  /**
   * Atributo findUniqueOrThrow
   */
  export type AtributoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atributo
     */
    select?: AtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atributo
     */
    omit?: AtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtributoInclude<ExtArgs> | null
    /**
     * Filter, which Atributo to fetch.
     */
    where: AtributoWhereUniqueInput
  }

  /**
   * Atributo findFirst
   */
  export type AtributoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atributo
     */
    select?: AtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atributo
     */
    omit?: AtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtributoInclude<ExtArgs> | null
    /**
     * Filter, which Atributo to fetch.
     */
    where?: AtributoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Atributos to fetch.
     */
    orderBy?: AtributoOrderByWithRelationInput | AtributoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Atributos.
     */
    cursor?: AtributoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Atributos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Atributos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Atributos.
     */
    distinct?: AtributoScalarFieldEnum | AtributoScalarFieldEnum[]
  }

  /**
   * Atributo findFirstOrThrow
   */
  export type AtributoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atributo
     */
    select?: AtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atributo
     */
    omit?: AtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtributoInclude<ExtArgs> | null
    /**
     * Filter, which Atributo to fetch.
     */
    where?: AtributoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Atributos to fetch.
     */
    orderBy?: AtributoOrderByWithRelationInput | AtributoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Atributos.
     */
    cursor?: AtributoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Atributos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Atributos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Atributos.
     */
    distinct?: AtributoScalarFieldEnum | AtributoScalarFieldEnum[]
  }

  /**
   * Atributo findMany
   */
  export type AtributoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atributo
     */
    select?: AtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atributo
     */
    omit?: AtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtributoInclude<ExtArgs> | null
    /**
     * Filter, which Atributos to fetch.
     */
    where?: AtributoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Atributos to fetch.
     */
    orderBy?: AtributoOrderByWithRelationInput | AtributoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Atributos.
     */
    cursor?: AtributoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Atributos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Atributos.
     */
    skip?: number
    distinct?: AtributoScalarFieldEnum | AtributoScalarFieldEnum[]
  }

  /**
   * Atributo create
   */
  export type AtributoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atributo
     */
    select?: AtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atributo
     */
    omit?: AtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtributoInclude<ExtArgs> | null
    /**
     * The data needed to create a Atributo.
     */
    data: XOR<AtributoCreateInput, AtributoUncheckedCreateInput>
  }

  /**
   * Atributo createMany
   */
  export type AtributoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Atributos.
     */
    data: AtributoCreateManyInput | AtributoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Atributo update
   */
  export type AtributoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atributo
     */
    select?: AtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atributo
     */
    omit?: AtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtributoInclude<ExtArgs> | null
    /**
     * The data needed to update a Atributo.
     */
    data: XOR<AtributoUpdateInput, AtributoUncheckedUpdateInput>
    /**
     * Choose, which Atributo to update.
     */
    where: AtributoWhereUniqueInput
  }

  /**
   * Atributo updateMany
   */
  export type AtributoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Atributos.
     */
    data: XOR<AtributoUpdateManyMutationInput, AtributoUncheckedUpdateManyInput>
    /**
     * Filter which Atributos to update
     */
    where?: AtributoWhereInput
    /**
     * Limit how many Atributos to update.
     */
    limit?: number
  }

  /**
   * Atributo upsert
   */
  export type AtributoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atributo
     */
    select?: AtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atributo
     */
    omit?: AtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtributoInclude<ExtArgs> | null
    /**
     * The filter to search for the Atributo to update in case it exists.
     */
    where: AtributoWhereUniqueInput
    /**
     * In case the Atributo found by the `where` argument doesn't exist, create a new Atributo with this data.
     */
    create: XOR<AtributoCreateInput, AtributoUncheckedCreateInput>
    /**
     * In case the Atributo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AtributoUpdateInput, AtributoUncheckedUpdateInput>
  }

  /**
   * Atributo delete
   */
  export type AtributoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atributo
     */
    select?: AtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atributo
     */
    omit?: AtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtributoInclude<ExtArgs> | null
    /**
     * Filter which Atributo to delete.
     */
    where: AtributoWhereUniqueInput
  }

  /**
   * Atributo deleteMany
   */
  export type AtributoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Atributos to delete
     */
    where?: AtributoWhereInput
    /**
     * Limit how many Atributos to delete.
     */
    limit?: number
  }

  /**
   * Atributo.valores
   */
  export type Atributo$valoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValorAtributo
     */
    select?: ValorAtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValorAtributo
     */
    omit?: ValorAtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValorAtributoInclude<ExtArgs> | null
    where?: ValorAtributoWhereInput
    orderBy?: ValorAtributoOrderByWithRelationInput | ValorAtributoOrderByWithRelationInput[]
    cursor?: ValorAtributoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ValorAtributoScalarFieldEnum | ValorAtributoScalarFieldEnum[]
  }

  /**
   * Atributo without action
   */
  export type AtributoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atributo
     */
    select?: AtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atributo
     */
    omit?: AtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtributoInclude<ExtArgs> | null
  }


  /**
   * Model ValorAtributo
   */

  export type AggregateValorAtributo = {
    _count: ValorAtributoCountAggregateOutputType | null
    _avg: ValorAtributoAvgAggregateOutputType | null
    _sum: ValorAtributoSumAggregateOutputType | null
    _min: ValorAtributoMinAggregateOutputType | null
    _max: ValorAtributoMaxAggregateOutputType | null
  }

  export type ValorAtributoAvgAggregateOutputType = {
    id_valor: number | null
    id_atributo: number | null
    precio_extra: number | null
  }

  export type ValorAtributoSumAggregateOutputType = {
    id_valor: number | null
    id_atributo: number | null
    precio_extra: number | null
  }

  export type ValorAtributoMinAggregateOutputType = {
    id_valor: number | null
    id_atributo: number | null
    valor: string | null
    precio_extra: number | null
  }

  export type ValorAtributoMaxAggregateOutputType = {
    id_valor: number | null
    id_atributo: number | null
    valor: string | null
    precio_extra: number | null
  }

  export type ValorAtributoCountAggregateOutputType = {
    id_valor: number
    id_atributo: number
    valor: number
    precio_extra: number
    _all: number
  }


  export type ValorAtributoAvgAggregateInputType = {
    id_valor?: true
    id_atributo?: true
    precio_extra?: true
  }

  export type ValorAtributoSumAggregateInputType = {
    id_valor?: true
    id_atributo?: true
    precio_extra?: true
  }

  export type ValorAtributoMinAggregateInputType = {
    id_valor?: true
    id_atributo?: true
    valor?: true
    precio_extra?: true
  }

  export type ValorAtributoMaxAggregateInputType = {
    id_valor?: true
    id_atributo?: true
    valor?: true
    precio_extra?: true
  }

  export type ValorAtributoCountAggregateInputType = {
    id_valor?: true
    id_atributo?: true
    valor?: true
    precio_extra?: true
    _all?: true
  }

  export type ValorAtributoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ValorAtributo to aggregate.
     */
    where?: ValorAtributoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValorAtributos to fetch.
     */
    orderBy?: ValorAtributoOrderByWithRelationInput | ValorAtributoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ValorAtributoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValorAtributos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValorAtributos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ValorAtributos
    **/
    _count?: true | ValorAtributoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ValorAtributoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ValorAtributoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ValorAtributoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ValorAtributoMaxAggregateInputType
  }

  export type GetValorAtributoAggregateType<T extends ValorAtributoAggregateArgs> = {
        [P in keyof T & keyof AggregateValorAtributo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateValorAtributo[P]>
      : GetScalarType<T[P], AggregateValorAtributo[P]>
  }




  export type ValorAtributoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValorAtributoWhereInput
    orderBy?: ValorAtributoOrderByWithAggregationInput | ValorAtributoOrderByWithAggregationInput[]
    by: ValorAtributoScalarFieldEnum[] | ValorAtributoScalarFieldEnum
    having?: ValorAtributoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ValorAtributoCountAggregateInputType | true
    _avg?: ValorAtributoAvgAggregateInputType
    _sum?: ValorAtributoSumAggregateInputType
    _min?: ValorAtributoMinAggregateInputType
    _max?: ValorAtributoMaxAggregateInputType
  }

  export type ValorAtributoGroupByOutputType = {
    id_valor: number
    id_atributo: number
    valor: string
    precio_extra: number
    _count: ValorAtributoCountAggregateOutputType | null
    _avg: ValorAtributoAvgAggregateOutputType | null
    _sum: ValorAtributoSumAggregateOutputType | null
    _min: ValorAtributoMinAggregateOutputType | null
    _max: ValorAtributoMaxAggregateOutputType | null
  }

  type GetValorAtributoGroupByPayload<T extends ValorAtributoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ValorAtributoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ValorAtributoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ValorAtributoGroupByOutputType[P]>
            : GetScalarType<T[P], ValorAtributoGroupByOutputType[P]>
        }
      >
    >


  export type ValorAtributoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_valor?: boolean
    id_atributo?: boolean
    valor?: boolean
    precio_extra?: boolean
    atributo?: boolean | AtributoDefaultArgs<ExtArgs>
    varianteDetalles?: boolean | ValorAtributo$varianteDetallesArgs<ExtArgs>
    _count?: boolean | ValorAtributoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["valorAtributo"]>



  export type ValorAtributoSelectScalar = {
    id_valor?: boolean
    id_atributo?: boolean
    valor?: boolean
    precio_extra?: boolean
  }

  export type ValorAtributoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_valor" | "id_atributo" | "valor" | "precio_extra", ExtArgs["result"]["valorAtributo"]>
  export type ValorAtributoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atributo?: boolean | AtributoDefaultArgs<ExtArgs>
    varianteDetalles?: boolean | ValorAtributo$varianteDetallesArgs<ExtArgs>
    _count?: boolean | ValorAtributoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ValorAtributoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ValorAtributo"
    objects: {
      atributo: Prisma.$AtributoPayload<ExtArgs>
      varianteDetalles: Prisma.$VarianteDetallePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_valor: number
      id_atributo: number
      valor: string
      precio_extra: number
    }, ExtArgs["result"]["valorAtributo"]>
    composites: {}
  }

  type ValorAtributoGetPayload<S extends boolean | null | undefined | ValorAtributoDefaultArgs> = $Result.GetResult<Prisma.$ValorAtributoPayload, S>

  type ValorAtributoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ValorAtributoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ValorAtributoCountAggregateInputType | true
    }

  export interface ValorAtributoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ValorAtributo'], meta: { name: 'ValorAtributo' } }
    /**
     * Find zero or one ValorAtributo that matches the filter.
     * @param {ValorAtributoFindUniqueArgs} args - Arguments to find a ValorAtributo
     * @example
     * // Get one ValorAtributo
     * const valorAtributo = await prisma.valorAtributo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ValorAtributoFindUniqueArgs>(args: SelectSubset<T, ValorAtributoFindUniqueArgs<ExtArgs>>): Prisma__ValorAtributoClient<$Result.GetResult<Prisma.$ValorAtributoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ValorAtributo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ValorAtributoFindUniqueOrThrowArgs} args - Arguments to find a ValorAtributo
     * @example
     * // Get one ValorAtributo
     * const valorAtributo = await prisma.valorAtributo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ValorAtributoFindUniqueOrThrowArgs>(args: SelectSubset<T, ValorAtributoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ValorAtributoClient<$Result.GetResult<Prisma.$ValorAtributoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ValorAtributo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValorAtributoFindFirstArgs} args - Arguments to find a ValorAtributo
     * @example
     * // Get one ValorAtributo
     * const valorAtributo = await prisma.valorAtributo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ValorAtributoFindFirstArgs>(args?: SelectSubset<T, ValorAtributoFindFirstArgs<ExtArgs>>): Prisma__ValorAtributoClient<$Result.GetResult<Prisma.$ValorAtributoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ValorAtributo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValorAtributoFindFirstOrThrowArgs} args - Arguments to find a ValorAtributo
     * @example
     * // Get one ValorAtributo
     * const valorAtributo = await prisma.valorAtributo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ValorAtributoFindFirstOrThrowArgs>(args?: SelectSubset<T, ValorAtributoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ValorAtributoClient<$Result.GetResult<Prisma.$ValorAtributoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ValorAtributos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValorAtributoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ValorAtributos
     * const valorAtributos = await prisma.valorAtributo.findMany()
     * 
     * // Get first 10 ValorAtributos
     * const valorAtributos = await prisma.valorAtributo.findMany({ take: 10 })
     * 
     * // Only select the `id_valor`
     * const valorAtributoWithId_valorOnly = await prisma.valorAtributo.findMany({ select: { id_valor: true } })
     * 
     */
    findMany<T extends ValorAtributoFindManyArgs>(args?: SelectSubset<T, ValorAtributoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValorAtributoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ValorAtributo.
     * @param {ValorAtributoCreateArgs} args - Arguments to create a ValorAtributo.
     * @example
     * // Create one ValorAtributo
     * const ValorAtributo = await prisma.valorAtributo.create({
     *   data: {
     *     // ... data to create a ValorAtributo
     *   }
     * })
     * 
     */
    create<T extends ValorAtributoCreateArgs>(args: SelectSubset<T, ValorAtributoCreateArgs<ExtArgs>>): Prisma__ValorAtributoClient<$Result.GetResult<Prisma.$ValorAtributoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ValorAtributos.
     * @param {ValorAtributoCreateManyArgs} args - Arguments to create many ValorAtributos.
     * @example
     * // Create many ValorAtributos
     * const valorAtributo = await prisma.valorAtributo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ValorAtributoCreateManyArgs>(args?: SelectSubset<T, ValorAtributoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ValorAtributo.
     * @param {ValorAtributoDeleteArgs} args - Arguments to delete one ValorAtributo.
     * @example
     * // Delete one ValorAtributo
     * const ValorAtributo = await prisma.valorAtributo.delete({
     *   where: {
     *     // ... filter to delete one ValorAtributo
     *   }
     * })
     * 
     */
    delete<T extends ValorAtributoDeleteArgs>(args: SelectSubset<T, ValorAtributoDeleteArgs<ExtArgs>>): Prisma__ValorAtributoClient<$Result.GetResult<Prisma.$ValorAtributoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ValorAtributo.
     * @param {ValorAtributoUpdateArgs} args - Arguments to update one ValorAtributo.
     * @example
     * // Update one ValorAtributo
     * const valorAtributo = await prisma.valorAtributo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ValorAtributoUpdateArgs>(args: SelectSubset<T, ValorAtributoUpdateArgs<ExtArgs>>): Prisma__ValorAtributoClient<$Result.GetResult<Prisma.$ValorAtributoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ValorAtributos.
     * @param {ValorAtributoDeleteManyArgs} args - Arguments to filter ValorAtributos to delete.
     * @example
     * // Delete a few ValorAtributos
     * const { count } = await prisma.valorAtributo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ValorAtributoDeleteManyArgs>(args?: SelectSubset<T, ValorAtributoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ValorAtributos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValorAtributoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ValorAtributos
     * const valorAtributo = await prisma.valorAtributo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ValorAtributoUpdateManyArgs>(args: SelectSubset<T, ValorAtributoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ValorAtributo.
     * @param {ValorAtributoUpsertArgs} args - Arguments to update or create a ValorAtributo.
     * @example
     * // Update or create a ValorAtributo
     * const valorAtributo = await prisma.valorAtributo.upsert({
     *   create: {
     *     // ... data to create a ValorAtributo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ValorAtributo we want to update
     *   }
     * })
     */
    upsert<T extends ValorAtributoUpsertArgs>(args: SelectSubset<T, ValorAtributoUpsertArgs<ExtArgs>>): Prisma__ValorAtributoClient<$Result.GetResult<Prisma.$ValorAtributoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ValorAtributos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValorAtributoCountArgs} args - Arguments to filter ValorAtributos to count.
     * @example
     * // Count the number of ValorAtributos
     * const count = await prisma.valorAtributo.count({
     *   where: {
     *     // ... the filter for the ValorAtributos we want to count
     *   }
     * })
    **/
    count<T extends ValorAtributoCountArgs>(
      args?: Subset<T, ValorAtributoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ValorAtributoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ValorAtributo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValorAtributoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ValorAtributoAggregateArgs>(args: Subset<T, ValorAtributoAggregateArgs>): Prisma.PrismaPromise<GetValorAtributoAggregateType<T>>

    /**
     * Group by ValorAtributo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValorAtributoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ValorAtributoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ValorAtributoGroupByArgs['orderBy'] }
        : { orderBy?: ValorAtributoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ValorAtributoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetValorAtributoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ValorAtributo model
   */
  readonly fields: ValorAtributoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ValorAtributo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ValorAtributoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    atributo<T extends AtributoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AtributoDefaultArgs<ExtArgs>>): Prisma__AtributoClient<$Result.GetResult<Prisma.$AtributoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    varianteDetalles<T extends ValorAtributo$varianteDetallesArgs<ExtArgs> = {}>(args?: Subset<T, ValorAtributo$varianteDetallesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VarianteDetallePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ValorAtributo model
   */
  interface ValorAtributoFieldRefs {
    readonly id_valor: FieldRef<"ValorAtributo", 'Int'>
    readonly id_atributo: FieldRef<"ValorAtributo", 'Int'>
    readonly valor: FieldRef<"ValorAtributo", 'String'>
    readonly precio_extra: FieldRef<"ValorAtributo", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ValorAtributo findUnique
   */
  export type ValorAtributoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValorAtributo
     */
    select?: ValorAtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValorAtributo
     */
    omit?: ValorAtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValorAtributoInclude<ExtArgs> | null
    /**
     * Filter, which ValorAtributo to fetch.
     */
    where: ValorAtributoWhereUniqueInput
  }

  /**
   * ValorAtributo findUniqueOrThrow
   */
  export type ValorAtributoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValorAtributo
     */
    select?: ValorAtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValorAtributo
     */
    omit?: ValorAtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValorAtributoInclude<ExtArgs> | null
    /**
     * Filter, which ValorAtributo to fetch.
     */
    where: ValorAtributoWhereUniqueInput
  }

  /**
   * ValorAtributo findFirst
   */
  export type ValorAtributoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValorAtributo
     */
    select?: ValorAtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValorAtributo
     */
    omit?: ValorAtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValorAtributoInclude<ExtArgs> | null
    /**
     * Filter, which ValorAtributo to fetch.
     */
    where?: ValorAtributoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValorAtributos to fetch.
     */
    orderBy?: ValorAtributoOrderByWithRelationInput | ValorAtributoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ValorAtributos.
     */
    cursor?: ValorAtributoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValorAtributos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValorAtributos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ValorAtributos.
     */
    distinct?: ValorAtributoScalarFieldEnum | ValorAtributoScalarFieldEnum[]
  }

  /**
   * ValorAtributo findFirstOrThrow
   */
  export type ValorAtributoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValorAtributo
     */
    select?: ValorAtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValorAtributo
     */
    omit?: ValorAtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValorAtributoInclude<ExtArgs> | null
    /**
     * Filter, which ValorAtributo to fetch.
     */
    where?: ValorAtributoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValorAtributos to fetch.
     */
    orderBy?: ValorAtributoOrderByWithRelationInput | ValorAtributoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ValorAtributos.
     */
    cursor?: ValorAtributoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValorAtributos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValorAtributos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ValorAtributos.
     */
    distinct?: ValorAtributoScalarFieldEnum | ValorAtributoScalarFieldEnum[]
  }

  /**
   * ValorAtributo findMany
   */
  export type ValorAtributoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValorAtributo
     */
    select?: ValorAtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValorAtributo
     */
    omit?: ValorAtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValorAtributoInclude<ExtArgs> | null
    /**
     * Filter, which ValorAtributos to fetch.
     */
    where?: ValorAtributoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValorAtributos to fetch.
     */
    orderBy?: ValorAtributoOrderByWithRelationInput | ValorAtributoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ValorAtributos.
     */
    cursor?: ValorAtributoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValorAtributos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValorAtributos.
     */
    skip?: number
    distinct?: ValorAtributoScalarFieldEnum | ValorAtributoScalarFieldEnum[]
  }

  /**
   * ValorAtributo create
   */
  export type ValorAtributoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValorAtributo
     */
    select?: ValorAtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValorAtributo
     */
    omit?: ValorAtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValorAtributoInclude<ExtArgs> | null
    /**
     * The data needed to create a ValorAtributo.
     */
    data: XOR<ValorAtributoCreateInput, ValorAtributoUncheckedCreateInput>
  }

  /**
   * ValorAtributo createMany
   */
  export type ValorAtributoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ValorAtributos.
     */
    data: ValorAtributoCreateManyInput | ValorAtributoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ValorAtributo update
   */
  export type ValorAtributoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValorAtributo
     */
    select?: ValorAtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValorAtributo
     */
    omit?: ValorAtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValorAtributoInclude<ExtArgs> | null
    /**
     * The data needed to update a ValorAtributo.
     */
    data: XOR<ValorAtributoUpdateInput, ValorAtributoUncheckedUpdateInput>
    /**
     * Choose, which ValorAtributo to update.
     */
    where: ValorAtributoWhereUniqueInput
  }

  /**
   * ValorAtributo updateMany
   */
  export type ValorAtributoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ValorAtributos.
     */
    data: XOR<ValorAtributoUpdateManyMutationInput, ValorAtributoUncheckedUpdateManyInput>
    /**
     * Filter which ValorAtributos to update
     */
    where?: ValorAtributoWhereInput
    /**
     * Limit how many ValorAtributos to update.
     */
    limit?: number
  }

  /**
   * ValorAtributo upsert
   */
  export type ValorAtributoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValorAtributo
     */
    select?: ValorAtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValorAtributo
     */
    omit?: ValorAtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValorAtributoInclude<ExtArgs> | null
    /**
     * The filter to search for the ValorAtributo to update in case it exists.
     */
    where: ValorAtributoWhereUniqueInput
    /**
     * In case the ValorAtributo found by the `where` argument doesn't exist, create a new ValorAtributo with this data.
     */
    create: XOR<ValorAtributoCreateInput, ValorAtributoUncheckedCreateInput>
    /**
     * In case the ValorAtributo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ValorAtributoUpdateInput, ValorAtributoUncheckedUpdateInput>
  }

  /**
   * ValorAtributo delete
   */
  export type ValorAtributoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValorAtributo
     */
    select?: ValorAtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValorAtributo
     */
    omit?: ValorAtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValorAtributoInclude<ExtArgs> | null
    /**
     * Filter which ValorAtributo to delete.
     */
    where: ValorAtributoWhereUniqueInput
  }

  /**
   * ValorAtributo deleteMany
   */
  export type ValorAtributoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ValorAtributos to delete
     */
    where?: ValorAtributoWhereInput
    /**
     * Limit how many ValorAtributos to delete.
     */
    limit?: number
  }

  /**
   * ValorAtributo.varianteDetalles
   */
  export type ValorAtributo$varianteDetallesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianteDetalle
     */
    select?: VarianteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianteDetalle
     */
    omit?: VarianteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianteDetalleInclude<ExtArgs> | null
    where?: VarianteDetalleWhereInput
    orderBy?: VarianteDetalleOrderByWithRelationInput | VarianteDetalleOrderByWithRelationInput[]
    cursor?: VarianteDetalleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VarianteDetalleScalarFieldEnum | VarianteDetalleScalarFieldEnum[]
  }

  /**
   * ValorAtributo without action
   */
  export type ValorAtributoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValorAtributo
     */
    select?: ValorAtributoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValorAtributo
     */
    omit?: ValorAtributoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValorAtributoInclude<ExtArgs> | null
  }


  /**
   * Model VarianteDetalle
   */

  export type AggregateVarianteDetalle = {
    _count: VarianteDetalleCountAggregateOutputType | null
    _avg: VarianteDetalleAvgAggregateOutputType | null
    _sum: VarianteDetalleSumAggregateOutputType | null
    _min: VarianteDetalleMinAggregateOutputType | null
    _max: VarianteDetalleMaxAggregateOutputType | null
  }

  export type VarianteDetalleAvgAggregateOutputType = {
    id_productoPersonalizable: number | null
    id_valor: number | null
  }

  export type VarianteDetalleSumAggregateOutputType = {
    id_productoPersonalizable: number | null
    id_valor: number | null
  }

  export type VarianteDetalleMinAggregateOutputType = {
    id_productoPersonalizable: number | null
    id_valor: number | null
  }

  export type VarianteDetalleMaxAggregateOutputType = {
    id_productoPersonalizable: number | null
    id_valor: number | null
  }

  export type VarianteDetalleCountAggregateOutputType = {
    id_productoPersonalizable: number
    id_valor: number
    _all: number
  }


  export type VarianteDetalleAvgAggregateInputType = {
    id_productoPersonalizable?: true
    id_valor?: true
  }

  export type VarianteDetalleSumAggregateInputType = {
    id_productoPersonalizable?: true
    id_valor?: true
  }

  export type VarianteDetalleMinAggregateInputType = {
    id_productoPersonalizable?: true
    id_valor?: true
  }

  export type VarianteDetalleMaxAggregateInputType = {
    id_productoPersonalizable?: true
    id_valor?: true
  }

  export type VarianteDetalleCountAggregateInputType = {
    id_productoPersonalizable?: true
    id_valor?: true
    _all?: true
  }

  export type VarianteDetalleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VarianteDetalle to aggregate.
     */
    where?: VarianteDetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VarianteDetalles to fetch.
     */
    orderBy?: VarianteDetalleOrderByWithRelationInput | VarianteDetalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VarianteDetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VarianteDetalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VarianteDetalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VarianteDetalles
    **/
    _count?: true | VarianteDetalleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VarianteDetalleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VarianteDetalleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VarianteDetalleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VarianteDetalleMaxAggregateInputType
  }

  export type GetVarianteDetalleAggregateType<T extends VarianteDetalleAggregateArgs> = {
        [P in keyof T & keyof AggregateVarianteDetalle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVarianteDetalle[P]>
      : GetScalarType<T[P], AggregateVarianteDetalle[P]>
  }




  export type VarianteDetalleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VarianteDetalleWhereInput
    orderBy?: VarianteDetalleOrderByWithAggregationInput | VarianteDetalleOrderByWithAggregationInput[]
    by: VarianteDetalleScalarFieldEnum[] | VarianteDetalleScalarFieldEnum
    having?: VarianteDetalleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VarianteDetalleCountAggregateInputType | true
    _avg?: VarianteDetalleAvgAggregateInputType
    _sum?: VarianteDetalleSumAggregateInputType
    _min?: VarianteDetalleMinAggregateInputType
    _max?: VarianteDetalleMaxAggregateInputType
  }

  export type VarianteDetalleGroupByOutputType = {
    id_productoPersonalizable: number
    id_valor: number
    _count: VarianteDetalleCountAggregateOutputType | null
    _avg: VarianteDetalleAvgAggregateOutputType | null
    _sum: VarianteDetalleSumAggregateOutputType | null
    _min: VarianteDetalleMinAggregateOutputType | null
    _max: VarianteDetalleMaxAggregateOutputType | null
  }

  type GetVarianteDetalleGroupByPayload<T extends VarianteDetalleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VarianteDetalleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VarianteDetalleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VarianteDetalleGroupByOutputType[P]>
            : GetScalarType<T[P], VarianteDetalleGroupByOutputType[P]>
        }
      >
    >


  export type VarianteDetalleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_productoPersonalizable?: boolean
    id_valor?: boolean
    valor?: boolean | ValorAtributoDefaultArgs<ExtArgs>
    productoPersonalizable?: boolean | ProductoPersonalizableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["varianteDetalle"]>



  export type VarianteDetalleSelectScalar = {
    id_productoPersonalizable?: boolean
    id_valor?: boolean
  }

  export type VarianteDetalleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_productoPersonalizable" | "id_valor", ExtArgs["result"]["varianteDetalle"]>
  export type VarianteDetalleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    valor?: boolean | ValorAtributoDefaultArgs<ExtArgs>
    productoPersonalizable?: boolean | ProductoPersonalizableDefaultArgs<ExtArgs>
  }

  export type $VarianteDetallePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VarianteDetalle"
    objects: {
      valor: Prisma.$ValorAtributoPayload<ExtArgs>
      productoPersonalizable: Prisma.$ProductoPersonalizablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_productoPersonalizable: number
      id_valor: number
    }, ExtArgs["result"]["varianteDetalle"]>
    composites: {}
  }

  type VarianteDetalleGetPayload<S extends boolean | null | undefined | VarianteDetalleDefaultArgs> = $Result.GetResult<Prisma.$VarianteDetallePayload, S>

  type VarianteDetalleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VarianteDetalleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VarianteDetalleCountAggregateInputType | true
    }

  export interface VarianteDetalleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VarianteDetalle'], meta: { name: 'VarianteDetalle' } }
    /**
     * Find zero or one VarianteDetalle that matches the filter.
     * @param {VarianteDetalleFindUniqueArgs} args - Arguments to find a VarianteDetalle
     * @example
     * // Get one VarianteDetalle
     * const varianteDetalle = await prisma.varianteDetalle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VarianteDetalleFindUniqueArgs>(args: SelectSubset<T, VarianteDetalleFindUniqueArgs<ExtArgs>>): Prisma__VarianteDetalleClient<$Result.GetResult<Prisma.$VarianteDetallePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VarianteDetalle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VarianteDetalleFindUniqueOrThrowArgs} args - Arguments to find a VarianteDetalle
     * @example
     * // Get one VarianteDetalle
     * const varianteDetalle = await prisma.varianteDetalle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VarianteDetalleFindUniqueOrThrowArgs>(args: SelectSubset<T, VarianteDetalleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VarianteDetalleClient<$Result.GetResult<Prisma.$VarianteDetallePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VarianteDetalle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianteDetalleFindFirstArgs} args - Arguments to find a VarianteDetalle
     * @example
     * // Get one VarianteDetalle
     * const varianteDetalle = await prisma.varianteDetalle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VarianteDetalleFindFirstArgs>(args?: SelectSubset<T, VarianteDetalleFindFirstArgs<ExtArgs>>): Prisma__VarianteDetalleClient<$Result.GetResult<Prisma.$VarianteDetallePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VarianteDetalle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianteDetalleFindFirstOrThrowArgs} args - Arguments to find a VarianteDetalle
     * @example
     * // Get one VarianteDetalle
     * const varianteDetalle = await prisma.varianteDetalle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VarianteDetalleFindFirstOrThrowArgs>(args?: SelectSubset<T, VarianteDetalleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VarianteDetalleClient<$Result.GetResult<Prisma.$VarianteDetallePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VarianteDetalles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianteDetalleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VarianteDetalles
     * const varianteDetalles = await prisma.varianteDetalle.findMany()
     * 
     * // Get first 10 VarianteDetalles
     * const varianteDetalles = await prisma.varianteDetalle.findMany({ take: 10 })
     * 
     * // Only select the `id_productoPersonalizable`
     * const varianteDetalleWithId_productoPersonalizableOnly = await prisma.varianteDetalle.findMany({ select: { id_productoPersonalizable: true } })
     * 
     */
    findMany<T extends VarianteDetalleFindManyArgs>(args?: SelectSubset<T, VarianteDetalleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VarianteDetallePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VarianteDetalle.
     * @param {VarianteDetalleCreateArgs} args - Arguments to create a VarianteDetalle.
     * @example
     * // Create one VarianteDetalle
     * const VarianteDetalle = await prisma.varianteDetalle.create({
     *   data: {
     *     // ... data to create a VarianteDetalle
     *   }
     * })
     * 
     */
    create<T extends VarianteDetalleCreateArgs>(args: SelectSubset<T, VarianteDetalleCreateArgs<ExtArgs>>): Prisma__VarianteDetalleClient<$Result.GetResult<Prisma.$VarianteDetallePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VarianteDetalles.
     * @param {VarianteDetalleCreateManyArgs} args - Arguments to create many VarianteDetalles.
     * @example
     * // Create many VarianteDetalles
     * const varianteDetalle = await prisma.varianteDetalle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VarianteDetalleCreateManyArgs>(args?: SelectSubset<T, VarianteDetalleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VarianteDetalle.
     * @param {VarianteDetalleDeleteArgs} args - Arguments to delete one VarianteDetalle.
     * @example
     * // Delete one VarianteDetalle
     * const VarianteDetalle = await prisma.varianteDetalle.delete({
     *   where: {
     *     // ... filter to delete one VarianteDetalle
     *   }
     * })
     * 
     */
    delete<T extends VarianteDetalleDeleteArgs>(args: SelectSubset<T, VarianteDetalleDeleteArgs<ExtArgs>>): Prisma__VarianteDetalleClient<$Result.GetResult<Prisma.$VarianteDetallePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VarianteDetalle.
     * @param {VarianteDetalleUpdateArgs} args - Arguments to update one VarianteDetalle.
     * @example
     * // Update one VarianteDetalle
     * const varianteDetalle = await prisma.varianteDetalle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VarianteDetalleUpdateArgs>(args: SelectSubset<T, VarianteDetalleUpdateArgs<ExtArgs>>): Prisma__VarianteDetalleClient<$Result.GetResult<Prisma.$VarianteDetallePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VarianteDetalles.
     * @param {VarianteDetalleDeleteManyArgs} args - Arguments to filter VarianteDetalles to delete.
     * @example
     * // Delete a few VarianteDetalles
     * const { count } = await prisma.varianteDetalle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VarianteDetalleDeleteManyArgs>(args?: SelectSubset<T, VarianteDetalleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VarianteDetalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianteDetalleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VarianteDetalles
     * const varianteDetalle = await prisma.varianteDetalle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VarianteDetalleUpdateManyArgs>(args: SelectSubset<T, VarianteDetalleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VarianteDetalle.
     * @param {VarianteDetalleUpsertArgs} args - Arguments to update or create a VarianteDetalle.
     * @example
     * // Update or create a VarianteDetalle
     * const varianteDetalle = await prisma.varianteDetalle.upsert({
     *   create: {
     *     // ... data to create a VarianteDetalle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VarianteDetalle we want to update
     *   }
     * })
     */
    upsert<T extends VarianteDetalleUpsertArgs>(args: SelectSubset<T, VarianteDetalleUpsertArgs<ExtArgs>>): Prisma__VarianteDetalleClient<$Result.GetResult<Prisma.$VarianteDetallePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VarianteDetalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianteDetalleCountArgs} args - Arguments to filter VarianteDetalles to count.
     * @example
     * // Count the number of VarianteDetalles
     * const count = await prisma.varianteDetalle.count({
     *   where: {
     *     // ... the filter for the VarianteDetalles we want to count
     *   }
     * })
    **/
    count<T extends VarianteDetalleCountArgs>(
      args?: Subset<T, VarianteDetalleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VarianteDetalleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VarianteDetalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianteDetalleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VarianteDetalleAggregateArgs>(args: Subset<T, VarianteDetalleAggregateArgs>): Prisma.PrismaPromise<GetVarianteDetalleAggregateType<T>>

    /**
     * Group by VarianteDetalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VarianteDetalleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VarianteDetalleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VarianteDetalleGroupByArgs['orderBy'] }
        : { orderBy?: VarianteDetalleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VarianteDetalleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVarianteDetalleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VarianteDetalle model
   */
  readonly fields: VarianteDetalleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VarianteDetalle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VarianteDetalleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    valor<T extends ValorAtributoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ValorAtributoDefaultArgs<ExtArgs>>): Prisma__ValorAtributoClient<$Result.GetResult<Prisma.$ValorAtributoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productoPersonalizable<T extends ProductoPersonalizableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoPersonalizableDefaultArgs<ExtArgs>>): Prisma__ProductoPersonalizableClient<$Result.GetResult<Prisma.$ProductoPersonalizablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VarianteDetalle model
   */
  interface VarianteDetalleFieldRefs {
    readonly id_productoPersonalizable: FieldRef<"VarianteDetalle", 'Int'>
    readonly id_valor: FieldRef<"VarianteDetalle", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * VarianteDetalle findUnique
   */
  export type VarianteDetalleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianteDetalle
     */
    select?: VarianteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianteDetalle
     */
    omit?: VarianteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianteDetalleInclude<ExtArgs> | null
    /**
     * Filter, which VarianteDetalle to fetch.
     */
    where: VarianteDetalleWhereUniqueInput
  }

  /**
   * VarianteDetalle findUniqueOrThrow
   */
  export type VarianteDetalleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianteDetalle
     */
    select?: VarianteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianteDetalle
     */
    omit?: VarianteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianteDetalleInclude<ExtArgs> | null
    /**
     * Filter, which VarianteDetalle to fetch.
     */
    where: VarianteDetalleWhereUniqueInput
  }

  /**
   * VarianteDetalle findFirst
   */
  export type VarianteDetalleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianteDetalle
     */
    select?: VarianteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianteDetalle
     */
    omit?: VarianteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianteDetalleInclude<ExtArgs> | null
    /**
     * Filter, which VarianteDetalle to fetch.
     */
    where?: VarianteDetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VarianteDetalles to fetch.
     */
    orderBy?: VarianteDetalleOrderByWithRelationInput | VarianteDetalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VarianteDetalles.
     */
    cursor?: VarianteDetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VarianteDetalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VarianteDetalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VarianteDetalles.
     */
    distinct?: VarianteDetalleScalarFieldEnum | VarianteDetalleScalarFieldEnum[]
  }

  /**
   * VarianteDetalle findFirstOrThrow
   */
  export type VarianteDetalleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianteDetalle
     */
    select?: VarianteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianteDetalle
     */
    omit?: VarianteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianteDetalleInclude<ExtArgs> | null
    /**
     * Filter, which VarianteDetalle to fetch.
     */
    where?: VarianteDetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VarianteDetalles to fetch.
     */
    orderBy?: VarianteDetalleOrderByWithRelationInput | VarianteDetalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VarianteDetalles.
     */
    cursor?: VarianteDetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VarianteDetalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VarianteDetalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VarianteDetalles.
     */
    distinct?: VarianteDetalleScalarFieldEnum | VarianteDetalleScalarFieldEnum[]
  }

  /**
   * VarianteDetalle findMany
   */
  export type VarianteDetalleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianteDetalle
     */
    select?: VarianteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianteDetalle
     */
    omit?: VarianteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianteDetalleInclude<ExtArgs> | null
    /**
     * Filter, which VarianteDetalles to fetch.
     */
    where?: VarianteDetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VarianteDetalles to fetch.
     */
    orderBy?: VarianteDetalleOrderByWithRelationInput | VarianteDetalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VarianteDetalles.
     */
    cursor?: VarianteDetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VarianteDetalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VarianteDetalles.
     */
    skip?: number
    distinct?: VarianteDetalleScalarFieldEnum | VarianteDetalleScalarFieldEnum[]
  }

  /**
   * VarianteDetalle create
   */
  export type VarianteDetalleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianteDetalle
     */
    select?: VarianteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianteDetalle
     */
    omit?: VarianteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianteDetalleInclude<ExtArgs> | null
    /**
     * The data needed to create a VarianteDetalle.
     */
    data: XOR<VarianteDetalleCreateInput, VarianteDetalleUncheckedCreateInput>
  }

  /**
   * VarianteDetalle createMany
   */
  export type VarianteDetalleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VarianteDetalles.
     */
    data: VarianteDetalleCreateManyInput | VarianteDetalleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VarianteDetalle update
   */
  export type VarianteDetalleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianteDetalle
     */
    select?: VarianteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianteDetalle
     */
    omit?: VarianteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianteDetalleInclude<ExtArgs> | null
    /**
     * The data needed to update a VarianteDetalle.
     */
    data: XOR<VarianteDetalleUpdateInput, VarianteDetalleUncheckedUpdateInput>
    /**
     * Choose, which VarianteDetalle to update.
     */
    where: VarianteDetalleWhereUniqueInput
  }

  /**
   * VarianteDetalle updateMany
   */
  export type VarianteDetalleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VarianteDetalles.
     */
    data: XOR<VarianteDetalleUpdateManyMutationInput, VarianteDetalleUncheckedUpdateManyInput>
    /**
     * Filter which VarianteDetalles to update
     */
    where?: VarianteDetalleWhereInput
    /**
     * Limit how many VarianteDetalles to update.
     */
    limit?: number
  }

  /**
   * VarianteDetalle upsert
   */
  export type VarianteDetalleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianteDetalle
     */
    select?: VarianteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianteDetalle
     */
    omit?: VarianteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianteDetalleInclude<ExtArgs> | null
    /**
     * The filter to search for the VarianteDetalle to update in case it exists.
     */
    where: VarianteDetalleWhereUniqueInput
    /**
     * In case the VarianteDetalle found by the `where` argument doesn't exist, create a new VarianteDetalle with this data.
     */
    create: XOR<VarianteDetalleCreateInput, VarianteDetalleUncheckedCreateInput>
    /**
     * In case the VarianteDetalle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VarianteDetalleUpdateInput, VarianteDetalleUncheckedUpdateInput>
  }

  /**
   * VarianteDetalle delete
   */
  export type VarianteDetalleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianteDetalle
     */
    select?: VarianteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianteDetalle
     */
    omit?: VarianteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianteDetalleInclude<ExtArgs> | null
    /**
     * Filter which VarianteDetalle to delete.
     */
    where: VarianteDetalleWhereUniqueInput
  }

  /**
   * VarianteDetalle deleteMany
   */
  export type VarianteDetalleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VarianteDetalles to delete
     */
    where?: VarianteDetalleWhereInput
    /**
     * Limit how many VarianteDetalles to delete.
     */
    limit?: number
  }

  /**
   * VarianteDetalle without action
   */
  export type VarianteDetalleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VarianteDetalle
     */
    select?: VarianteDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VarianteDetalle
     */
    omit?: VarianteDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VarianteDetalleInclude<ExtArgs> | null
  }


  /**
   * Model Promocion
   */

  export type AggregatePromocion = {
    _count: PromocionCountAggregateOutputType | null
    _avg: PromocionAvgAggregateOutputType | null
    _sum: PromocionSumAggregateOutputType | null
    _min: PromocionMinAggregateOutputType | null
    _max: PromocionMaxAggregateOutputType | null
  }

  export type PromocionAvgAggregateOutputType = {
    id: number | null
    referencia_id_producto: number | null
    referencia_id_categoria: number | null
    valor: number | null
  }

  export type PromocionSumAggregateOutputType = {
    id: number | null
    referencia_id_producto: number | null
    referencia_id_categoria: number | null
    valor: number | null
  }

  export type PromocionMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    tipo: $Enums.TipoPromocion | null
    referencia_id_producto: number | null
    referencia_id_categoria: number | null
    valor: number | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
  }

  export type PromocionMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    tipo: $Enums.TipoPromocion | null
    referencia_id_producto: number | null
    referencia_id_categoria: number | null
    valor: number | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
  }

  export type PromocionCountAggregateOutputType = {
    id: number
    nombre: number
    tipo: number
    referencia_id_producto: number
    referencia_id_categoria: number
    valor: number
    fecha_inicio: number
    fecha_fin: number
    _all: number
  }


  export type PromocionAvgAggregateInputType = {
    id?: true
    referencia_id_producto?: true
    referencia_id_categoria?: true
    valor?: true
  }

  export type PromocionSumAggregateInputType = {
    id?: true
    referencia_id_producto?: true
    referencia_id_categoria?: true
    valor?: true
  }

  export type PromocionMinAggregateInputType = {
    id?: true
    nombre?: true
    tipo?: true
    referencia_id_producto?: true
    referencia_id_categoria?: true
    valor?: true
    fecha_inicio?: true
    fecha_fin?: true
  }

  export type PromocionMaxAggregateInputType = {
    id?: true
    nombre?: true
    tipo?: true
    referencia_id_producto?: true
    referencia_id_categoria?: true
    valor?: true
    fecha_inicio?: true
    fecha_fin?: true
  }

  export type PromocionCountAggregateInputType = {
    id?: true
    nombre?: true
    tipo?: true
    referencia_id_producto?: true
    referencia_id_categoria?: true
    valor?: true
    fecha_inicio?: true
    fecha_fin?: true
    _all?: true
  }

  export type PromocionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promocion to aggregate.
     */
    where?: PromocionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promocions to fetch.
     */
    orderBy?: PromocionOrderByWithRelationInput | PromocionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromocionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promocions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promocions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promocions
    **/
    _count?: true | PromocionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromocionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromocionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromocionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromocionMaxAggregateInputType
  }

  export type GetPromocionAggregateType<T extends PromocionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromocion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromocion[P]>
      : GetScalarType<T[P], AggregatePromocion[P]>
  }




  export type PromocionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromocionWhereInput
    orderBy?: PromocionOrderByWithAggregationInput | PromocionOrderByWithAggregationInput[]
    by: PromocionScalarFieldEnum[] | PromocionScalarFieldEnum
    having?: PromocionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromocionCountAggregateInputType | true
    _avg?: PromocionAvgAggregateInputType
    _sum?: PromocionSumAggregateInputType
    _min?: PromocionMinAggregateInputType
    _max?: PromocionMaxAggregateInputType
  }

  export type PromocionGroupByOutputType = {
    id: number
    nombre: string
    tipo: $Enums.TipoPromocion
    referencia_id_producto: number | null
    referencia_id_categoria: number | null
    valor: number
    fecha_inicio: Date
    fecha_fin: Date
    _count: PromocionCountAggregateOutputType | null
    _avg: PromocionAvgAggregateOutputType | null
    _sum: PromocionSumAggregateOutputType | null
    _min: PromocionMinAggregateOutputType | null
    _max: PromocionMaxAggregateOutputType | null
  }

  type GetPromocionGroupByPayload<T extends PromocionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromocionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromocionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromocionGroupByOutputType[P]>
            : GetScalarType<T[P], PromocionGroupByOutputType[P]>
        }
      >
    >


  export type PromocionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    tipo?: boolean
    referencia_id_producto?: boolean
    referencia_id_categoria?: boolean
    valor?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    producto?: boolean | Promocion$productoArgs<ExtArgs>
    categoria?: boolean | Promocion$categoriaArgs<ExtArgs>
    historial?: boolean | Promocion$historialArgs<ExtArgs>
    _count?: boolean | PromocionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promocion"]>



  export type PromocionSelectScalar = {
    id?: boolean
    nombre?: boolean
    tipo?: boolean
    referencia_id_producto?: boolean
    referencia_id_categoria?: boolean
    valor?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
  }

  export type PromocionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "tipo" | "referencia_id_producto" | "referencia_id_categoria" | "valor" | "fecha_inicio" | "fecha_fin", ExtArgs["result"]["promocion"]>
  export type PromocionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | Promocion$productoArgs<ExtArgs>
    categoria?: boolean | Promocion$categoriaArgs<ExtArgs>
    historial?: boolean | Promocion$historialArgs<ExtArgs>
    _count?: boolean | PromocionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PromocionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promocion"
    objects: {
      producto: Prisma.$ProductoPayload<ExtArgs> | null
      categoria: Prisma.$CategoriaPayload<ExtArgs> | null
      historial: Prisma.$HistorialPromocionAplicadaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      tipo: $Enums.TipoPromocion
      referencia_id_producto: number | null
      referencia_id_categoria: number | null
      valor: number
      fecha_inicio: Date
      fecha_fin: Date
    }, ExtArgs["result"]["promocion"]>
    composites: {}
  }

  type PromocionGetPayload<S extends boolean | null | undefined | PromocionDefaultArgs> = $Result.GetResult<Prisma.$PromocionPayload, S>

  type PromocionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromocionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromocionCountAggregateInputType | true
    }

  export interface PromocionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promocion'], meta: { name: 'Promocion' } }
    /**
     * Find zero or one Promocion that matches the filter.
     * @param {PromocionFindUniqueArgs} args - Arguments to find a Promocion
     * @example
     * // Get one Promocion
     * const promocion = await prisma.promocion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromocionFindUniqueArgs>(args: SelectSubset<T, PromocionFindUniqueArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Promocion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromocionFindUniqueOrThrowArgs} args - Arguments to find a Promocion
     * @example
     * // Get one Promocion
     * const promocion = await prisma.promocion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromocionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromocionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promocion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromocionFindFirstArgs} args - Arguments to find a Promocion
     * @example
     * // Get one Promocion
     * const promocion = await prisma.promocion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromocionFindFirstArgs>(args?: SelectSubset<T, PromocionFindFirstArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promocion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromocionFindFirstOrThrowArgs} args - Arguments to find a Promocion
     * @example
     * // Get one Promocion
     * const promocion = await prisma.promocion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromocionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromocionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Promocions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromocionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promocions
     * const promocions = await prisma.promocion.findMany()
     * 
     * // Get first 10 Promocions
     * const promocions = await prisma.promocion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promocionWithIdOnly = await prisma.promocion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromocionFindManyArgs>(args?: SelectSubset<T, PromocionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Promocion.
     * @param {PromocionCreateArgs} args - Arguments to create a Promocion.
     * @example
     * // Create one Promocion
     * const Promocion = await prisma.promocion.create({
     *   data: {
     *     // ... data to create a Promocion
     *   }
     * })
     * 
     */
    create<T extends PromocionCreateArgs>(args: SelectSubset<T, PromocionCreateArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Promocions.
     * @param {PromocionCreateManyArgs} args - Arguments to create many Promocions.
     * @example
     * // Create many Promocions
     * const promocion = await prisma.promocion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromocionCreateManyArgs>(args?: SelectSubset<T, PromocionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Promocion.
     * @param {PromocionDeleteArgs} args - Arguments to delete one Promocion.
     * @example
     * // Delete one Promocion
     * const Promocion = await prisma.promocion.delete({
     *   where: {
     *     // ... filter to delete one Promocion
     *   }
     * })
     * 
     */
    delete<T extends PromocionDeleteArgs>(args: SelectSubset<T, PromocionDeleteArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Promocion.
     * @param {PromocionUpdateArgs} args - Arguments to update one Promocion.
     * @example
     * // Update one Promocion
     * const promocion = await prisma.promocion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromocionUpdateArgs>(args: SelectSubset<T, PromocionUpdateArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Promocions.
     * @param {PromocionDeleteManyArgs} args - Arguments to filter Promocions to delete.
     * @example
     * // Delete a few Promocions
     * const { count } = await prisma.promocion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromocionDeleteManyArgs>(args?: SelectSubset<T, PromocionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promocions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromocionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promocions
     * const promocion = await prisma.promocion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromocionUpdateManyArgs>(args: SelectSubset<T, PromocionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Promocion.
     * @param {PromocionUpsertArgs} args - Arguments to update or create a Promocion.
     * @example
     * // Update or create a Promocion
     * const promocion = await prisma.promocion.upsert({
     *   create: {
     *     // ... data to create a Promocion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promocion we want to update
     *   }
     * })
     */
    upsert<T extends PromocionUpsertArgs>(args: SelectSubset<T, PromocionUpsertArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Promocions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromocionCountArgs} args - Arguments to filter Promocions to count.
     * @example
     * // Count the number of Promocions
     * const count = await prisma.promocion.count({
     *   where: {
     *     // ... the filter for the Promocions we want to count
     *   }
     * })
    **/
    count<T extends PromocionCountArgs>(
      args?: Subset<T, PromocionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromocionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promocion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromocionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromocionAggregateArgs>(args: Subset<T, PromocionAggregateArgs>): Prisma.PrismaPromise<GetPromocionAggregateType<T>>

    /**
     * Group by Promocion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromocionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromocionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromocionGroupByArgs['orderBy'] }
        : { orderBy?: PromocionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromocionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromocionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promocion model
   */
  readonly fields: PromocionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promocion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromocionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto<T extends Promocion$productoArgs<ExtArgs> = {}>(args?: Subset<T, Promocion$productoArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    categoria<T extends Promocion$categoriaArgs<ExtArgs> = {}>(args?: Subset<T, Promocion$categoriaArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    historial<T extends Promocion$historialArgs<ExtArgs> = {}>(args?: Subset<T, Promocion$historialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialPromocionAplicadaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promocion model
   */
  interface PromocionFieldRefs {
    readonly id: FieldRef<"Promocion", 'Int'>
    readonly nombre: FieldRef<"Promocion", 'String'>
    readonly tipo: FieldRef<"Promocion", 'TipoPromocion'>
    readonly referencia_id_producto: FieldRef<"Promocion", 'Int'>
    readonly referencia_id_categoria: FieldRef<"Promocion", 'Int'>
    readonly valor: FieldRef<"Promocion", 'Float'>
    readonly fecha_inicio: FieldRef<"Promocion", 'DateTime'>
    readonly fecha_fin: FieldRef<"Promocion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Promocion findUnique
   */
  export type PromocionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promocion
     */
    omit?: PromocionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * Filter, which Promocion to fetch.
     */
    where: PromocionWhereUniqueInput
  }

  /**
   * Promocion findUniqueOrThrow
   */
  export type PromocionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promocion
     */
    omit?: PromocionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * Filter, which Promocion to fetch.
     */
    where: PromocionWhereUniqueInput
  }

  /**
   * Promocion findFirst
   */
  export type PromocionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promocion
     */
    omit?: PromocionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * Filter, which Promocion to fetch.
     */
    where?: PromocionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promocions to fetch.
     */
    orderBy?: PromocionOrderByWithRelationInput | PromocionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promocions.
     */
    cursor?: PromocionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promocions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promocions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promocions.
     */
    distinct?: PromocionScalarFieldEnum | PromocionScalarFieldEnum[]
  }

  /**
   * Promocion findFirstOrThrow
   */
  export type PromocionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promocion
     */
    omit?: PromocionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * Filter, which Promocion to fetch.
     */
    where?: PromocionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promocions to fetch.
     */
    orderBy?: PromocionOrderByWithRelationInput | PromocionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promocions.
     */
    cursor?: PromocionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promocions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promocions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promocions.
     */
    distinct?: PromocionScalarFieldEnum | PromocionScalarFieldEnum[]
  }

  /**
   * Promocion findMany
   */
  export type PromocionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promocion
     */
    omit?: PromocionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * Filter, which Promocions to fetch.
     */
    where?: PromocionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promocions to fetch.
     */
    orderBy?: PromocionOrderByWithRelationInput | PromocionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promocions.
     */
    cursor?: PromocionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promocions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promocions.
     */
    skip?: number
    distinct?: PromocionScalarFieldEnum | PromocionScalarFieldEnum[]
  }

  /**
   * Promocion create
   */
  export type PromocionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promocion
     */
    omit?: PromocionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promocion.
     */
    data: XOR<PromocionCreateInput, PromocionUncheckedCreateInput>
  }

  /**
   * Promocion createMany
   */
  export type PromocionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promocions.
     */
    data: PromocionCreateManyInput | PromocionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promocion update
   */
  export type PromocionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promocion
     */
    omit?: PromocionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promocion.
     */
    data: XOR<PromocionUpdateInput, PromocionUncheckedUpdateInput>
    /**
     * Choose, which Promocion to update.
     */
    where: PromocionWhereUniqueInput
  }

  /**
   * Promocion updateMany
   */
  export type PromocionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promocions.
     */
    data: XOR<PromocionUpdateManyMutationInput, PromocionUncheckedUpdateManyInput>
    /**
     * Filter which Promocions to update
     */
    where?: PromocionWhereInput
    /**
     * Limit how many Promocions to update.
     */
    limit?: number
  }

  /**
   * Promocion upsert
   */
  export type PromocionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promocion
     */
    omit?: PromocionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promocion to update in case it exists.
     */
    where: PromocionWhereUniqueInput
    /**
     * In case the Promocion found by the `where` argument doesn't exist, create a new Promocion with this data.
     */
    create: XOR<PromocionCreateInput, PromocionUncheckedCreateInput>
    /**
     * In case the Promocion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromocionUpdateInput, PromocionUncheckedUpdateInput>
  }

  /**
   * Promocion delete
   */
  export type PromocionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promocion
     */
    omit?: PromocionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * Filter which Promocion to delete.
     */
    where: PromocionWhereUniqueInput
  }

  /**
   * Promocion deleteMany
   */
  export type PromocionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promocions to delete
     */
    where?: PromocionWhereInput
    /**
     * Limit how many Promocions to delete.
     */
    limit?: number
  }

  /**
   * Promocion.producto
   */
  export type Promocion$productoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Producto
     */
    omit?: ProductoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    where?: ProductoWhereInput
  }

  /**
   * Promocion.categoria
   */
  export type Promocion$categoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    where?: CategoriaWhereInput
  }

  /**
   * Promocion.historial
   */
  export type Promocion$historialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPromocionAplicada
     */
    select?: HistorialPromocionAplicadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorialPromocionAplicada
     */
    omit?: HistorialPromocionAplicadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPromocionAplicadaInclude<ExtArgs> | null
    where?: HistorialPromocionAplicadaWhereInput
    orderBy?: HistorialPromocionAplicadaOrderByWithRelationInput | HistorialPromocionAplicadaOrderByWithRelationInput[]
    cursor?: HistorialPromocionAplicadaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialPromocionAplicadaScalarFieldEnum | HistorialPromocionAplicadaScalarFieldEnum[]
  }

  /**
   * Promocion without action
   */
  export type PromocionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promocion
     */
    omit?: PromocionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
  }


  /**
   * Model HistorialPromocionAplicada
   */

  export type AggregateHistorialPromocionAplicada = {
    _count: HistorialPromocionAplicadaCountAggregateOutputType | null
    _avg: HistorialPromocionAplicadaAvgAggregateOutputType | null
    _sum: HistorialPromocionAplicadaSumAggregateOutputType | null
    _min: HistorialPromocionAplicadaMinAggregateOutputType | null
    _max: HistorialPromocionAplicadaMaxAggregateOutputType | null
  }

  export type HistorialPromocionAplicadaAvgAggregateOutputType = {
    id: number | null
    promocion_id: number | null
    pedido_id: number | null
  }

  export type HistorialPromocionAplicadaSumAggregateOutputType = {
    id: number | null
    promocion_id: number | null
    pedido_id: number | null
  }

  export type HistorialPromocionAplicadaMinAggregateOutputType = {
    id: number | null
    promocion_id: number | null
    pedido_id: number | null
    fecha: Date | null
  }

  export type HistorialPromocionAplicadaMaxAggregateOutputType = {
    id: number | null
    promocion_id: number | null
    pedido_id: number | null
    fecha: Date | null
  }

  export type HistorialPromocionAplicadaCountAggregateOutputType = {
    id: number
    promocion_id: number
    pedido_id: number
    fecha: number
    _all: number
  }


  export type HistorialPromocionAplicadaAvgAggregateInputType = {
    id?: true
    promocion_id?: true
    pedido_id?: true
  }

  export type HistorialPromocionAplicadaSumAggregateInputType = {
    id?: true
    promocion_id?: true
    pedido_id?: true
  }

  export type HistorialPromocionAplicadaMinAggregateInputType = {
    id?: true
    promocion_id?: true
    pedido_id?: true
    fecha?: true
  }

  export type HistorialPromocionAplicadaMaxAggregateInputType = {
    id?: true
    promocion_id?: true
    pedido_id?: true
    fecha?: true
  }

  export type HistorialPromocionAplicadaCountAggregateInputType = {
    id?: true
    promocion_id?: true
    pedido_id?: true
    fecha?: true
    _all?: true
  }

  export type HistorialPromocionAplicadaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistorialPromocionAplicada to aggregate.
     */
    where?: HistorialPromocionAplicadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialPromocionAplicadas to fetch.
     */
    orderBy?: HistorialPromocionAplicadaOrderByWithRelationInput | HistorialPromocionAplicadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistorialPromocionAplicadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialPromocionAplicadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialPromocionAplicadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HistorialPromocionAplicadas
    **/
    _count?: true | HistorialPromocionAplicadaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistorialPromocionAplicadaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistorialPromocionAplicadaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistorialPromocionAplicadaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistorialPromocionAplicadaMaxAggregateInputType
  }

  export type GetHistorialPromocionAplicadaAggregateType<T extends HistorialPromocionAplicadaAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorialPromocionAplicada]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorialPromocionAplicada[P]>
      : GetScalarType<T[P], AggregateHistorialPromocionAplicada[P]>
  }




  export type HistorialPromocionAplicadaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialPromocionAplicadaWhereInput
    orderBy?: HistorialPromocionAplicadaOrderByWithAggregationInput | HistorialPromocionAplicadaOrderByWithAggregationInput[]
    by: HistorialPromocionAplicadaScalarFieldEnum[] | HistorialPromocionAplicadaScalarFieldEnum
    having?: HistorialPromocionAplicadaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistorialPromocionAplicadaCountAggregateInputType | true
    _avg?: HistorialPromocionAplicadaAvgAggregateInputType
    _sum?: HistorialPromocionAplicadaSumAggregateInputType
    _min?: HistorialPromocionAplicadaMinAggregateInputType
    _max?: HistorialPromocionAplicadaMaxAggregateInputType
  }

  export type HistorialPromocionAplicadaGroupByOutputType = {
    id: number
    promocion_id: number
    pedido_id: number
    fecha: Date
    _count: HistorialPromocionAplicadaCountAggregateOutputType | null
    _avg: HistorialPromocionAplicadaAvgAggregateOutputType | null
    _sum: HistorialPromocionAplicadaSumAggregateOutputType | null
    _min: HistorialPromocionAplicadaMinAggregateOutputType | null
    _max: HistorialPromocionAplicadaMaxAggregateOutputType | null
  }

  type GetHistorialPromocionAplicadaGroupByPayload<T extends HistorialPromocionAplicadaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistorialPromocionAplicadaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistorialPromocionAplicadaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistorialPromocionAplicadaGroupByOutputType[P]>
            : GetScalarType<T[P], HistorialPromocionAplicadaGroupByOutputType[P]>
        }
      >
    >


  export type HistorialPromocionAplicadaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promocion_id?: boolean
    pedido_id?: boolean
    fecha?: boolean
    promocion?: boolean | PromocionDefaultArgs<ExtArgs>
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historialPromocionAplicada"]>



  export type HistorialPromocionAplicadaSelectScalar = {
    id?: boolean
    promocion_id?: boolean
    pedido_id?: boolean
    fecha?: boolean
  }

  export type HistorialPromocionAplicadaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "promocion_id" | "pedido_id" | "fecha", ExtArgs["result"]["historialPromocionAplicada"]>
  export type HistorialPromocionAplicadaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promocion?: boolean | PromocionDefaultArgs<ExtArgs>
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
  }

  export type $HistorialPromocionAplicadaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HistorialPromocionAplicada"
    objects: {
      promocion: Prisma.$PromocionPayload<ExtArgs>
      pedido: Prisma.$PedidoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      promocion_id: number
      pedido_id: number
      fecha: Date
    }, ExtArgs["result"]["historialPromocionAplicada"]>
    composites: {}
  }

  type HistorialPromocionAplicadaGetPayload<S extends boolean | null | undefined | HistorialPromocionAplicadaDefaultArgs> = $Result.GetResult<Prisma.$HistorialPromocionAplicadaPayload, S>

  type HistorialPromocionAplicadaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HistorialPromocionAplicadaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistorialPromocionAplicadaCountAggregateInputType | true
    }

  export interface HistorialPromocionAplicadaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HistorialPromocionAplicada'], meta: { name: 'HistorialPromocionAplicada' } }
    /**
     * Find zero or one HistorialPromocionAplicada that matches the filter.
     * @param {HistorialPromocionAplicadaFindUniqueArgs} args - Arguments to find a HistorialPromocionAplicada
     * @example
     * // Get one HistorialPromocionAplicada
     * const historialPromocionAplicada = await prisma.historialPromocionAplicada.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HistorialPromocionAplicadaFindUniqueArgs>(args: SelectSubset<T, HistorialPromocionAplicadaFindUniqueArgs<ExtArgs>>): Prisma__HistorialPromocionAplicadaClient<$Result.GetResult<Prisma.$HistorialPromocionAplicadaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HistorialPromocionAplicada that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HistorialPromocionAplicadaFindUniqueOrThrowArgs} args - Arguments to find a HistorialPromocionAplicada
     * @example
     * // Get one HistorialPromocionAplicada
     * const historialPromocionAplicada = await prisma.historialPromocionAplicada.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HistorialPromocionAplicadaFindUniqueOrThrowArgs>(args: SelectSubset<T, HistorialPromocionAplicadaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HistorialPromocionAplicadaClient<$Result.GetResult<Prisma.$HistorialPromocionAplicadaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HistorialPromocionAplicada that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialPromocionAplicadaFindFirstArgs} args - Arguments to find a HistorialPromocionAplicada
     * @example
     * // Get one HistorialPromocionAplicada
     * const historialPromocionAplicada = await prisma.historialPromocionAplicada.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HistorialPromocionAplicadaFindFirstArgs>(args?: SelectSubset<T, HistorialPromocionAplicadaFindFirstArgs<ExtArgs>>): Prisma__HistorialPromocionAplicadaClient<$Result.GetResult<Prisma.$HistorialPromocionAplicadaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HistorialPromocionAplicada that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialPromocionAplicadaFindFirstOrThrowArgs} args - Arguments to find a HistorialPromocionAplicada
     * @example
     * // Get one HistorialPromocionAplicada
     * const historialPromocionAplicada = await prisma.historialPromocionAplicada.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HistorialPromocionAplicadaFindFirstOrThrowArgs>(args?: SelectSubset<T, HistorialPromocionAplicadaFindFirstOrThrowArgs<ExtArgs>>): Prisma__HistorialPromocionAplicadaClient<$Result.GetResult<Prisma.$HistorialPromocionAplicadaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HistorialPromocionAplicadas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialPromocionAplicadaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistorialPromocionAplicadas
     * const historialPromocionAplicadas = await prisma.historialPromocionAplicada.findMany()
     * 
     * // Get first 10 HistorialPromocionAplicadas
     * const historialPromocionAplicadas = await prisma.historialPromocionAplicada.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historialPromocionAplicadaWithIdOnly = await prisma.historialPromocionAplicada.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HistorialPromocionAplicadaFindManyArgs>(args?: SelectSubset<T, HistorialPromocionAplicadaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialPromocionAplicadaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HistorialPromocionAplicada.
     * @param {HistorialPromocionAplicadaCreateArgs} args - Arguments to create a HistorialPromocionAplicada.
     * @example
     * // Create one HistorialPromocionAplicada
     * const HistorialPromocionAplicada = await prisma.historialPromocionAplicada.create({
     *   data: {
     *     // ... data to create a HistorialPromocionAplicada
     *   }
     * })
     * 
     */
    create<T extends HistorialPromocionAplicadaCreateArgs>(args: SelectSubset<T, HistorialPromocionAplicadaCreateArgs<ExtArgs>>): Prisma__HistorialPromocionAplicadaClient<$Result.GetResult<Prisma.$HistorialPromocionAplicadaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HistorialPromocionAplicadas.
     * @param {HistorialPromocionAplicadaCreateManyArgs} args - Arguments to create many HistorialPromocionAplicadas.
     * @example
     * // Create many HistorialPromocionAplicadas
     * const historialPromocionAplicada = await prisma.historialPromocionAplicada.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HistorialPromocionAplicadaCreateManyArgs>(args?: SelectSubset<T, HistorialPromocionAplicadaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HistorialPromocionAplicada.
     * @param {HistorialPromocionAplicadaDeleteArgs} args - Arguments to delete one HistorialPromocionAplicada.
     * @example
     * // Delete one HistorialPromocionAplicada
     * const HistorialPromocionAplicada = await prisma.historialPromocionAplicada.delete({
     *   where: {
     *     // ... filter to delete one HistorialPromocionAplicada
     *   }
     * })
     * 
     */
    delete<T extends HistorialPromocionAplicadaDeleteArgs>(args: SelectSubset<T, HistorialPromocionAplicadaDeleteArgs<ExtArgs>>): Prisma__HistorialPromocionAplicadaClient<$Result.GetResult<Prisma.$HistorialPromocionAplicadaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HistorialPromocionAplicada.
     * @param {HistorialPromocionAplicadaUpdateArgs} args - Arguments to update one HistorialPromocionAplicada.
     * @example
     * // Update one HistorialPromocionAplicada
     * const historialPromocionAplicada = await prisma.historialPromocionAplicada.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HistorialPromocionAplicadaUpdateArgs>(args: SelectSubset<T, HistorialPromocionAplicadaUpdateArgs<ExtArgs>>): Prisma__HistorialPromocionAplicadaClient<$Result.GetResult<Prisma.$HistorialPromocionAplicadaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HistorialPromocionAplicadas.
     * @param {HistorialPromocionAplicadaDeleteManyArgs} args - Arguments to filter HistorialPromocionAplicadas to delete.
     * @example
     * // Delete a few HistorialPromocionAplicadas
     * const { count } = await prisma.historialPromocionAplicada.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HistorialPromocionAplicadaDeleteManyArgs>(args?: SelectSubset<T, HistorialPromocionAplicadaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistorialPromocionAplicadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialPromocionAplicadaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistorialPromocionAplicadas
     * const historialPromocionAplicada = await prisma.historialPromocionAplicada.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HistorialPromocionAplicadaUpdateManyArgs>(args: SelectSubset<T, HistorialPromocionAplicadaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HistorialPromocionAplicada.
     * @param {HistorialPromocionAplicadaUpsertArgs} args - Arguments to update or create a HistorialPromocionAplicada.
     * @example
     * // Update or create a HistorialPromocionAplicada
     * const historialPromocionAplicada = await prisma.historialPromocionAplicada.upsert({
     *   create: {
     *     // ... data to create a HistorialPromocionAplicada
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistorialPromocionAplicada we want to update
     *   }
     * })
     */
    upsert<T extends HistorialPromocionAplicadaUpsertArgs>(args: SelectSubset<T, HistorialPromocionAplicadaUpsertArgs<ExtArgs>>): Prisma__HistorialPromocionAplicadaClient<$Result.GetResult<Prisma.$HistorialPromocionAplicadaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HistorialPromocionAplicadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialPromocionAplicadaCountArgs} args - Arguments to filter HistorialPromocionAplicadas to count.
     * @example
     * // Count the number of HistorialPromocionAplicadas
     * const count = await prisma.historialPromocionAplicada.count({
     *   where: {
     *     // ... the filter for the HistorialPromocionAplicadas we want to count
     *   }
     * })
    **/
    count<T extends HistorialPromocionAplicadaCountArgs>(
      args?: Subset<T, HistorialPromocionAplicadaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistorialPromocionAplicadaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistorialPromocionAplicada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialPromocionAplicadaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistorialPromocionAplicadaAggregateArgs>(args: Subset<T, HistorialPromocionAplicadaAggregateArgs>): Prisma.PrismaPromise<GetHistorialPromocionAplicadaAggregateType<T>>

    /**
     * Group by HistorialPromocionAplicada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialPromocionAplicadaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistorialPromocionAplicadaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistorialPromocionAplicadaGroupByArgs['orderBy'] }
        : { orderBy?: HistorialPromocionAplicadaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistorialPromocionAplicadaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorialPromocionAplicadaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HistorialPromocionAplicada model
   */
  readonly fields: HistorialPromocionAplicadaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HistorialPromocionAplicada.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistorialPromocionAplicadaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    promocion<T extends PromocionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromocionDefaultArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pedido<T extends PedidoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoDefaultArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HistorialPromocionAplicada model
   */
  interface HistorialPromocionAplicadaFieldRefs {
    readonly id: FieldRef<"HistorialPromocionAplicada", 'Int'>
    readonly promocion_id: FieldRef<"HistorialPromocionAplicada", 'Int'>
    readonly pedido_id: FieldRef<"HistorialPromocionAplicada", 'Int'>
    readonly fecha: FieldRef<"HistorialPromocionAplicada", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HistorialPromocionAplicada findUnique
   */
  export type HistorialPromocionAplicadaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPromocionAplicada
     */
    select?: HistorialPromocionAplicadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorialPromocionAplicada
     */
    omit?: HistorialPromocionAplicadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPromocionAplicadaInclude<ExtArgs> | null
    /**
     * Filter, which HistorialPromocionAplicada to fetch.
     */
    where: HistorialPromocionAplicadaWhereUniqueInput
  }

  /**
   * HistorialPromocionAplicada findUniqueOrThrow
   */
  export type HistorialPromocionAplicadaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPromocionAplicada
     */
    select?: HistorialPromocionAplicadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorialPromocionAplicada
     */
    omit?: HistorialPromocionAplicadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPromocionAplicadaInclude<ExtArgs> | null
    /**
     * Filter, which HistorialPromocionAplicada to fetch.
     */
    where: HistorialPromocionAplicadaWhereUniqueInput
  }

  /**
   * HistorialPromocionAplicada findFirst
   */
  export type HistorialPromocionAplicadaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPromocionAplicada
     */
    select?: HistorialPromocionAplicadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorialPromocionAplicada
     */
    omit?: HistorialPromocionAplicadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPromocionAplicadaInclude<ExtArgs> | null
    /**
     * Filter, which HistorialPromocionAplicada to fetch.
     */
    where?: HistorialPromocionAplicadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialPromocionAplicadas to fetch.
     */
    orderBy?: HistorialPromocionAplicadaOrderByWithRelationInput | HistorialPromocionAplicadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistorialPromocionAplicadas.
     */
    cursor?: HistorialPromocionAplicadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialPromocionAplicadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialPromocionAplicadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistorialPromocionAplicadas.
     */
    distinct?: HistorialPromocionAplicadaScalarFieldEnum | HistorialPromocionAplicadaScalarFieldEnum[]
  }

  /**
   * HistorialPromocionAplicada findFirstOrThrow
   */
  export type HistorialPromocionAplicadaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPromocionAplicada
     */
    select?: HistorialPromocionAplicadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorialPromocionAplicada
     */
    omit?: HistorialPromocionAplicadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPromocionAplicadaInclude<ExtArgs> | null
    /**
     * Filter, which HistorialPromocionAplicada to fetch.
     */
    where?: HistorialPromocionAplicadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialPromocionAplicadas to fetch.
     */
    orderBy?: HistorialPromocionAplicadaOrderByWithRelationInput | HistorialPromocionAplicadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistorialPromocionAplicadas.
     */
    cursor?: HistorialPromocionAplicadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialPromocionAplicadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialPromocionAplicadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistorialPromocionAplicadas.
     */
    distinct?: HistorialPromocionAplicadaScalarFieldEnum | HistorialPromocionAplicadaScalarFieldEnum[]
  }

  /**
   * HistorialPromocionAplicada findMany
   */
  export type HistorialPromocionAplicadaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPromocionAplicada
     */
    select?: HistorialPromocionAplicadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorialPromocionAplicada
     */
    omit?: HistorialPromocionAplicadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPromocionAplicadaInclude<ExtArgs> | null
    /**
     * Filter, which HistorialPromocionAplicadas to fetch.
     */
    where?: HistorialPromocionAplicadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialPromocionAplicadas to fetch.
     */
    orderBy?: HistorialPromocionAplicadaOrderByWithRelationInput | HistorialPromocionAplicadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HistorialPromocionAplicadas.
     */
    cursor?: HistorialPromocionAplicadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialPromocionAplicadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialPromocionAplicadas.
     */
    skip?: number
    distinct?: HistorialPromocionAplicadaScalarFieldEnum | HistorialPromocionAplicadaScalarFieldEnum[]
  }

  /**
   * HistorialPromocionAplicada create
   */
  export type HistorialPromocionAplicadaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPromocionAplicada
     */
    select?: HistorialPromocionAplicadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorialPromocionAplicada
     */
    omit?: HistorialPromocionAplicadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPromocionAplicadaInclude<ExtArgs> | null
    /**
     * The data needed to create a HistorialPromocionAplicada.
     */
    data: XOR<HistorialPromocionAplicadaCreateInput, HistorialPromocionAplicadaUncheckedCreateInput>
  }

  /**
   * HistorialPromocionAplicada createMany
   */
  export type HistorialPromocionAplicadaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HistorialPromocionAplicadas.
     */
    data: HistorialPromocionAplicadaCreateManyInput | HistorialPromocionAplicadaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HistorialPromocionAplicada update
   */
  export type HistorialPromocionAplicadaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPromocionAplicada
     */
    select?: HistorialPromocionAplicadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorialPromocionAplicada
     */
    omit?: HistorialPromocionAplicadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPromocionAplicadaInclude<ExtArgs> | null
    /**
     * The data needed to update a HistorialPromocionAplicada.
     */
    data: XOR<HistorialPromocionAplicadaUpdateInput, HistorialPromocionAplicadaUncheckedUpdateInput>
    /**
     * Choose, which HistorialPromocionAplicada to update.
     */
    where: HistorialPromocionAplicadaWhereUniqueInput
  }

  /**
   * HistorialPromocionAplicada updateMany
   */
  export type HistorialPromocionAplicadaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HistorialPromocionAplicadas.
     */
    data: XOR<HistorialPromocionAplicadaUpdateManyMutationInput, HistorialPromocionAplicadaUncheckedUpdateManyInput>
    /**
     * Filter which HistorialPromocionAplicadas to update
     */
    where?: HistorialPromocionAplicadaWhereInput
    /**
     * Limit how many HistorialPromocionAplicadas to update.
     */
    limit?: number
  }

  /**
   * HistorialPromocionAplicada upsert
   */
  export type HistorialPromocionAplicadaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPromocionAplicada
     */
    select?: HistorialPromocionAplicadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorialPromocionAplicada
     */
    omit?: HistorialPromocionAplicadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPromocionAplicadaInclude<ExtArgs> | null
    /**
     * The filter to search for the HistorialPromocionAplicada to update in case it exists.
     */
    where: HistorialPromocionAplicadaWhereUniqueInput
    /**
     * In case the HistorialPromocionAplicada found by the `where` argument doesn't exist, create a new HistorialPromocionAplicada with this data.
     */
    create: XOR<HistorialPromocionAplicadaCreateInput, HistorialPromocionAplicadaUncheckedCreateInput>
    /**
     * In case the HistorialPromocionAplicada was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistorialPromocionAplicadaUpdateInput, HistorialPromocionAplicadaUncheckedUpdateInput>
  }

  /**
   * HistorialPromocionAplicada delete
   */
  export type HistorialPromocionAplicadaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPromocionAplicada
     */
    select?: HistorialPromocionAplicadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorialPromocionAplicada
     */
    omit?: HistorialPromocionAplicadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPromocionAplicadaInclude<ExtArgs> | null
    /**
     * Filter which HistorialPromocionAplicada to delete.
     */
    where: HistorialPromocionAplicadaWhereUniqueInput
  }

  /**
   * HistorialPromocionAplicada deleteMany
   */
  export type HistorialPromocionAplicadaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistorialPromocionAplicadas to delete
     */
    where?: HistorialPromocionAplicadaWhereInput
    /**
     * Limit how many HistorialPromocionAplicadas to delete.
     */
    limit?: number
  }

  /**
   * HistorialPromocionAplicada without action
   */
  export type HistorialPromocionAplicadaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPromocionAplicada
     */
    select?: HistorialPromocionAplicadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorialPromocionAplicada
     */
    omit?: HistorialPromocionAplicadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPromocionAplicadaInclude<ExtArgs> | null
  }


  /**
   * Model Pedido
   */

  export type AggregatePedido = {
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  export type PedidoAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    subtotal: number | null
    total: number | null
    impuestos: number | null
  }

  export type PedidoSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    subtotal: number | null
    total: number | null
    impuestos: number | null
  }

  export type PedidoMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    fecha_pedido: Date | null
    direccion_envio: string | null
    metodo_pago: $Enums.MetodoPago | null
    subtotal: number | null
    total: number | null
    impuestos: number | null
    estado_carrito: boolean | null
  }

  export type PedidoMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    fecha_pedido: Date | null
    direccion_envio: string | null
    metodo_pago: $Enums.MetodoPago | null
    subtotal: number | null
    total: number | null
    impuestos: number | null
    estado_carrito: boolean | null
  }

  export type PedidoCountAggregateOutputType = {
    id: number
    usuario_id: number
    fecha_pedido: number
    direccion_envio: number
    metodo_pago: number
    subtotal: number
    total: number
    impuestos: number
    estado_carrito: number
    _all: number
  }


  export type PedidoAvgAggregateInputType = {
    id?: true
    usuario_id?: true
    subtotal?: true
    total?: true
    impuestos?: true
  }

  export type PedidoSumAggregateInputType = {
    id?: true
    usuario_id?: true
    subtotal?: true
    total?: true
    impuestos?: true
  }

  export type PedidoMinAggregateInputType = {
    id?: true
    usuario_id?: true
    fecha_pedido?: true
    direccion_envio?: true
    metodo_pago?: true
    subtotal?: true
    total?: true
    impuestos?: true
    estado_carrito?: true
  }

  export type PedidoMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    fecha_pedido?: true
    direccion_envio?: true
    metodo_pago?: true
    subtotal?: true
    total?: true
    impuestos?: true
    estado_carrito?: true
  }

  export type PedidoCountAggregateInputType = {
    id?: true
    usuario_id?: true
    fecha_pedido?: true
    direccion_envio?: true
    metodo_pago?: true
    subtotal?: true
    total?: true
    impuestos?: true
    estado_carrito?: true
    _all?: true
  }

  export type PedidoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pedido to aggregate.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pedidos
    **/
    _count?: true | PedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoMaxAggregateInputType
  }

  export type GetPedidoAggregateType<T extends PedidoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido[P]>
      : GetScalarType<T[P], AggregatePedido[P]>
  }




  export type PedidoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithAggregationInput | PedidoOrderByWithAggregationInput[]
    by: PedidoScalarFieldEnum[] | PedidoScalarFieldEnum
    having?: PedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoCountAggregateInputType | true
    _avg?: PedidoAvgAggregateInputType
    _sum?: PedidoSumAggregateInputType
    _min?: PedidoMinAggregateInputType
    _max?: PedidoMaxAggregateInputType
  }

  export type PedidoGroupByOutputType = {
    id: number
    usuario_id: number
    fecha_pedido: Date
    direccion_envio: string
    metodo_pago: $Enums.MetodoPago
    subtotal: number
    total: number
    impuestos: number
    estado_carrito: boolean
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  type GetPedidoGroupByPayload<T extends PedidoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoGroupByOutputType[P]>
        }
      >
    >


  export type PedidoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    fecha_pedido?: boolean
    direccion_envio?: boolean
    metodo_pago?: boolean
    subtotal?: boolean
    total?: boolean
    impuestos?: boolean
    estado_carrito?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    items?: boolean | Pedido$itemsArgs<ExtArgs>
    transiciones?: boolean | Pedido$transicionesArgs<ExtArgs>
    promociones_aplicadas?: boolean | Pedido$promociones_aplicadasArgs<ExtArgs>
    _count?: boolean | PedidoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedido"]>



  export type PedidoSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    fecha_pedido?: boolean
    direccion_envio?: boolean
    metodo_pago?: boolean
    subtotal?: boolean
    total?: boolean
    impuestos?: boolean
    estado_carrito?: boolean
  }

  export type PedidoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "fecha_pedido" | "direccion_envio" | "metodo_pago" | "subtotal" | "total" | "impuestos" | "estado_carrito", ExtArgs["result"]["pedido"]>
  export type PedidoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    items?: boolean | Pedido$itemsArgs<ExtArgs>
    transiciones?: boolean | Pedido$transicionesArgs<ExtArgs>
    promociones_aplicadas?: boolean | Pedido$promociones_aplicadasArgs<ExtArgs>
    _count?: boolean | PedidoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PedidoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pedido"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      items: Prisma.$PedidoItemPayload<ExtArgs>[]
      transiciones: Prisma.$TransicionEstadoPedidoPayload<ExtArgs>[]
      promociones_aplicadas: Prisma.$HistorialPromocionAplicadaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
      fecha_pedido: Date
      direccion_envio: string
      metodo_pago: $Enums.MetodoPago
      subtotal: number
      total: number
      impuestos: number
      estado_carrito: boolean
    }, ExtArgs["result"]["pedido"]>
    composites: {}
  }

  type PedidoGetPayload<S extends boolean | null | undefined | PedidoDefaultArgs> = $Result.GetResult<Prisma.$PedidoPayload, S>

  type PedidoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PedidoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PedidoCountAggregateInputType | true
    }

  export interface PedidoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pedido'], meta: { name: 'Pedido' } }
    /**
     * Find zero or one Pedido that matches the filter.
     * @param {PedidoFindUniqueArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PedidoFindUniqueArgs>(args: SelectSubset<T, PedidoFindUniqueArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pedido that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PedidoFindUniqueOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PedidoFindUniqueOrThrowArgs>(args: SelectSubset<T, PedidoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PedidoFindFirstArgs>(args?: SelectSubset<T, PedidoFindFirstArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pedido that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PedidoFindFirstOrThrowArgs>(args?: SelectSubset<T, PedidoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedidos
     * const pedidos = await prisma.pedido.findMany()
     * 
     * // Get first 10 Pedidos
     * const pedidos = await prisma.pedido.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pedidoWithIdOnly = await prisma.pedido.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PedidoFindManyArgs>(args?: SelectSubset<T, PedidoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pedido.
     * @param {PedidoCreateArgs} args - Arguments to create a Pedido.
     * @example
     * // Create one Pedido
     * const Pedido = await prisma.pedido.create({
     *   data: {
     *     // ... data to create a Pedido
     *   }
     * })
     * 
     */
    create<T extends PedidoCreateArgs>(args: SelectSubset<T, PedidoCreateArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pedidos.
     * @param {PedidoCreateManyArgs} args - Arguments to create many Pedidos.
     * @example
     * // Create many Pedidos
     * const pedido = await prisma.pedido.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PedidoCreateManyArgs>(args?: SelectSubset<T, PedidoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pedido.
     * @param {PedidoDeleteArgs} args - Arguments to delete one Pedido.
     * @example
     * // Delete one Pedido
     * const Pedido = await prisma.pedido.delete({
     *   where: {
     *     // ... filter to delete one Pedido
     *   }
     * })
     * 
     */
    delete<T extends PedidoDeleteArgs>(args: SelectSubset<T, PedidoDeleteArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pedido.
     * @param {PedidoUpdateArgs} args - Arguments to update one Pedido.
     * @example
     * // Update one Pedido
     * const pedido = await prisma.pedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PedidoUpdateArgs>(args: SelectSubset<T, PedidoUpdateArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pedidos.
     * @param {PedidoDeleteManyArgs} args - Arguments to filter Pedidos to delete.
     * @example
     * // Delete a few Pedidos
     * const { count } = await prisma.pedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PedidoDeleteManyArgs>(args?: SelectSubset<T, PedidoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedidos
     * const pedido = await prisma.pedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PedidoUpdateManyArgs>(args: SelectSubset<T, PedidoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pedido.
     * @param {PedidoUpsertArgs} args - Arguments to update or create a Pedido.
     * @example
     * // Update or create a Pedido
     * const pedido = await prisma.pedido.upsert({
     *   create: {
     *     // ... data to create a Pedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido we want to update
     *   }
     * })
     */
    upsert<T extends PedidoUpsertArgs>(args: SelectSubset<T, PedidoUpsertArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoCountArgs} args - Arguments to filter Pedidos to count.
     * @example
     * // Count the number of Pedidos
     * const count = await prisma.pedido.count({
     *   where: {
     *     // ... the filter for the Pedidos we want to count
     *   }
     * })
    **/
    count<T extends PedidoCountArgs>(
      args?: Subset<T, PedidoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoAggregateArgs>(args: Subset<T, PedidoAggregateArgs>): Prisma.PrismaPromise<GetPedidoAggregateType<T>>

    /**
     * Group by Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoGroupByArgs['orderBy'] }
        : { orderBy?: PedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pedido model
   */
  readonly fields: PedidoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PedidoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Pedido$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transiciones<T extends Pedido$transicionesArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$transicionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransicionEstadoPedidoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promociones_aplicadas<T extends Pedido$promociones_aplicadasArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$promociones_aplicadasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialPromocionAplicadaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pedido model
   */
  interface PedidoFieldRefs {
    readonly id: FieldRef<"Pedido", 'Int'>
    readonly usuario_id: FieldRef<"Pedido", 'Int'>
    readonly fecha_pedido: FieldRef<"Pedido", 'DateTime'>
    readonly direccion_envio: FieldRef<"Pedido", 'String'>
    readonly metodo_pago: FieldRef<"Pedido", 'MetodoPago'>
    readonly subtotal: FieldRef<"Pedido", 'Float'>
    readonly total: FieldRef<"Pedido", 'Float'>
    readonly impuestos: FieldRef<"Pedido", 'Float'>
    readonly estado_carrito: FieldRef<"Pedido", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Pedido findUnique
   */
  export type PedidoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido findUniqueOrThrow
   */
  export type PedidoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido findFirst
   */
  export type PedidoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Pedido findFirstOrThrow
   */
  export type PedidoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Pedido findMany
   */
  export type PedidoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedidos to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Pedido create
   */
  export type PedidoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pedido.
     */
    data: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
  }

  /**
   * Pedido createMany
   */
  export type PedidoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pedidos.
     */
    data: PedidoCreateManyInput | PedidoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pedido update
   */
  export type PedidoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pedido.
     */
    data: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
    /**
     * Choose, which Pedido to update.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido updateMany
   */
  export type PedidoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pedidos.
     */
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyInput>
    /**
     * Filter which Pedidos to update
     */
    where?: PedidoWhereInput
    /**
     * Limit how many Pedidos to update.
     */
    limit?: number
  }

  /**
   * Pedido upsert
   */
  export type PedidoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pedido to update in case it exists.
     */
    where: PedidoWhereUniqueInput
    /**
     * In case the Pedido found by the `where` argument doesn't exist, create a new Pedido with this data.
     */
    create: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
    /**
     * In case the Pedido was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
  }

  /**
   * Pedido delete
   */
  export type PedidoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter which Pedido to delete.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido deleteMany
   */
  export type PedidoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pedidos to delete
     */
    where?: PedidoWhereInput
    /**
     * Limit how many Pedidos to delete.
     */
    limit?: number
  }

  /**
   * Pedido.items
   */
  export type Pedido$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    where?: PedidoItemWhereInput
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    cursor?: PedidoItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * Pedido.transiciones
   */
  export type Pedido$transicionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransicionEstadoPedido
     */
    select?: TransicionEstadoPedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransicionEstadoPedido
     */
    omit?: TransicionEstadoPedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransicionEstadoPedidoInclude<ExtArgs> | null
    where?: TransicionEstadoPedidoWhereInput
    orderBy?: TransicionEstadoPedidoOrderByWithRelationInput | TransicionEstadoPedidoOrderByWithRelationInput[]
    cursor?: TransicionEstadoPedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransicionEstadoPedidoScalarFieldEnum | TransicionEstadoPedidoScalarFieldEnum[]
  }

  /**
   * Pedido.promociones_aplicadas
   */
  export type Pedido$promociones_aplicadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPromocionAplicada
     */
    select?: HistorialPromocionAplicadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorialPromocionAplicada
     */
    omit?: HistorialPromocionAplicadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPromocionAplicadaInclude<ExtArgs> | null
    where?: HistorialPromocionAplicadaWhereInput
    orderBy?: HistorialPromocionAplicadaOrderByWithRelationInput | HistorialPromocionAplicadaOrderByWithRelationInput[]
    cursor?: HistorialPromocionAplicadaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialPromocionAplicadaScalarFieldEnum | HistorialPromocionAplicadaScalarFieldEnum[]
  }

  /**
   * Pedido without action
   */
  export type PedidoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pedido
     */
    omit?: PedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
  }


  /**
   * Model PedidoItem
   */

  export type AggregatePedidoItem = {
    _count: PedidoItemCountAggregateOutputType | null
    _avg: PedidoItemAvgAggregateOutputType | null
    _sum: PedidoItemSumAggregateOutputType | null
    _min: PedidoItemMinAggregateOutputType | null
    _max: PedidoItemMaxAggregateOutputType | null
  }

  export type PedidoItemAvgAggregateOutputType = {
    pedido_id: number | null
    producto_id: number | null
    cantidad: number | null
    producto_personalizado_id: number | null
  }

  export type PedidoItemSumAggregateOutputType = {
    pedido_id: number | null
    producto_id: number | null
    cantidad: number | null
    producto_personalizado_id: number | null
  }

  export type PedidoItemMinAggregateOutputType = {
    pedido_id: number | null
    producto_id: number | null
    cantidad: number | null
    producto_personalizado_id: number | null
  }

  export type PedidoItemMaxAggregateOutputType = {
    pedido_id: number | null
    producto_id: number | null
    cantidad: number | null
    producto_personalizado_id: number | null
  }

  export type PedidoItemCountAggregateOutputType = {
    pedido_id: number
    producto_id: number
    cantidad: number
    producto_personalizado_id: number
    _all: number
  }


  export type PedidoItemAvgAggregateInputType = {
    pedido_id?: true
    producto_id?: true
    cantidad?: true
    producto_personalizado_id?: true
  }

  export type PedidoItemSumAggregateInputType = {
    pedido_id?: true
    producto_id?: true
    cantidad?: true
    producto_personalizado_id?: true
  }

  export type PedidoItemMinAggregateInputType = {
    pedido_id?: true
    producto_id?: true
    cantidad?: true
    producto_personalizado_id?: true
  }

  export type PedidoItemMaxAggregateInputType = {
    pedido_id?: true
    producto_id?: true
    cantidad?: true
    producto_personalizado_id?: true
  }

  export type PedidoItemCountAggregateInputType = {
    pedido_id?: true
    producto_id?: true
    cantidad?: true
    producto_personalizado_id?: true
    _all?: true
  }

  export type PedidoItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PedidoItem to aggregate.
     */
    where?: PedidoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoItems to fetch.
     */
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PedidoItems
    **/
    _count?: true | PedidoItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoItemMaxAggregateInputType
  }

  export type GetPedidoItemAggregateType<T extends PedidoItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePedidoItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedidoItem[P]>
      : GetScalarType<T[P], AggregatePedidoItem[P]>
  }




  export type PedidoItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoItemWhereInput
    orderBy?: PedidoItemOrderByWithAggregationInput | PedidoItemOrderByWithAggregationInput[]
    by: PedidoItemScalarFieldEnum[] | PedidoItemScalarFieldEnum
    having?: PedidoItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoItemCountAggregateInputType | true
    _avg?: PedidoItemAvgAggregateInputType
    _sum?: PedidoItemSumAggregateInputType
    _min?: PedidoItemMinAggregateInputType
    _max?: PedidoItemMaxAggregateInputType
  }

  export type PedidoItemGroupByOutputType = {
    pedido_id: number
    producto_id: number
    cantidad: number
    producto_personalizado_id: number | null
    _count: PedidoItemCountAggregateOutputType | null
    _avg: PedidoItemAvgAggregateOutputType | null
    _sum: PedidoItemSumAggregateOutputType | null
    _min: PedidoItemMinAggregateOutputType | null
    _max: PedidoItemMaxAggregateOutputType | null
  }

  type GetPedidoItemGroupByPayload<T extends PedidoItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PedidoItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoItemGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoItemGroupByOutputType[P]>
        }
      >
    >


  export type PedidoItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pedido_id?: boolean
    producto_id?: boolean
    cantidad?: boolean
    producto_personalizado_id?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
    producto_personalizado?: boolean | PedidoItem$producto_personalizadoArgs<ExtArgs>
  }, ExtArgs["result"]["pedidoItem"]>



  export type PedidoItemSelectScalar = {
    pedido_id?: boolean
    producto_id?: boolean
    cantidad?: boolean
    producto_personalizado_id?: boolean
  }

  export type PedidoItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pedido_id" | "producto_id" | "cantidad" | "producto_personalizado_id", ExtArgs["result"]["pedidoItem"]>
  export type PedidoItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    producto?: boolean | ProductoDefaultArgs<ExtArgs>
    producto_personalizado?: boolean | PedidoItem$producto_personalizadoArgs<ExtArgs>
  }

  export type $PedidoItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PedidoItem"
    objects: {
      pedido: Prisma.$PedidoPayload<ExtArgs>
      producto: Prisma.$ProductoPayload<ExtArgs>
      producto_personalizado: Prisma.$ProductoPersonalizablePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      pedido_id: number
      producto_id: number
      cantidad: number
      producto_personalizado_id: number | null
    }, ExtArgs["result"]["pedidoItem"]>
    composites: {}
  }

  type PedidoItemGetPayload<S extends boolean | null | undefined | PedidoItemDefaultArgs> = $Result.GetResult<Prisma.$PedidoItemPayload, S>

  type PedidoItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PedidoItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PedidoItemCountAggregateInputType | true
    }

  export interface PedidoItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PedidoItem'], meta: { name: 'PedidoItem' } }
    /**
     * Find zero or one PedidoItem that matches the filter.
     * @param {PedidoItemFindUniqueArgs} args - Arguments to find a PedidoItem
     * @example
     * // Get one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PedidoItemFindUniqueArgs>(args: SelectSubset<T, PedidoItemFindUniqueArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PedidoItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PedidoItemFindUniqueOrThrowArgs} args - Arguments to find a PedidoItem
     * @example
     * // Get one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PedidoItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PedidoItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PedidoItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemFindFirstArgs} args - Arguments to find a PedidoItem
     * @example
     * // Get one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PedidoItemFindFirstArgs>(args?: SelectSubset<T, PedidoItemFindFirstArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PedidoItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemFindFirstOrThrowArgs} args - Arguments to find a PedidoItem
     * @example
     * // Get one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PedidoItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PedidoItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PedidoItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PedidoItems
     * const pedidoItems = await prisma.pedidoItem.findMany()
     * 
     * // Get first 10 PedidoItems
     * const pedidoItems = await prisma.pedidoItem.findMany({ take: 10 })
     * 
     * // Only select the `pedido_id`
     * const pedidoItemWithPedido_idOnly = await prisma.pedidoItem.findMany({ select: { pedido_id: true } })
     * 
     */
    findMany<T extends PedidoItemFindManyArgs>(args?: SelectSubset<T, PedidoItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PedidoItem.
     * @param {PedidoItemCreateArgs} args - Arguments to create a PedidoItem.
     * @example
     * // Create one PedidoItem
     * const PedidoItem = await prisma.pedidoItem.create({
     *   data: {
     *     // ... data to create a PedidoItem
     *   }
     * })
     * 
     */
    create<T extends PedidoItemCreateArgs>(args: SelectSubset<T, PedidoItemCreateArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PedidoItems.
     * @param {PedidoItemCreateManyArgs} args - Arguments to create many PedidoItems.
     * @example
     * // Create many PedidoItems
     * const pedidoItem = await prisma.pedidoItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PedidoItemCreateManyArgs>(args?: SelectSubset<T, PedidoItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PedidoItem.
     * @param {PedidoItemDeleteArgs} args - Arguments to delete one PedidoItem.
     * @example
     * // Delete one PedidoItem
     * const PedidoItem = await prisma.pedidoItem.delete({
     *   where: {
     *     // ... filter to delete one PedidoItem
     *   }
     * })
     * 
     */
    delete<T extends PedidoItemDeleteArgs>(args: SelectSubset<T, PedidoItemDeleteArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PedidoItem.
     * @param {PedidoItemUpdateArgs} args - Arguments to update one PedidoItem.
     * @example
     * // Update one PedidoItem
     * const pedidoItem = await prisma.pedidoItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PedidoItemUpdateArgs>(args: SelectSubset<T, PedidoItemUpdateArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PedidoItems.
     * @param {PedidoItemDeleteManyArgs} args - Arguments to filter PedidoItems to delete.
     * @example
     * // Delete a few PedidoItems
     * const { count } = await prisma.pedidoItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PedidoItemDeleteManyArgs>(args?: SelectSubset<T, PedidoItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PedidoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PedidoItems
     * const pedidoItem = await prisma.pedidoItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PedidoItemUpdateManyArgs>(args: SelectSubset<T, PedidoItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PedidoItem.
     * @param {PedidoItemUpsertArgs} args - Arguments to update or create a PedidoItem.
     * @example
     * // Update or create a PedidoItem
     * const pedidoItem = await prisma.pedidoItem.upsert({
     *   create: {
     *     // ... data to create a PedidoItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PedidoItem we want to update
     *   }
     * })
     */
    upsert<T extends PedidoItemUpsertArgs>(args: SelectSubset<T, PedidoItemUpsertArgs<ExtArgs>>): Prisma__PedidoItemClient<$Result.GetResult<Prisma.$PedidoItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PedidoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemCountArgs} args - Arguments to filter PedidoItems to count.
     * @example
     * // Count the number of PedidoItems
     * const count = await prisma.pedidoItem.count({
     *   where: {
     *     // ... the filter for the PedidoItems we want to count
     *   }
     * })
    **/
    count<T extends PedidoItemCountArgs>(
      args?: Subset<T, PedidoItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PedidoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoItemAggregateArgs>(args: Subset<T, PedidoItemAggregateArgs>): Prisma.PrismaPromise<GetPedidoItemAggregateType<T>>

    /**
     * Group by PedidoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoItemGroupByArgs['orderBy'] }
        : { orderBy?: PedidoItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PedidoItem model
   */
  readonly fields: PedidoItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PedidoItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PedidoItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pedido<T extends PedidoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoDefaultArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    producto<T extends ProductoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductoDefaultArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    producto_personalizado<T extends PedidoItem$producto_personalizadoArgs<ExtArgs> = {}>(args?: Subset<T, PedidoItem$producto_personalizadoArgs<ExtArgs>>): Prisma__ProductoPersonalizableClient<$Result.GetResult<Prisma.$ProductoPersonalizablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PedidoItem model
   */
  interface PedidoItemFieldRefs {
    readonly pedido_id: FieldRef<"PedidoItem", 'Int'>
    readonly producto_id: FieldRef<"PedidoItem", 'Int'>
    readonly cantidad: FieldRef<"PedidoItem", 'Int'>
    readonly producto_personalizado_id: FieldRef<"PedidoItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PedidoItem findUnique
   */
  export type PedidoItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItem to fetch.
     */
    where: PedidoItemWhereUniqueInput
  }

  /**
   * PedidoItem findUniqueOrThrow
   */
  export type PedidoItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItem to fetch.
     */
    where: PedidoItemWhereUniqueInput
  }

  /**
   * PedidoItem findFirst
   */
  export type PedidoItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItem to fetch.
     */
    where?: PedidoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoItems to fetch.
     */
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoItems.
     */
    cursor?: PedidoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoItems.
     */
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * PedidoItem findFirstOrThrow
   */
  export type PedidoItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItem to fetch.
     */
    where?: PedidoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoItems to fetch.
     */
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoItems.
     */
    cursor?: PedidoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoItems.
     */
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * PedidoItem findMany
   */
  export type PedidoItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter, which PedidoItems to fetch.
     */
    where?: PedidoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoItems to fetch.
     */
    orderBy?: PedidoItemOrderByWithRelationInput | PedidoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PedidoItems.
     */
    cursor?: PedidoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoItems.
     */
    skip?: number
    distinct?: PedidoItemScalarFieldEnum | PedidoItemScalarFieldEnum[]
  }

  /**
   * PedidoItem create
   */
  export type PedidoItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PedidoItem.
     */
    data: XOR<PedidoItemCreateInput, PedidoItemUncheckedCreateInput>
  }

  /**
   * PedidoItem createMany
   */
  export type PedidoItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PedidoItems.
     */
    data: PedidoItemCreateManyInput | PedidoItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PedidoItem update
   */
  export type PedidoItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PedidoItem.
     */
    data: XOR<PedidoItemUpdateInput, PedidoItemUncheckedUpdateInput>
    /**
     * Choose, which PedidoItem to update.
     */
    where: PedidoItemWhereUniqueInput
  }

  /**
   * PedidoItem updateMany
   */
  export type PedidoItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PedidoItems.
     */
    data: XOR<PedidoItemUpdateManyMutationInput, PedidoItemUncheckedUpdateManyInput>
    /**
     * Filter which PedidoItems to update
     */
    where?: PedidoItemWhereInput
    /**
     * Limit how many PedidoItems to update.
     */
    limit?: number
  }

  /**
   * PedidoItem upsert
   */
  export type PedidoItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PedidoItem to update in case it exists.
     */
    where: PedidoItemWhereUniqueInput
    /**
     * In case the PedidoItem found by the `where` argument doesn't exist, create a new PedidoItem with this data.
     */
    create: XOR<PedidoItemCreateInput, PedidoItemUncheckedCreateInput>
    /**
     * In case the PedidoItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoItemUpdateInput, PedidoItemUncheckedUpdateInput>
  }

  /**
   * PedidoItem delete
   */
  export type PedidoItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
    /**
     * Filter which PedidoItem to delete.
     */
    where: PedidoItemWhereUniqueInput
  }

  /**
   * PedidoItem deleteMany
   */
  export type PedidoItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PedidoItems to delete
     */
    where?: PedidoItemWhereInput
    /**
     * Limit how many PedidoItems to delete.
     */
    limit?: number
  }

  /**
   * PedidoItem.producto_personalizado
   */
  export type PedidoItem$producto_personalizadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductoPersonalizable
     */
    select?: ProductoPersonalizableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductoPersonalizable
     */
    omit?: ProductoPersonalizableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoPersonalizableInclude<ExtArgs> | null
    where?: ProductoPersonalizableWhereInput
  }

  /**
   * PedidoItem without action
   */
  export type PedidoItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoItem
     */
    select?: PedidoItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoItem
     */
    omit?: PedidoItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoItemInclude<ExtArgs> | null
  }


  /**
   * Model TransicionEstadoPedido
   */

  export type AggregateTransicionEstadoPedido = {
    _count: TransicionEstadoPedidoCountAggregateOutputType | null
    _avg: TransicionEstadoPedidoAvgAggregateOutputType | null
    _sum: TransicionEstadoPedidoSumAggregateOutputType | null
    _min: TransicionEstadoPedidoMinAggregateOutputType | null
    _max: TransicionEstadoPedidoMaxAggregateOutputType | null
  }

  export type TransicionEstadoPedidoAvgAggregateOutputType = {
    id: number | null
    pedido_id: number | null
    admin_id: number | null
  }

  export type TransicionEstadoPedidoSumAggregateOutputType = {
    id: number | null
    pedido_id: number | null
    admin_id: number | null
  }

  export type TransicionEstadoPedidoMinAggregateOutputType = {
    id: number | null
    pedido_id: number | null
    estado: $Enums.EstadoPedido | null
    fecha_hora: Date | null
    admin_id: number | null
  }

  export type TransicionEstadoPedidoMaxAggregateOutputType = {
    id: number | null
    pedido_id: number | null
    estado: $Enums.EstadoPedido | null
    fecha_hora: Date | null
    admin_id: number | null
  }

  export type TransicionEstadoPedidoCountAggregateOutputType = {
    id: number
    pedido_id: number
    estado: number
    fecha_hora: number
    admin_id: number
    _all: number
  }


  export type TransicionEstadoPedidoAvgAggregateInputType = {
    id?: true
    pedido_id?: true
    admin_id?: true
  }

  export type TransicionEstadoPedidoSumAggregateInputType = {
    id?: true
    pedido_id?: true
    admin_id?: true
  }

  export type TransicionEstadoPedidoMinAggregateInputType = {
    id?: true
    pedido_id?: true
    estado?: true
    fecha_hora?: true
    admin_id?: true
  }

  export type TransicionEstadoPedidoMaxAggregateInputType = {
    id?: true
    pedido_id?: true
    estado?: true
    fecha_hora?: true
    admin_id?: true
  }

  export type TransicionEstadoPedidoCountAggregateInputType = {
    id?: true
    pedido_id?: true
    estado?: true
    fecha_hora?: true
    admin_id?: true
    _all?: true
  }

  export type TransicionEstadoPedidoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransicionEstadoPedido to aggregate.
     */
    where?: TransicionEstadoPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransicionEstadoPedidos to fetch.
     */
    orderBy?: TransicionEstadoPedidoOrderByWithRelationInput | TransicionEstadoPedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransicionEstadoPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransicionEstadoPedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransicionEstadoPedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransicionEstadoPedidos
    **/
    _count?: true | TransicionEstadoPedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransicionEstadoPedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransicionEstadoPedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransicionEstadoPedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransicionEstadoPedidoMaxAggregateInputType
  }

  export type GetTransicionEstadoPedidoAggregateType<T extends TransicionEstadoPedidoAggregateArgs> = {
        [P in keyof T & keyof AggregateTransicionEstadoPedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransicionEstadoPedido[P]>
      : GetScalarType<T[P], AggregateTransicionEstadoPedido[P]>
  }




  export type TransicionEstadoPedidoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransicionEstadoPedidoWhereInput
    orderBy?: TransicionEstadoPedidoOrderByWithAggregationInput | TransicionEstadoPedidoOrderByWithAggregationInput[]
    by: TransicionEstadoPedidoScalarFieldEnum[] | TransicionEstadoPedidoScalarFieldEnum
    having?: TransicionEstadoPedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransicionEstadoPedidoCountAggregateInputType | true
    _avg?: TransicionEstadoPedidoAvgAggregateInputType
    _sum?: TransicionEstadoPedidoSumAggregateInputType
    _min?: TransicionEstadoPedidoMinAggregateInputType
    _max?: TransicionEstadoPedidoMaxAggregateInputType
  }

  export type TransicionEstadoPedidoGroupByOutputType = {
    id: number
    pedido_id: number
    estado: $Enums.EstadoPedido
    fecha_hora: Date
    admin_id: number
    _count: TransicionEstadoPedidoCountAggregateOutputType | null
    _avg: TransicionEstadoPedidoAvgAggregateOutputType | null
    _sum: TransicionEstadoPedidoSumAggregateOutputType | null
    _min: TransicionEstadoPedidoMinAggregateOutputType | null
    _max: TransicionEstadoPedidoMaxAggregateOutputType | null
  }

  type GetTransicionEstadoPedidoGroupByPayload<T extends TransicionEstadoPedidoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransicionEstadoPedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransicionEstadoPedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransicionEstadoPedidoGroupByOutputType[P]>
            : GetScalarType<T[P], TransicionEstadoPedidoGroupByOutputType[P]>
        }
      >
    >


  export type TransicionEstadoPedidoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedido_id?: boolean
    estado?: boolean
    fecha_hora?: boolean
    admin_id?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    admin?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transicionEstadoPedido"]>



  export type TransicionEstadoPedidoSelectScalar = {
    id?: boolean
    pedido_id?: boolean
    estado?: boolean
    fecha_hora?: boolean
    admin_id?: boolean
  }

  export type TransicionEstadoPedidoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pedido_id" | "estado" | "fecha_hora" | "admin_id", ExtArgs["result"]["transicionEstadoPedido"]>
  export type TransicionEstadoPedidoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    admin?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $TransicionEstadoPedidoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransicionEstadoPedido"
    objects: {
      pedido: Prisma.$PedidoPayload<ExtArgs>
      admin: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pedido_id: number
      estado: $Enums.EstadoPedido
      fecha_hora: Date
      admin_id: number
    }, ExtArgs["result"]["transicionEstadoPedido"]>
    composites: {}
  }

  type TransicionEstadoPedidoGetPayload<S extends boolean | null | undefined | TransicionEstadoPedidoDefaultArgs> = $Result.GetResult<Prisma.$TransicionEstadoPedidoPayload, S>

  type TransicionEstadoPedidoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransicionEstadoPedidoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransicionEstadoPedidoCountAggregateInputType | true
    }

  export interface TransicionEstadoPedidoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransicionEstadoPedido'], meta: { name: 'TransicionEstadoPedido' } }
    /**
     * Find zero or one TransicionEstadoPedido that matches the filter.
     * @param {TransicionEstadoPedidoFindUniqueArgs} args - Arguments to find a TransicionEstadoPedido
     * @example
     * // Get one TransicionEstadoPedido
     * const transicionEstadoPedido = await prisma.transicionEstadoPedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransicionEstadoPedidoFindUniqueArgs>(args: SelectSubset<T, TransicionEstadoPedidoFindUniqueArgs<ExtArgs>>): Prisma__TransicionEstadoPedidoClient<$Result.GetResult<Prisma.$TransicionEstadoPedidoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransicionEstadoPedido that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransicionEstadoPedidoFindUniqueOrThrowArgs} args - Arguments to find a TransicionEstadoPedido
     * @example
     * // Get one TransicionEstadoPedido
     * const transicionEstadoPedido = await prisma.transicionEstadoPedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransicionEstadoPedidoFindUniqueOrThrowArgs>(args: SelectSubset<T, TransicionEstadoPedidoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransicionEstadoPedidoClient<$Result.GetResult<Prisma.$TransicionEstadoPedidoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransicionEstadoPedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransicionEstadoPedidoFindFirstArgs} args - Arguments to find a TransicionEstadoPedido
     * @example
     * // Get one TransicionEstadoPedido
     * const transicionEstadoPedido = await prisma.transicionEstadoPedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransicionEstadoPedidoFindFirstArgs>(args?: SelectSubset<T, TransicionEstadoPedidoFindFirstArgs<ExtArgs>>): Prisma__TransicionEstadoPedidoClient<$Result.GetResult<Prisma.$TransicionEstadoPedidoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransicionEstadoPedido that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransicionEstadoPedidoFindFirstOrThrowArgs} args - Arguments to find a TransicionEstadoPedido
     * @example
     * // Get one TransicionEstadoPedido
     * const transicionEstadoPedido = await prisma.transicionEstadoPedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransicionEstadoPedidoFindFirstOrThrowArgs>(args?: SelectSubset<T, TransicionEstadoPedidoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransicionEstadoPedidoClient<$Result.GetResult<Prisma.$TransicionEstadoPedidoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransicionEstadoPedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransicionEstadoPedidoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransicionEstadoPedidos
     * const transicionEstadoPedidos = await prisma.transicionEstadoPedido.findMany()
     * 
     * // Get first 10 TransicionEstadoPedidos
     * const transicionEstadoPedidos = await prisma.transicionEstadoPedido.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transicionEstadoPedidoWithIdOnly = await prisma.transicionEstadoPedido.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransicionEstadoPedidoFindManyArgs>(args?: SelectSubset<T, TransicionEstadoPedidoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransicionEstadoPedidoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransicionEstadoPedido.
     * @param {TransicionEstadoPedidoCreateArgs} args - Arguments to create a TransicionEstadoPedido.
     * @example
     * // Create one TransicionEstadoPedido
     * const TransicionEstadoPedido = await prisma.transicionEstadoPedido.create({
     *   data: {
     *     // ... data to create a TransicionEstadoPedido
     *   }
     * })
     * 
     */
    create<T extends TransicionEstadoPedidoCreateArgs>(args: SelectSubset<T, TransicionEstadoPedidoCreateArgs<ExtArgs>>): Prisma__TransicionEstadoPedidoClient<$Result.GetResult<Prisma.$TransicionEstadoPedidoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransicionEstadoPedidos.
     * @param {TransicionEstadoPedidoCreateManyArgs} args - Arguments to create many TransicionEstadoPedidos.
     * @example
     * // Create many TransicionEstadoPedidos
     * const transicionEstadoPedido = await prisma.transicionEstadoPedido.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransicionEstadoPedidoCreateManyArgs>(args?: SelectSubset<T, TransicionEstadoPedidoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TransicionEstadoPedido.
     * @param {TransicionEstadoPedidoDeleteArgs} args - Arguments to delete one TransicionEstadoPedido.
     * @example
     * // Delete one TransicionEstadoPedido
     * const TransicionEstadoPedido = await prisma.transicionEstadoPedido.delete({
     *   where: {
     *     // ... filter to delete one TransicionEstadoPedido
     *   }
     * })
     * 
     */
    delete<T extends TransicionEstadoPedidoDeleteArgs>(args: SelectSubset<T, TransicionEstadoPedidoDeleteArgs<ExtArgs>>): Prisma__TransicionEstadoPedidoClient<$Result.GetResult<Prisma.$TransicionEstadoPedidoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransicionEstadoPedido.
     * @param {TransicionEstadoPedidoUpdateArgs} args - Arguments to update one TransicionEstadoPedido.
     * @example
     * // Update one TransicionEstadoPedido
     * const transicionEstadoPedido = await prisma.transicionEstadoPedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransicionEstadoPedidoUpdateArgs>(args: SelectSubset<T, TransicionEstadoPedidoUpdateArgs<ExtArgs>>): Prisma__TransicionEstadoPedidoClient<$Result.GetResult<Prisma.$TransicionEstadoPedidoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransicionEstadoPedidos.
     * @param {TransicionEstadoPedidoDeleteManyArgs} args - Arguments to filter TransicionEstadoPedidos to delete.
     * @example
     * // Delete a few TransicionEstadoPedidos
     * const { count } = await prisma.transicionEstadoPedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransicionEstadoPedidoDeleteManyArgs>(args?: SelectSubset<T, TransicionEstadoPedidoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransicionEstadoPedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransicionEstadoPedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransicionEstadoPedidos
     * const transicionEstadoPedido = await prisma.transicionEstadoPedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransicionEstadoPedidoUpdateManyArgs>(args: SelectSubset<T, TransicionEstadoPedidoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransicionEstadoPedido.
     * @param {TransicionEstadoPedidoUpsertArgs} args - Arguments to update or create a TransicionEstadoPedido.
     * @example
     * // Update or create a TransicionEstadoPedido
     * const transicionEstadoPedido = await prisma.transicionEstadoPedido.upsert({
     *   create: {
     *     // ... data to create a TransicionEstadoPedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransicionEstadoPedido we want to update
     *   }
     * })
     */
    upsert<T extends TransicionEstadoPedidoUpsertArgs>(args: SelectSubset<T, TransicionEstadoPedidoUpsertArgs<ExtArgs>>): Prisma__TransicionEstadoPedidoClient<$Result.GetResult<Prisma.$TransicionEstadoPedidoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransicionEstadoPedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransicionEstadoPedidoCountArgs} args - Arguments to filter TransicionEstadoPedidos to count.
     * @example
     * // Count the number of TransicionEstadoPedidos
     * const count = await prisma.transicionEstadoPedido.count({
     *   where: {
     *     // ... the filter for the TransicionEstadoPedidos we want to count
     *   }
     * })
    **/
    count<T extends TransicionEstadoPedidoCountArgs>(
      args?: Subset<T, TransicionEstadoPedidoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransicionEstadoPedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransicionEstadoPedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransicionEstadoPedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransicionEstadoPedidoAggregateArgs>(args: Subset<T, TransicionEstadoPedidoAggregateArgs>): Prisma.PrismaPromise<GetTransicionEstadoPedidoAggregateType<T>>

    /**
     * Group by TransicionEstadoPedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransicionEstadoPedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransicionEstadoPedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransicionEstadoPedidoGroupByArgs['orderBy'] }
        : { orderBy?: TransicionEstadoPedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransicionEstadoPedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransicionEstadoPedidoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransicionEstadoPedido model
   */
  readonly fields: TransicionEstadoPedidoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransicionEstadoPedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransicionEstadoPedidoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pedido<T extends PedidoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoDefaultArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    admin<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransicionEstadoPedido model
   */
  interface TransicionEstadoPedidoFieldRefs {
    readonly id: FieldRef<"TransicionEstadoPedido", 'Int'>
    readonly pedido_id: FieldRef<"TransicionEstadoPedido", 'Int'>
    readonly estado: FieldRef<"TransicionEstadoPedido", 'EstadoPedido'>
    readonly fecha_hora: FieldRef<"TransicionEstadoPedido", 'DateTime'>
    readonly admin_id: FieldRef<"TransicionEstadoPedido", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TransicionEstadoPedido findUnique
   */
  export type TransicionEstadoPedidoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransicionEstadoPedido
     */
    select?: TransicionEstadoPedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransicionEstadoPedido
     */
    omit?: TransicionEstadoPedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransicionEstadoPedidoInclude<ExtArgs> | null
    /**
     * Filter, which TransicionEstadoPedido to fetch.
     */
    where: TransicionEstadoPedidoWhereUniqueInput
  }

  /**
   * TransicionEstadoPedido findUniqueOrThrow
   */
  export type TransicionEstadoPedidoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransicionEstadoPedido
     */
    select?: TransicionEstadoPedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransicionEstadoPedido
     */
    omit?: TransicionEstadoPedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransicionEstadoPedidoInclude<ExtArgs> | null
    /**
     * Filter, which TransicionEstadoPedido to fetch.
     */
    where: TransicionEstadoPedidoWhereUniqueInput
  }

  /**
   * TransicionEstadoPedido findFirst
   */
  export type TransicionEstadoPedidoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransicionEstadoPedido
     */
    select?: TransicionEstadoPedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransicionEstadoPedido
     */
    omit?: TransicionEstadoPedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransicionEstadoPedidoInclude<ExtArgs> | null
    /**
     * Filter, which TransicionEstadoPedido to fetch.
     */
    where?: TransicionEstadoPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransicionEstadoPedidos to fetch.
     */
    orderBy?: TransicionEstadoPedidoOrderByWithRelationInput | TransicionEstadoPedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransicionEstadoPedidos.
     */
    cursor?: TransicionEstadoPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransicionEstadoPedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransicionEstadoPedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransicionEstadoPedidos.
     */
    distinct?: TransicionEstadoPedidoScalarFieldEnum | TransicionEstadoPedidoScalarFieldEnum[]
  }

  /**
   * TransicionEstadoPedido findFirstOrThrow
   */
  export type TransicionEstadoPedidoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransicionEstadoPedido
     */
    select?: TransicionEstadoPedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransicionEstadoPedido
     */
    omit?: TransicionEstadoPedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransicionEstadoPedidoInclude<ExtArgs> | null
    /**
     * Filter, which TransicionEstadoPedido to fetch.
     */
    where?: TransicionEstadoPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransicionEstadoPedidos to fetch.
     */
    orderBy?: TransicionEstadoPedidoOrderByWithRelationInput | TransicionEstadoPedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransicionEstadoPedidos.
     */
    cursor?: TransicionEstadoPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransicionEstadoPedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransicionEstadoPedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransicionEstadoPedidos.
     */
    distinct?: TransicionEstadoPedidoScalarFieldEnum | TransicionEstadoPedidoScalarFieldEnum[]
  }

  /**
   * TransicionEstadoPedido findMany
   */
  export type TransicionEstadoPedidoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransicionEstadoPedido
     */
    select?: TransicionEstadoPedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransicionEstadoPedido
     */
    omit?: TransicionEstadoPedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransicionEstadoPedidoInclude<ExtArgs> | null
    /**
     * Filter, which TransicionEstadoPedidos to fetch.
     */
    where?: TransicionEstadoPedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransicionEstadoPedidos to fetch.
     */
    orderBy?: TransicionEstadoPedidoOrderByWithRelationInput | TransicionEstadoPedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransicionEstadoPedidos.
     */
    cursor?: TransicionEstadoPedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransicionEstadoPedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransicionEstadoPedidos.
     */
    skip?: number
    distinct?: TransicionEstadoPedidoScalarFieldEnum | TransicionEstadoPedidoScalarFieldEnum[]
  }

  /**
   * TransicionEstadoPedido create
   */
  export type TransicionEstadoPedidoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransicionEstadoPedido
     */
    select?: TransicionEstadoPedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransicionEstadoPedido
     */
    omit?: TransicionEstadoPedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransicionEstadoPedidoInclude<ExtArgs> | null
    /**
     * The data needed to create a TransicionEstadoPedido.
     */
    data: XOR<TransicionEstadoPedidoCreateInput, TransicionEstadoPedidoUncheckedCreateInput>
  }

  /**
   * TransicionEstadoPedido createMany
   */
  export type TransicionEstadoPedidoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransicionEstadoPedidos.
     */
    data: TransicionEstadoPedidoCreateManyInput | TransicionEstadoPedidoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransicionEstadoPedido update
   */
  export type TransicionEstadoPedidoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransicionEstadoPedido
     */
    select?: TransicionEstadoPedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransicionEstadoPedido
     */
    omit?: TransicionEstadoPedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransicionEstadoPedidoInclude<ExtArgs> | null
    /**
     * The data needed to update a TransicionEstadoPedido.
     */
    data: XOR<TransicionEstadoPedidoUpdateInput, TransicionEstadoPedidoUncheckedUpdateInput>
    /**
     * Choose, which TransicionEstadoPedido to update.
     */
    where: TransicionEstadoPedidoWhereUniqueInput
  }

  /**
   * TransicionEstadoPedido updateMany
   */
  export type TransicionEstadoPedidoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransicionEstadoPedidos.
     */
    data: XOR<TransicionEstadoPedidoUpdateManyMutationInput, TransicionEstadoPedidoUncheckedUpdateManyInput>
    /**
     * Filter which TransicionEstadoPedidos to update
     */
    where?: TransicionEstadoPedidoWhereInput
    /**
     * Limit how many TransicionEstadoPedidos to update.
     */
    limit?: number
  }

  /**
   * TransicionEstadoPedido upsert
   */
  export type TransicionEstadoPedidoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransicionEstadoPedido
     */
    select?: TransicionEstadoPedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransicionEstadoPedido
     */
    omit?: TransicionEstadoPedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransicionEstadoPedidoInclude<ExtArgs> | null
    /**
     * The filter to search for the TransicionEstadoPedido to update in case it exists.
     */
    where: TransicionEstadoPedidoWhereUniqueInput
    /**
     * In case the TransicionEstadoPedido found by the `where` argument doesn't exist, create a new TransicionEstadoPedido with this data.
     */
    create: XOR<TransicionEstadoPedidoCreateInput, TransicionEstadoPedidoUncheckedCreateInput>
    /**
     * In case the TransicionEstadoPedido was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransicionEstadoPedidoUpdateInput, TransicionEstadoPedidoUncheckedUpdateInput>
  }

  /**
   * TransicionEstadoPedido delete
   */
  export type TransicionEstadoPedidoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransicionEstadoPedido
     */
    select?: TransicionEstadoPedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransicionEstadoPedido
     */
    omit?: TransicionEstadoPedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransicionEstadoPedidoInclude<ExtArgs> | null
    /**
     * Filter which TransicionEstadoPedido to delete.
     */
    where: TransicionEstadoPedidoWhereUniqueInput
  }

  /**
   * TransicionEstadoPedido deleteMany
   */
  export type TransicionEstadoPedidoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransicionEstadoPedidos to delete
     */
    where?: TransicionEstadoPedidoWhereInput
    /**
     * Limit how many TransicionEstadoPedidos to delete.
     */
    limit?: number
  }

  /**
   * TransicionEstadoPedido without action
   */
  export type TransicionEstadoPedidoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransicionEstadoPedido
     */
    select?: TransicionEstadoPedidoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransicionEstadoPedido
     */
    omit?: TransicionEstadoPedidoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransicionEstadoPedidoInclude<ExtArgs> | null
  }


  /**
   * Model ReporteResena
   */

  export type AggregateReporteResena = {
    _count: ReporteResenaCountAggregateOutputType | null
    _avg: ReporteResenaAvgAggregateOutputType | null
    _sum: ReporteResenaSumAggregateOutputType | null
    _min: ReporteResenaMinAggregateOutputType | null
    _max: ReporteResenaMaxAggregateOutputType | null
  }

  export type ReporteResenaAvgAggregateOutputType = {
    id: number | null
    resena_id: number | null
    usuario_id: number | null
  }

  export type ReporteResenaSumAggregateOutputType = {
    id: number | null
    resena_id: number | null
    usuario_id: number | null
  }

  export type ReporteResenaMinAggregateOutputType = {
    id: number | null
    resena_id: number | null
    usuario_id: number | null
    comentario: string | null
  }

  export type ReporteResenaMaxAggregateOutputType = {
    id: number | null
    resena_id: number | null
    usuario_id: number | null
    comentario: string | null
  }

  export type ReporteResenaCountAggregateOutputType = {
    id: number
    resena_id: number
    usuario_id: number
    comentario: number
    _all: number
  }


  export type ReporteResenaAvgAggregateInputType = {
    id?: true
    resena_id?: true
    usuario_id?: true
  }

  export type ReporteResenaSumAggregateInputType = {
    id?: true
    resena_id?: true
    usuario_id?: true
  }

  export type ReporteResenaMinAggregateInputType = {
    id?: true
    resena_id?: true
    usuario_id?: true
    comentario?: true
  }

  export type ReporteResenaMaxAggregateInputType = {
    id?: true
    resena_id?: true
    usuario_id?: true
    comentario?: true
  }

  export type ReporteResenaCountAggregateInputType = {
    id?: true
    resena_id?: true
    usuario_id?: true
    comentario?: true
    _all?: true
  }

  export type ReporteResenaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReporteResena to aggregate.
     */
    where?: ReporteResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReporteResenas to fetch.
     */
    orderBy?: ReporteResenaOrderByWithRelationInput | ReporteResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReporteResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReporteResenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReporteResenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReporteResenas
    **/
    _count?: true | ReporteResenaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReporteResenaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReporteResenaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReporteResenaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReporteResenaMaxAggregateInputType
  }

  export type GetReporteResenaAggregateType<T extends ReporteResenaAggregateArgs> = {
        [P in keyof T & keyof AggregateReporteResena]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReporteResena[P]>
      : GetScalarType<T[P], AggregateReporteResena[P]>
  }




  export type ReporteResenaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReporteResenaWhereInput
    orderBy?: ReporteResenaOrderByWithAggregationInput | ReporteResenaOrderByWithAggregationInput[]
    by: ReporteResenaScalarFieldEnum[] | ReporteResenaScalarFieldEnum
    having?: ReporteResenaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReporteResenaCountAggregateInputType | true
    _avg?: ReporteResenaAvgAggregateInputType
    _sum?: ReporteResenaSumAggregateInputType
    _min?: ReporteResenaMinAggregateInputType
    _max?: ReporteResenaMaxAggregateInputType
  }

  export type ReporteResenaGroupByOutputType = {
    id: number
    resena_id: number
    usuario_id: number
    comentario: string
    _count: ReporteResenaCountAggregateOutputType | null
    _avg: ReporteResenaAvgAggregateOutputType | null
    _sum: ReporteResenaSumAggregateOutputType | null
    _min: ReporteResenaMinAggregateOutputType | null
    _max: ReporteResenaMaxAggregateOutputType | null
  }

  type GetReporteResenaGroupByPayload<T extends ReporteResenaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReporteResenaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReporteResenaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReporteResenaGroupByOutputType[P]>
            : GetScalarType<T[P], ReporteResenaGroupByOutputType[P]>
        }
      >
    >


  export type ReporteResenaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resena_id?: boolean
    usuario_id?: boolean
    comentario?: boolean
    resena?: boolean | ResenaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reporteResena"]>



  export type ReporteResenaSelectScalar = {
    id?: boolean
    resena_id?: boolean
    usuario_id?: boolean
    comentario?: boolean
  }

  export type ReporteResenaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resena_id" | "usuario_id" | "comentario", ExtArgs["result"]["reporteResena"]>
  export type ReporteResenaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resena?: boolean | ResenaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ReporteResenaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReporteResena"
    objects: {
      resena: Prisma.$ResenaPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      resena_id: number
      usuario_id: number
      comentario: string
    }, ExtArgs["result"]["reporteResena"]>
    composites: {}
  }

  type ReporteResenaGetPayload<S extends boolean | null | undefined | ReporteResenaDefaultArgs> = $Result.GetResult<Prisma.$ReporteResenaPayload, S>

  type ReporteResenaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReporteResenaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReporteResenaCountAggregateInputType | true
    }

  export interface ReporteResenaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReporteResena'], meta: { name: 'ReporteResena' } }
    /**
     * Find zero or one ReporteResena that matches the filter.
     * @param {ReporteResenaFindUniqueArgs} args - Arguments to find a ReporteResena
     * @example
     * // Get one ReporteResena
     * const reporteResena = await prisma.reporteResena.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReporteResenaFindUniqueArgs>(args: SelectSubset<T, ReporteResenaFindUniqueArgs<ExtArgs>>): Prisma__ReporteResenaClient<$Result.GetResult<Prisma.$ReporteResenaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReporteResena that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReporteResenaFindUniqueOrThrowArgs} args - Arguments to find a ReporteResena
     * @example
     * // Get one ReporteResena
     * const reporteResena = await prisma.reporteResena.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReporteResenaFindUniqueOrThrowArgs>(args: SelectSubset<T, ReporteResenaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReporteResenaClient<$Result.GetResult<Prisma.$ReporteResenaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReporteResena that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteResenaFindFirstArgs} args - Arguments to find a ReporteResena
     * @example
     * // Get one ReporteResena
     * const reporteResena = await prisma.reporteResena.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReporteResenaFindFirstArgs>(args?: SelectSubset<T, ReporteResenaFindFirstArgs<ExtArgs>>): Prisma__ReporteResenaClient<$Result.GetResult<Prisma.$ReporteResenaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReporteResena that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteResenaFindFirstOrThrowArgs} args - Arguments to find a ReporteResena
     * @example
     * // Get one ReporteResena
     * const reporteResena = await prisma.reporteResena.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReporteResenaFindFirstOrThrowArgs>(args?: SelectSubset<T, ReporteResenaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReporteResenaClient<$Result.GetResult<Prisma.$ReporteResenaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReporteResenas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteResenaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReporteResenas
     * const reporteResenas = await prisma.reporteResena.findMany()
     * 
     * // Get first 10 ReporteResenas
     * const reporteResenas = await prisma.reporteResena.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reporteResenaWithIdOnly = await prisma.reporteResena.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReporteResenaFindManyArgs>(args?: SelectSubset<T, ReporteResenaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReporteResenaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReporteResena.
     * @param {ReporteResenaCreateArgs} args - Arguments to create a ReporteResena.
     * @example
     * // Create one ReporteResena
     * const ReporteResena = await prisma.reporteResena.create({
     *   data: {
     *     // ... data to create a ReporteResena
     *   }
     * })
     * 
     */
    create<T extends ReporteResenaCreateArgs>(args: SelectSubset<T, ReporteResenaCreateArgs<ExtArgs>>): Prisma__ReporteResenaClient<$Result.GetResult<Prisma.$ReporteResenaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReporteResenas.
     * @param {ReporteResenaCreateManyArgs} args - Arguments to create many ReporteResenas.
     * @example
     * // Create many ReporteResenas
     * const reporteResena = await prisma.reporteResena.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReporteResenaCreateManyArgs>(args?: SelectSubset<T, ReporteResenaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReporteResena.
     * @param {ReporteResenaDeleteArgs} args - Arguments to delete one ReporteResena.
     * @example
     * // Delete one ReporteResena
     * const ReporteResena = await prisma.reporteResena.delete({
     *   where: {
     *     // ... filter to delete one ReporteResena
     *   }
     * })
     * 
     */
    delete<T extends ReporteResenaDeleteArgs>(args: SelectSubset<T, ReporteResenaDeleteArgs<ExtArgs>>): Prisma__ReporteResenaClient<$Result.GetResult<Prisma.$ReporteResenaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReporteResena.
     * @param {ReporteResenaUpdateArgs} args - Arguments to update one ReporteResena.
     * @example
     * // Update one ReporteResena
     * const reporteResena = await prisma.reporteResena.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReporteResenaUpdateArgs>(args: SelectSubset<T, ReporteResenaUpdateArgs<ExtArgs>>): Prisma__ReporteResenaClient<$Result.GetResult<Prisma.$ReporteResenaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReporteResenas.
     * @param {ReporteResenaDeleteManyArgs} args - Arguments to filter ReporteResenas to delete.
     * @example
     * // Delete a few ReporteResenas
     * const { count } = await prisma.reporteResena.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReporteResenaDeleteManyArgs>(args?: SelectSubset<T, ReporteResenaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReporteResenas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteResenaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReporteResenas
     * const reporteResena = await prisma.reporteResena.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReporteResenaUpdateManyArgs>(args: SelectSubset<T, ReporteResenaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReporteResena.
     * @param {ReporteResenaUpsertArgs} args - Arguments to update or create a ReporteResena.
     * @example
     * // Update or create a ReporteResena
     * const reporteResena = await prisma.reporteResena.upsert({
     *   create: {
     *     // ... data to create a ReporteResena
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReporteResena we want to update
     *   }
     * })
     */
    upsert<T extends ReporteResenaUpsertArgs>(args: SelectSubset<T, ReporteResenaUpsertArgs<ExtArgs>>): Prisma__ReporteResenaClient<$Result.GetResult<Prisma.$ReporteResenaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReporteResenas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteResenaCountArgs} args - Arguments to filter ReporteResenas to count.
     * @example
     * // Count the number of ReporteResenas
     * const count = await prisma.reporteResena.count({
     *   where: {
     *     // ... the filter for the ReporteResenas we want to count
     *   }
     * })
    **/
    count<T extends ReporteResenaCountArgs>(
      args?: Subset<T, ReporteResenaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReporteResenaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReporteResena.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteResenaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReporteResenaAggregateArgs>(args: Subset<T, ReporteResenaAggregateArgs>): Prisma.PrismaPromise<GetReporteResenaAggregateType<T>>

    /**
     * Group by ReporteResena.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReporteResenaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReporteResenaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReporteResenaGroupByArgs['orderBy'] }
        : { orderBy?: ReporteResenaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReporteResenaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReporteResenaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReporteResena model
   */
  readonly fields: ReporteResenaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReporteResena.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReporteResenaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resena<T extends ResenaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResenaDefaultArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReporteResena model
   */
  interface ReporteResenaFieldRefs {
    readonly id: FieldRef<"ReporteResena", 'Int'>
    readonly resena_id: FieldRef<"ReporteResena", 'Int'>
    readonly usuario_id: FieldRef<"ReporteResena", 'Int'>
    readonly comentario: FieldRef<"ReporteResena", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReporteResena findUnique
   */
  export type ReporteResenaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReporteResena
     */
    select?: ReporteResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReporteResena
     */
    omit?: ReporteResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteResenaInclude<ExtArgs> | null
    /**
     * Filter, which ReporteResena to fetch.
     */
    where: ReporteResenaWhereUniqueInput
  }

  /**
   * ReporteResena findUniqueOrThrow
   */
  export type ReporteResenaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReporteResena
     */
    select?: ReporteResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReporteResena
     */
    omit?: ReporteResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteResenaInclude<ExtArgs> | null
    /**
     * Filter, which ReporteResena to fetch.
     */
    where: ReporteResenaWhereUniqueInput
  }

  /**
   * ReporteResena findFirst
   */
  export type ReporteResenaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReporteResena
     */
    select?: ReporteResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReporteResena
     */
    omit?: ReporteResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteResenaInclude<ExtArgs> | null
    /**
     * Filter, which ReporteResena to fetch.
     */
    where?: ReporteResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReporteResenas to fetch.
     */
    orderBy?: ReporteResenaOrderByWithRelationInput | ReporteResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReporteResenas.
     */
    cursor?: ReporteResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReporteResenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReporteResenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReporteResenas.
     */
    distinct?: ReporteResenaScalarFieldEnum | ReporteResenaScalarFieldEnum[]
  }

  /**
   * ReporteResena findFirstOrThrow
   */
  export type ReporteResenaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReporteResena
     */
    select?: ReporteResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReporteResena
     */
    omit?: ReporteResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteResenaInclude<ExtArgs> | null
    /**
     * Filter, which ReporteResena to fetch.
     */
    where?: ReporteResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReporteResenas to fetch.
     */
    orderBy?: ReporteResenaOrderByWithRelationInput | ReporteResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReporteResenas.
     */
    cursor?: ReporteResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReporteResenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReporteResenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReporteResenas.
     */
    distinct?: ReporteResenaScalarFieldEnum | ReporteResenaScalarFieldEnum[]
  }

  /**
   * ReporteResena findMany
   */
  export type ReporteResenaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReporteResena
     */
    select?: ReporteResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReporteResena
     */
    omit?: ReporteResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteResenaInclude<ExtArgs> | null
    /**
     * Filter, which ReporteResenas to fetch.
     */
    where?: ReporteResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReporteResenas to fetch.
     */
    orderBy?: ReporteResenaOrderByWithRelationInput | ReporteResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReporteResenas.
     */
    cursor?: ReporteResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReporteResenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReporteResenas.
     */
    skip?: number
    distinct?: ReporteResenaScalarFieldEnum | ReporteResenaScalarFieldEnum[]
  }

  /**
   * ReporteResena create
   */
  export type ReporteResenaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReporteResena
     */
    select?: ReporteResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReporteResena
     */
    omit?: ReporteResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteResenaInclude<ExtArgs> | null
    /**
     * The data needed to create a ReporteResena.
     */
    data: XOR<ReporteResenaCreateInput, ReporteResenaUncheckedCreateInput>
  }

  /**
   * ReporteResena createMany
   */
  export type ReporteResenaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReporteResenas.
     */
    data: ReporteResenaCreateManyInput | ReporteResenaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReporteResena update
   */
  export type ReporteResenaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReporteResena
     */
    select?: ReporteResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReporteResena
     */
    omit?: ReporteResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteResenaInclude<ExtArgs> | null
    /**
     * The data needed to update a ReporteResena.
     */
    data: XOR<ReporteResenaUpdateInput, ReporteResenaUncheckedUpdateInput>
    /**
     * Choose, which ReporteResena to update.
     */
    where: ReporteResenaWhereUniqueInput
  }

  /**
   * ReporteResena updateMany
   */
  export type ReporteResenaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReporteResenas.
     */
    data: XOR<ReporteResenaUpdateManyMutationInput, ReporteResenaUncheckedUpdateManyInput>
    /**
     * Filter which ReporteResenas to update
     */
    where?: ReporteResenaWhereInput
    /**
     * Limit how many ReporteResenas to update.
     */
    limit?: number
  }

  /**
   * ReporteResena upsert
   */
  export type ReporteResenaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReporteResena
     */
    select?: ReporteResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReporteResena
     */
    omit?: ReporteResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteResenaInclude<ExtArgs> | null
    /**
     * The filter to search for the ReporteResena to update in case it exists.
     */
    where: ReporteResenaWhereUniqueInput
    /**
     * In case the ReporteResena found by the `where` argument doesn't exist, create a new ReporteResena with this data.
     */
    create: XOR<ReporteResenaCreateInput, ReporteResenaUncheckedCreateInput>
    /**
     * In case the ReporteResena was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReporteResenaUpdateInput, ReporteResenaUncheckedUpdateInput>
  }

  /**
   * ReporteResena delete
   */
  export type ReporteResenaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReporteResena
     */
    select?: ReporteResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReporteResena
     */
    omit?: ReporteResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteResenaInclude<ExtArgs> | null
    /**
     * Filter which ReporteResena to delete.
     */
    where: ReporteResenaWhereUniqueInput
  }

  /**
   * ReporteResena deleteMany
   */
  export type ReporteResenaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReporteResenas to delete
     */
    where?: ReporteResenaWhereInput
    /**
     * Limit how many ReporteResenas to delete.
     */
    limit?: number
  }

  /**
   * ReporteResena without action
   */
  export type ReporteResenaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReporteResena
     */
    select?: ReporteResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReporteResena
     */
    omit?: ReporteResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReporteResenaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre_usuario: 'nombre_usuario',
    correo: 'correo',
    contraseña: 'contraseña',
    rol: 'rol',
    ultimo_inicio_sesion: 'ultimo_inicio_sesion'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const CategoriaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type CategoriaScalarFieldEnum = (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum]


  export const EtiquetaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type EtiquetaScalarFieldEnum = (typeof EtiquetaScalarFieldEnum)[keyof typeof EtiquetaScalarFieldEnum]


  export const ProductoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    precio_base: 'precio_base',
    stock: 'stock',
    categoria_id: 'categoria_id',
    promedio_valoracion: 'promedio_valoracion',
    activo: 'activo'
  };

  export type ProductoScalarFieldEnum = (typeof ProductoScalarFieldEnum)[keyof typeof ProductoScalarFieldEnum]


  export const ImagenProductoScalarFieldEnum: {
    id: 'id',
    producto_id: 'producto_id',
    url: 'url'
  };

  export type ImagenProductoScalarFieldEnum = (typeof ImagenProductoScalarFieldEnum)[keyof typeof ImagenProductoScalarFieldEnum]


  export const ProductoEtiquetaScalarFieldEnum: {
    producto_id: 'producto_id',
    etiqueta_id: 'etiqueta_id'
  };

  export type ProductoEtiquetaScalarFieldEnum = (typeof ProductoEtiquetaScalarFieldEnum)[keyof typeof ProductoEtiquetaScalarFieldEnum]


  export const ResenaScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    producto_id: 'producto_id',
    comentario: 'comentario',
    valoracion: 'valoracion',
    fecha: 'fecha',
    visible: 'visible'
  };

  export type ResenaScalarFieldEnum = (typeof ResenaScalarFieldEnum)[keyof typeof ResenaScalarFieldEnum]


  export const ProductoPersonalizableScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion_general: 'descripcion_general',
    id_categoria: 'id_categoria',
    id_producto_base: 'id_producto_base',
    activo: 'activo'
  };

  export type ProductoPersonalizableScalarFieldEnum = (typeof ProductoPersonalizableScalarFieldEnum)[keyof typeof ProductoPersonalizableScalarFieldEnum]


  export const AtributoScalarFieldEnum: {
    id_atributo: 'id_atributo',
    nombre: 'nombre',
    tipo: 'tipo'
  };

  export type AtributoScalarFieldEnum = (typeof AtributoScalarFieldEnum)[keyof typeof AtributoScalarFieldEnum]


  export const ValorAtributoScalarFieldEnum: {
    id_valor: 'id_valor',
    id_atributo: 'id_atributo',
    valor: 'valor',
    precio_extra: 'precio_extra'
  };

  export type ValorAtributoScalarFieldEnum = (typeof ValorAtributoScalarFieldEnum)[keyof typeof ValorAtributoScalarFieldEnum]


  export const VarianteDetalleScalarFieldEnum: {
    id_productoPersonalizable: 'id_productoPersonalizable',
    id_valor: 'id_valor'
  };

  export type VarianteDetalleScalarFieldEnum = (typeof VarianteDetalleScalarFieldEnum)[keyof typeof VarianteDetalleScalarFieldEnum]


  export const PromocionScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    tipo: 'tipo',
    referencia_id_producto: 'referencia_id_producto',
    referencia_id_categoria: 'referencia_id_categoria',
    valor: 'valor',
    fecha_inicio: 'fecha_inicio',
    fecha_fin: 'fecha_fin'
  };

  export type PromocionScalarFieldEnum = (typeof PromocionScalarFieldEnum)[keyof typeof PromocionScalarFieldEnum]


  export const HistorialPromocionAplicadaScalarFieldEnum: {
    id: 'id',
    promocion_id: 'promocion_id',
    pedido_id: 'pedido_id',
    fecha: 'fecha'
  };

  export type HistorialPromocionAplicadaScalarFieldEnum = (typeof HistorialPromocionAplicadaScalarFieldEnum)[keyof typeof HistorialPromocionAplicadaScalarFieldEnum]


  export const PedidoScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    fecha_pedido: 'fecha_pedido',
    direccion_envio: 'direccion_envio',
    metodo_pago: 'metodo_pago',
    subtotal: 'subtotal',
    total: 'total',
    impuestos: 'impuestos',
    estado_carrito: 'estado_carrito'
  };

  export type PedidoScalarFieldEnum = (typeof PedidoScalarFieldEnum)[keyof typeof PedidoScalarFieldEnum]


  export const PedidoItemScalarFieldEnum: {
    pedido_id: 'pedido_id',
    producto_id: 'producto_id',
    cantidad: 'cantidad',
    producto_personalizado_id: 'producto_personalizado_id'
  };

  export type PedidoItemScalarFieldEnum = (typeof PedidoItemScalarFieldEnum)[keyof typeof PedidoItemScalarFieldEnum]


  export const TransicionEstadoPedidoScalarFieldEnum: {
    id: 'id',
    pedido_id: 'pedido_id',
    estado: 'estado',
    fecha_hora: 'fecha_hora',
    admin_id: 'admin_id'
  };

  export type TransicionEstadoPedidoScalarFieldEnum = (typeof TransicionEstadoPedidoScalarFieldEnum)[keyof typeof TransicionEstadoPedidoScalarFieldEnum]


  export const ReporteResenaScalarFieldEnum: {
    id: 'id',
    resena_id: 'resena_id',
    usuario_id: 'usuario_id',
    comentario: 'comentario'
  };

  export type ReporteResenaScalarFieldEnum = (typeof ReporteResenaScalarFieldEnum)[keyof typeof ReporteResenaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UsuarioOrderByRelevanceFieldEnum: {
    nombre_usuario: 'nombre_usuario',
    correo: 'correo',
    contraseña: 'contraseña'
  };

  export type UsuarioOrderByRelevanceFieldEnum = (typeof UsuarioOrderByRelevanceFieldEnum)[keyof typeof UsuarioOrderByRelevanceFieldEnum]


  export const CategoriaOrderByRelevanceFieldEnum: {
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type CategoriaOrderByRelevanceFieldEnum = (typeof CategoriaOrderByRelevanceFieldEnum)[keyof typeof CategoriaOrderByRelevanceFieldEnum]


  export const EtiquetaOrderByRelevanceFieldEnum: {
    nombre: 'nombre'
  };

  export type EtiquetaOrderByRelevanceFieldEnum = (typeof EtiquetaOrderByRelevanceFieldEnum)[keyof typeof EtiquetaOrderByRelevanceFieldEnum]


  export const ProductoOrderByRelevanceFieldEnum: {
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type ProductoOrderByRelevanceFieldEnum = (typeof ProductoOrderByRelevanceFieldEnum)[keyof typeof ProductoOrderByRelevanceFieldEnum]


  export const ImagenProductoOrderByRelevanceFieldEnum: {
    url: 'url'
  };

  export type ImagenProductoOrderByRelevanceFieldEnum = (typeof ImagenProductoOrderByRelevanceFieldEnum)[keyof typeof ImagenProductoOrderByRelevanceFieldEnum]


  export const ResenaOrderByRelevanceFieldEnum: {
    comentario: 'comentario'
  };

  export type ResenaOrderByRelevanceFieldEnum = (typeof ResenaOrderByRelevanceFieldEnum)[keyof typeof ResenaOrderByRelevanceFieldEnum]


  export const ProductoPersonalizableOrderByRelevanceFieldEnum: {
    nombre: 'nombre',
    descripcion_general: 'descripcion_general'
  };

  export type ProductoPersonalizableOrderByRelevanceFieldEnum = (typeof ProductoPersonalizableOrderByRelevanceFieldEnum)[keyof typeof ProductoPersonalizableOrderByRelevanceFieldEnum]


  export const AtributoOrderByRelevanceFieldEnum: {
    nombre: 'nombre',
    tipo: 'tipo'
  };

  export type AtributoOrderByRelevanceFieldEnum = (typeof AtributoOrderByRelevanceFieldEnum)[keyof typeof AtributoOrderByRelevanceFieldEnum]


  export const ValorAtributoOrderByRelevanceFieldEnum: {
    valor: 'valor'
  };

  export type ValorAtributoOrderByRelevanceFieldEnum = (typeof ValorAtributoOrderByRelevanceFieldEnum)[keyof typeof ValorAtributoOrderByRelevanceFieldEnum]


  export const PromocionOrderByRelevanceFieldEnum: {
    nombre: 'nombre'
  };

  export type PromocionOrderByRelevanceFieldEnum = (typeof PromocionOrderByRelevanceFieldEnum)[keyof typeof PromocionOrderByRelevanceFieldEnum]


  export const PedidoOrderByRelevanceFieldEnum: {
    direccion_envio: 'direccion_envio'
  };

  export type PedidoOrderByRelevanceFieldEnum = (typeof PedidoOrderByRelevanceFieldEnum)[keyof typeof PedidoOrderByRelevanceFieldEnum]


  export const ReporteResenaOrderByRelevanceFieldEnum: {
    comentario: 'comentario'
  };

  export type ReporteResenaOrderByRelevanceFieldEnum = (typeof ReporteResenaOrderByRelevanceFieldEnum)[keyof typeof ReporteResenaOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Rol'
   */
  export type EnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TipoPromocion'
   */
  export type EnumTipoPromocionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoPromocion'>
    


  /**
   * Reference to a field of type 'MetodoPago'
   */
  export type EnumMetodoPagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetodoPago'>
    


  /**
   * Reference to a field of type 'EstadoPedido'
   */
  export type EnumEstadoPedidoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoPedido'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nombre_usuario?: StringFilter<"Usuario"> | string
    correo?: StringFilter<"Usuario"> | string
    contraseña?: StringFilter<"Usuario"> | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    ultimo_inicio_sesion?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    resenas?: ResenaListRelationFilter
    pedidos?: PedidoListRelationFilter
    transiciones_estado?: TransicionEstadoPedidoListRelationFilter
    reportes_resena?: ReporteResenaListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre_usuario?: SortOrder
    correo?: SortOrder
    contraseña?: SortOrder
    rol?: SortOrder
    ultimo_inicio_sesion?: SortOrderInput | SortOrder
    resenas?: ResenaOrderByRelationAggregateInput
    pedidos?: PedidoOrderByRelationAggregateInput
    transiciones_estado?: TransicionEstadoPedidoOrderByRelationAggregateInput
    reportes_resena?: ReporteResenaOrderByRelationAggregateInput
    _relevance?: UsuarioOrderByRelevanceInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    correo?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre_usuario?: StringFilter<"Usuario"> | string
    contraseña?: StringFilter<"Usuario"> | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    ultimo_inicio_sesion?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    resenas?: ResenaListRelationFilter
    pedidos?: PedidoListRelationFilter
    transiciones_estado?: TransicionEstadoPedidoListRelationFilter
    reportes_resena?: ReporteResenaListRelationFilter
  }, "id" | "correo">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre_usuario?: SortOrder
    correo?: SortOrder
    contraseña?: SortOrder
    rol?: SortOrder
    ultimo_inicio_sesion?: SortOrderInput | SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    nombre_usuario?: StringWithAggregatesFilter<"Usuario"> | string
    correo?: StringWithAggregatesFilter<"Usuario"> | string
    contraseña?: StringWithAggregatesFilter<"Usuario"> | string
    rol?: EnumRolWithAggregatesFilter<"Usuario"> | $Enums.Rol
    ultimo_inicio_sesion?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
  }

  export type CategoriaWhereInput = {
    AND?: CategoriaWhereInput | CategoriaWhereInput[]
    OR?: CategoriaWhereInput[]
    NOT?: CategoriaWhereInput | CategoriaWhereInput[]
    id?: IntFilter<"Categoria"> | number
    nombre?: StringFilter<"Categoria"> | string
    descripcion?: StringFilter<"Categoria"> | string
    productos?: ProductoListRelationFilter
    promociones?: PromocionListRelationFilter
    productosPersonalizables?: ProductoPersonalizableListRelationFilter
  }

  export type CategoriaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    productos?: ProductoOrderByRelationAggregateInput
    promociones?: PromocionOrderByRelationAggregateInput
    productosPersonalizables?: ProductoPersonalizableOrderByRelationAggregateInput
    _relevance?: CategoriaOrderByRelevanceInput
  }

  export type CategoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CategoriaWhereInput | CategoriaWhereInput[]
    OR?: CategoriaWhereInput[]
    NOT?: CategoriaWhereInput | CategoriaWhereInput[]
    nombre?: StringFilter<"Categoria"> | string
    descripcion?: StringFilter<"Categoria"> | string
    productos?: ProductoListRelationFilter
    promociones?: PromocionListRelationFilter
    productosPersonalizables?: ProductoPersonalizableListRelationFilter
  }, "id">

  export type CategoriaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    _count?: CategoriaCountOrderByAggregateInput
    _avg?: CategoriaAvgOrderByAggregateInput
    _max?: CategoriaMaxOrderByAggregateInput
    _min?: CategoriaMinOrderByAggregateInput
    _sum?: CategoriaSumOrderByAggregateInput
  }

  export type CategoriaScalarWhereWithAggregatesInput = {
    AND?: CategoriaScalarWhereWithAggregatesInput | CategoriaScalarWhereWithAggregatesInput[]
    OR?: CategoriaScalarWhereWithAggregatesInput[]
    NOT?: CategoriaScalarWhereWithAggregatesInput | CategoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Categoria"> | number
    nombre?: StringWithAggregatesFilter<"Categoria"> | string
    descripcion?: StringWithAggregatesFilter<"Categoria"> | string
  }

  export type EtiquetaWhereInput = {
    AND?: EtiquetaWhereInput | EtiquetaWhereInput[]
    OR?: EtiquetaWhereInput[]
    NOT?: EtiquetaWhereInput | EtiquetaWhereInput[]
    id?: IntFilter<"Etiqueta"> | number
    nombre?: StringFilter<"Etiqueta"> | string
    productos?: ProductoEtiquetaListRelationFilter
  }

  export type EtiquetaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    productos?: ProductoEtiquetaOrderByRelationAggregateInput
    _relevance?: EtiquetaOrderByRelevanceInput
  }

  export type EtiquetaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EtiquetaWhereInput | EtiquetaWhereInput[]
    OR?: EtiquetaWhereInput[]
    NOT?: EtiquetaWhereInput | EtiquetaWhereInput[]
    nombre?: StringFilter<"Etiqueta"> | string
    productos?: ProductoEtiquetaListRelationFilter
  }, "id">

  export type EtiquetaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: EtiquetaCountOrderByAggregateInput
    _avg?: EtiquetaAvgOrderByAggregateInput
    _max?: EtiquetaMaxOrderByAggregateInput
    _min?: EtiquetaMinOrderByAggregateInput
    _sum?: EtiquetaSumOrderByAggregateInput
  }

  export type EtiquetaScalarWhereWithAggregatesInput = {
    AND?: EtiquetaScalarWhereWithAggregatesInput | EtiquetaScalarWhereWithAggregatesInput[]
    OR?: EtiquetaScalarWhereWithAggregatesInput[]
    NOT?: EtiquetaScalarWhereWithAggregatesInput | EtiquetaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Etiqueta"> | number
    nombre?: StringWithAggregatesFilter<"Etiqueta"> | string
  }

  export type ProductoWhereInput = {
    AND?: ProductoWhereInput | ProductoWhereInput[]
    OR?: ProductoWhereInput[]
    NOT?: ProductoWhereInput | ProductoWhereInput[]
    id?: IntFilter<"Producto"> | number
    nombre?: StringFilter<"Producto"> | string
    descripcion?: StringFilter<"Producto"> | string
    precio_base?: FloatFilter<"Producto"> | number
    stock?: IntFilter<"Producto"> | number
    categoria_id?: IntFilter<"Producto"> | number
    promedio_valoracion?: FloatFilter<"Producto"> | number
    activo?: BoolFilter<"Producto"> | boolean
    categoria?: XOR<CategoriaScalarRelationFilter, CategoriaWhereInput>
    imagenes?: ImagenProductoListRelationFilter
    etiquetas?: ProductoEtiquetaListRelationFilter
    resenas?: ResenaListRelationFilter
    pedidoItems?: PedidoItemListRelationFilter
    promociones?: PromocionListRelationFilter
    productosPersonalizables?: ProductoPersonalizableListRelationFilter
  }

  export type ProductoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio_base?: SortOrder
    stock?: SortOrder
    categoria_id?: SortOrder
    promedio_valoracion?: SortOrder
    activo?: SortOrder
    categoria?: CategoriaOrderByWithRelationInput
    imagenes?: ImagenProductoOrderByRelationAggregateInput
    etiquetas?: ProductoEtiquetaOrderByRelationAggregateInput
    resenas?: ResenaOrderByRelationAggregateInput
    pedidoItems?: PedidoItemOrderByRelationAggregateInput
    promociones?: PromocionOrderByRelationAggregateInput
    productosPersonalizables?: ProductoPersonalizableOrderByRelationAggregateInput
    _relevance?: ProductoOrderByRelevanceInput
  }

  export type ProductoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductoWhereInput | ProductoWhereInput[]
    OR?: ProductoWhereInput[]
    NOT?: ProductoWhereInput | ProductoWhereInput[]
    nombre?: StringFilter<"Producto"> | string
    descripcion?: StringFilter<"Producto"> | string
    precio_base?: FloatFilter<"Producto"> | number
    stock?: IntFilter<"Producto"> | number
    categoria_id?: IntFilter<"Producto"> | number
    promedio_valoracion?: FloatFilter<"Producto"> | number
    activo?: BoolFilter<"Producto"> | boolean
    categoria?: XOR<CategoriaScalarRelationFilter, CategoriaWhereInput>
    imagenes?: ImagenProductoListRelationFilter
    etiquetas?: ProductoEtiquetaListRelationFilter
    resenas?: ResenaListRelationFilter
    pedidoItems?: PedidoItemListRelationFilter
    promociones?: PromocionListRelationFilter
    productosPersonalizables?: ProductoPersonalizableListRelationFilter
  }, "id">

  export type ProductoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio_base?: SortOrder
    stock?: SortOrder
    categoria_id?: SortOrder
    promedio_valoracion?: SortOrder
    activo?: SortOrder
    _count?: ProductoCountOrderByAggregateInput
    _avg?: ProductoAvgOrderByAggregateInput
    _max?: ProductoMaxOrderByAggregateInput
    _min?: ProductoMinOrderByAggregateInput
    _sum?: ProductoSumOrderByAggregateInput
  }

  export type ProductoScalarWhereWithAggregatesInput = {
    AND?: ProductoScalarWhereWithAggregatesInput | ProductoScalarWhereWithAggregatesInput[]
    OR?: ProductoScalarWhereWithAggregatesInput[]
    NOT?: ProductoScalarWhereWithAggregatesInput | ProductoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Producto"> | number
    nombre?: StringWithAggregatesFilter<"Producto"> | string
    descripcion?: StringWithAggregatesFilter<"Producto"> | string
    precio_base?: FloatWithAggregatesFilter<"Producto"> | number
    stock?: IntWithAggregatesFilter<"Producto"> | number
    categoria_id?: IntWithAggregatesFilter<"Producto"> | number
    promedio_valoracion?: FloatWithAggregatesFilter<"Producto"> | number
    activo?: BoolWithAggregatesFilter<"Producto"> | boolean
  }

  export type ImagenProductoWhereInput = {
    AND?: ImagenProductoWhereInput | ImagenProductoWhereInput[]
    OR?: ImagenProductoWhereInput[]
    NOT?: ImagenProductoWhereInput | ImagenProductoWhereInput[]
    id?: IntFilter<"ImagenProducto"> | number
    producto_id?: IntFilter<"ImagenProducto"> | number
    url?: StringFilter<"ImagenProducto"> | string
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }

  export type ImagenProductoOrderByWithRelationInput = {
    id?: SortOrder
    producto_id?: SortOrder
    url?: SortOrder
    producto?: ProductoOrderByWithRelationInput
    _relevance?: ImagenProductoOrderByRelevanceInput
  }

  export type ImagenProductoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ImagenProductoWhereInput | ImagenProductoWhereInput[]
    OR?: ImagenProductoWhereInput[]
    NOT?: ImagenProductoWhereInput | ImagenProductoWhereInput[]
    producto_id?: IntFilter<"ImagenProducto"> | number
    url?: StringFilter<"ImagenProducto"> | string
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
  }, "id">

  export type ImagenProductoOrderByWithAggregationInput = {
    id?: SortOrder
    producto_id?: SortOrder
    url?: SortOrder
    _count?: ImagenProductoCountOrderByAggregateInput
    _avg?: ImagenProductoAvgOrderByAggregateInput
    _max?: ImagenProductoMaxOrderByAggregateInput
    _min?: ImagenProductoMinOrderByAggregateInput
    _sum?: ImagenProductoSumOrderByAggregateInput
  }

  export type ImagenProductoScalarWhereWithAggregatesInput = {
    AND?: ImagenProductoScalarWhereWithAggregatesInput | ImagenProductoScalarWhereWithAggregatesInput[]
    OR?: ImagenProductoScalarWhereWithAggregatesInput[]
    NOT?: ImagenProductoScalarWhereWithAggregatesInput | ImagenProductoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ImagenProducto"> | number
    producto_id?: IntWithAggregatesFilter<"ImagenProducto"> | number
    url?: StringWithAggregatesFilter<"ImagenProducto"> | string
  }

  export type ProductoEtiquetaWhereInput = {
    AND?: ProductoEtiquetaWhereInput | ProductoEtiquetaWhereInput[]
    OR?: ProductoEtiquetaWhereInput[]
    NOT?: ProductoEtiquetaWhereInput | ProductoEtiquetaWhereInput[]
    producto_id?: IntFilter<"ProductoEtiqueta"> | number
    etiqueta_id?: IntFilter<"ProductoEtiqueta"> | number
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
    etiqueta?: XOR<EtiquetaScalarRelationFilter, EtiquetaWhereInput>
  }

  export type ProductoEtiquetaOrderByWithRelationInput = {
    producto_id?: SortOrder
    etiqueta_id?: SortOrder
    producto?: ProductoOrderByWithRelationInput
    etiqueta?: EtiquetaOrderByWithRelationInput
  }

  export type ProductoEtiquetaWhereUniqueInput = Prisma.AtLeast<{
    producto_id_etiqueta_id?: ProductoEtiquetaProducto_idEtiqueta_idCompoundUniqueInput
    AND?: ProductoEtiquetaWhereInput | ProductoEtiquetaWhereInput[]
    OR?: ProductoEtiquetaWhereInput[]
    NOT?: ProductoEtiquetaWhereInput | ProductoEtiquetaWhereInput[]
    producto_id?: IntFilter<"ProductoEtiqueta"> | number
    etiqueta_id?: IntFilter<"ProductoEtiqueta"> | number
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
    etiqueta?: XOR<EtiquetaScalarRelationFilter, EtiquetaWhereInput>
  }, "producto_id_etiqueta_id">

  export type ProductoEtiquetaOrderByWithAggregationInput = {
    producto_id?: SortOrder
    etiqueta_id?: SortOrder
    _count?: ProductoEtiquetaCountOrderByAggregateInput
    _avg?: ProductoEtiquetaAvgOrderByAggregateInput
    _max?: ProductoEtiquetaMaxOrderByAggregateInput
    _min?: ProductoEtiquetaMinOrderByAggregateInput
    _sum?: ProductoEtiquetaSumOrderByAggregateInput
  }

  export type ProductoEtiquetaScalarWhereWithAggregatesInput = {
    AND?: ProductoEtiquetaScalarWhereWithAggregatesInput | ProductoEtiquetaScalarWhereWithAggregatesInput[]
    OR?: ProductoEtiquetaScalarWhereWithAggregatesInput[]
    NOT?: ProductoEtiquetaScalarWhereWithAggregatesInput | ProductoEtiquetaScalarWhereWithAggregatesInput[]
    producto_id?: IntWithAggregatesFilter<"ProductoEtiqueta"> | number
    etiqueta_id?: IntWithAggregatesFilter<"ProductoEtiqueta"> | number
  }

  export type ResenaWhereInput = {
    AND?: ResenaWhereInput | ResenaWhereInput[]
    OR?: ResenaWhereInput[]
    NOT?: ResenaWhereInput | ResenaWhereInput[]
    id?: IntFilter<"Resena"> | number
    usuario_id?: IntFilter<"Resena"> | number
    producto_id?: IntFilter<"Resena"> | number
    comentario?: StringFilter<"Resena"> | string
    valoracion?: IntFilter<"Resena"> | number
    fecha?: DateTimeFilter<"Resena"> | Date | string
    visible?: BoolFilter<"Resena"> | boolean
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
    reportes?: ReporteResenaListRelationFilter
  }

  export type ResenaOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    producto_id?: SortOrder
    comentario?: SortOrder
    valoracion?: SortOrder
    fecha?: SortOrder
    visible?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    producto?: ProductoOrderByWithRelationInput
    reportes?: ReporteResenaOrderByRelationAggregateInput
    _relevance?: ResenaOrderByRelevanceInput
  }

  export type ResenaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResenaWhereInput | ResenaWhereInput[]
    OR?: ResenaWhereInput[]
    NOT?: ResenaWhereInput | ResenaWhereInput[]
    usuario_id?: IntFilter<"Resena"> | number
    producto_id?: IntFilter<"Resena"> | number
    comentario?: StringFilter<"Resena"> | string
    valoracion?: IntFilter<"Resena"> | number
    fecha?: DateTimeFilter<"Resena"> | Date | string
    visible?: BoolFilter<"Resena"> | boolean
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
    reportes?: ReporteResenaListRelationFilter
  }, "id">

  export type ResenaOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    producto_id?: SortOrder
    comentario?: SortOrder
    valoracion?: SortOrder
    fecha?: SortOrder
    visible?: SortOrder
    _count?: ResenaCountOrderByAggregateInput
    _avg?: ResenaAvgOrderByAggregateInput
    _max?: ResenaMaxOrderByAggregateInput
    _min?: ResenaMinOrderByAggregateInput
    _sum?: ResenaSumOrderByAggregateInput
  }

  export type ResenaScalarWhereWithAggregatesInput = {
    AND?: ResenaScalarWhereWithAggregatesInput | ResenaScalarWhereWithAggregatesInput[]
    OR?: ResenaScalarWhereWithAggregatesInput[]
    NOT?: ResenaScalarWhereWithAggregatesInput | ResenaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Resena"> | number
    usuario_id?: IntWithAggregatesFilter<"Resena"> | number
    producto_id?: IntWithAggregatesFilter<"Resena"> | number
    comentario?: StringWithAggregatesFilter<"Resena"> | string
    valoracion?: IntWithAggregatesFilter<"Resena"> | number
    fecha?: DateTimeWithAggregatesFilter<"Resena"> | Date | string
    visible?: BoolWithAggregatesFilter<"Resena"> | boolean
  }

  export type ProductoPersonalizableWhereInput = {
    AND?: ProductoPersonalizableWhereInput | ProductoPersonalizableWhereInput[]
    OR?: ProductoPersonalizableWhereInput[]
    NOT?: ProductoPersonalizableWhereInput | ProductoPersonalizableWhereInput[]
    id?: IntFilter<"ProductoPersonalizable"> | number
    nombre?: StringFilter<"ProductoPersonalizable"> | string
    descripcion_general?: StringFilter<"ProductoPersonalizable"> | string
    id_categoria?: IntFilter<"ProductoPersonalizable"> | number
    id_producto_base?: IntFilter<"ProductoPersonalizable"> | number
    activo?: BoolFilter<"ProductoPersonalizable"> | boolean
    categoria?: XOR<CategoriaScalarRelationFilter, CategoriaWhereInput>
    producto_base?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
    pedidoItems?: PedidoItemListRelationFilter
    variantes?: VarianteDetalleListRelationFilter
  }

  export type ProductoPersonalizableOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion_general?: SortOrder
    id_categoria?: SortOrder
    id_producto_base?: SortOrder
    activo?: SortOrder
    categoria?: CategoriaOrderByWithRelationInput
    producto_base?: ProductoOrderByWithRelationInput
    pedidoItems?: PedidoItemOrderByRelationAggregateInput
    variantes?: VarianteDetalleOrderByRelationAggregateInput
    _relevance?: ProductoPersonalizableOrderByRelevanceInput
  }

  export type ProductoPersonalizableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductoPersonalizableWhereInput | ProductoPersonalizableWhereInput[]
    OR?: ProductoPersonalizableWhereInput[]
    NOT?: ProductoPersonalizableWhereInput | ProductoPersonalizableWhereInput[]
    nombre?: StringFilter<"ProductoPersonalizable"> | string
    descripcion_general?: StringFilter<"ProductoPersonalizable"> | string
    id_categoria?: IntFilter<"ProductoPersonalizable"> | number
    id_producto_base?: IntFilter<"ProductoPersonalizable"> | number
    activo?: BoolFilter<"ProductoPersonalizable"> | boolean
    categoria?: XOR<CategoriaScalarRelationFilter, CategoriaWhereInput>
    producto_base?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
    pedidoItems?: PedidoItemListRelationFilter
    variantes?: VarianteDetalleListRelationFilter
  }, "id">

  export type ProductoPersonalizableOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion_general?: SortOrder
    id_categoria?: SortOrder
    id_producto_base?: SortOrder
    activo?: SortOrder
    _count?: ProductoPersonalizableCountOrderByAggregateInput
    _avg?: ProductoPersonalizableAvgOrderByAggregateInput
    _max?: ProductoPersonalizableMaxOrderByAggregateInput
    _min?: ProductoPersonalizableMinOrderByAggregateInput
    _sum?: ProductoPersonalizableSumOrderByAggregateInput
  }

  export type ProductoPersonalizableScalarWhereWithAggregatesInput = {
    AND?: ProductoPersonalizableScalarWhereWithAggregatesInput | ProductoPersonalizableScalarWhereWithAggregatesInput[]
    OR?: ProductoPersonalizableScalarWhereWithAggregatesInput[]
    NOT?: ProductoPersonalizableScalarWhereWithAggregatesInput | ProductoPersonalizableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductoPersonalizable"> | number
    nombre?: StringWithAggregatesFilter<"ProductoPersonalizable"> | string
    descripcion_general?: StringWithAggregatesFilter<"ProductoPersonalizable"> | string
    id_categoria?: IntWithAggregatesFilter<"ProductoPersonalizable"> | number
    id_producto_base?: IntWithAggregatesFilter<"ProductoPersonalizable"> | number
    activo?: BoolWithAggregatesFilter<"ProductoPersonalizable"> | boolean
  }

  export type AtributoWhereInput = {
    AND?: AtributoWhereInput | AtributoWhereInput[]
    OR?: AtributoWhereInput[]
    NOT?: AtributoWhereInput | AtributoWhereInput[]
    id_atributo?: IntFilter<"Atributo"> | number
    nombre?: StringFilter<"Atributo"> | string
    tipo?: StringFilter<"Atributo"> | string
    valores?: ValorAtributoListRelationFilter
  }

  export type AtributoOrderByWithRelationInput = {
    id_atributo?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    valores?: ValorAtributoOrderByRelationAggregateInput
    _relevance?: AtributoOrderByRelevanceInput
  }

  export type AtributoWhereUniqueInput = Prisma.AtLeast<{
    id_atributo?: number
    AND?: AtributoWhereInput | AtributoWhereInput[]
    OR?: AtributoWhereInput[]
    NOT?: AtributoWhereInput | AtributoWhereInput[]
    nombre?: StringFilter<"Atributo"> | string
    tipo?: StringFilter<"Atributo"> | string
    valores?: ValorAtributoListRelationFilter
  }, "id_atributo">

  export type AtributoOrderByWithAggregationInput = {
    id_atributo?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    _count?: AtributoCountOrderByAggregateInput
    _avg?: AtributoAvgOrderByAggregateInput
    _max?: AtributoMaxOrderByAggregateInput
    _min?: AtributoMinOrderByAggregateInput
    _sum?: AtributoSumOrderByAggregateInput
  }

  export type AtributoScalarWhereWithAggregatesInput = {
    AND?: AtributoScalarWhereWithAggregatesInput | AtributoScalarWhereWithAggregatesInput[]
    OR?: AtributoScalarWhereWithAggregatesInput[]
    NOT?: AtributoScalarWhereWithAggregatesInput | AtributoScalarWhereWithAggregatesInput[]
    id_atributo?: IntWithAggregatesFilter<"Atributo"> | number
    nombre?: StringWithAggregatesFilter<"Atributo"> | string
    tipo?: StringWithAggregatesFilter<"Atributo"> | string
  }

  export type ValorAtributoWhereInput = {
    AND?: ValorAtributoWhereInput | ValorAtributoWhereInput[]
    OR?: ValorAtributoWhereInput[]
    NOT?: ValorAtributoWhereInput | ValorAtributoWhereInput[]
    id_valor?: IntFilter<"ValorAtributo"> | number
    id_atributo?: IntFilter<"ValorAtributo"> | number
    valor?: StringFilter<"ValorAtributo"> | string
    precio_extra?: FloatFilter<"ValorAtributo"> | number
    atributo?: XOR<AtributoScalarRelationFilter, AtributoWhereInput>
    varianteDetalles?: VarianteDetalleListRelationFilter
  }

  export type ValorAtributoOrderByWithRelationInput = {
    id_valor?: SortOrder
    id_atributo?: SortOrder
    valor?: SortOrder
    precio_extra?: SortOrder
    atributo?: AtributoOrderByWithRelationInput
    varianteDetalles?: VarianteDetalleOrderByRelationAggregateInput
    _relevance?: ValorAtributoOrderByRelevanceInput
  }

  export type ValorAtributoWhereUniqueInput = Prisma.AtLeast<{
    id_valor?: number
    AND?: ValorAtributoWhereInput | ValorAtributoWhereInput[]
    OR?: ValorAtributoWhereInput[]
    NOT?: ValorAtributoWhereInput | ValorAtributoWhereInput[]
    id_atributo?: IntFilter<"ValorAtributo"> | number
    valor?: StringFilter<"ValorAtributo"> | string
    precio_extra?: FloatFilter<"ValorAtributo"> | number
    atributo?: XOR<AtributoScalarRelationFilter, AtributoWhereInput>
    varianteDetalles?: VarianteDetalleListRelationFilter
  }, "id_valor">

  export type ValorAtributoOrderByWithAggregationInput = {
    id_valor?: SortOrder
    id_atributo?: SortOrder
    valor?: SortOrder
    precio_extra?: SortOrder
    _count?: ValorAtributoCountOrderByAggregateInput
    _avg?: ValorAtributoAvgOrderByAggregateInput
    _max?: ValorAtributoMaxOrderByAggregateInput
    _min?: ValorAtributoMinOrderByAggregateInput
    _sum?: ValorAtributoSumOrderByAggregateInput
  }

  export type ValorAtributoScalarWhereWithAggregatesInput = {
    AND?: ValorAtributoScalarWhereWithAggregatesInput | ValorAtributoScalarWhereWithAggregatesInput[]
    OR?: ValorAtributoScalarWhereWithAggregatesInput[]
    NOT?: ValorAtributoScalarWhereWithAggregatesInput | ValorAtributoScalarWhereWithAggregatesInput[]
    id_valor?: IntWithAggregatesFilter<"ValorAtributo"> | number
    id_atributo?: IntWithAggregatesFilter<"ValorAtributo"> | number
    valor?: StringWithAggregatesFilter<"ValorAtributo"> | string
    precio_extra?: FloatWithAggregatesFilter<"ValorAtributo"> | number
  }

  export type VarianteDetalleWhereInput = {
    AND?: VarianteDetalleWhereInput | VarianteDetalleWhereInput[]
    OR?: VarianteDetalleWhereInput[]
    NOT?: VarianteDetalleWhereInput | VarianteDetalleWhereInput[]
    id_productoPersonalizable?: IntFilter<"VarianteDetalle"> | number
    id_valor?: IntFilter<"VarianteDetalle"> | number
    valor?: XOR<ValorAtributoScalarRelationFilter, ValorAtributoWhereInput>
    productoPersonalizable?: XOR<ProductoPersonalizableScalarRelationFilter, ProductoPersonalizableWhereInput>
  }

  export type VarianteDetalleOrderByWithRelationInput = {
    id_productoPersonalizable?: SortOrder
    id_valor?: SortOrder
    valor?: ValorAtributoOrderByWithRelationInput
    productoPersonalizable?: ProductoPersonalizableOrderByWithRelationInput
  }

  export type VarianteDetalleWhereUniqueInput = Prisma.AtLeast<{
    id_productoPersonalizable_id_valor?: VarianteDetalleId_productoPersonalizableId_valorCompoundUniqueInput
    AND?: VarianteDetalleWhereInput | VarianteDetalleWhereInput[]
    OR?: VarianteDetalleWhereInput[]
    NOT?: VarianteDetalleWhereInput | VarianteDetalleWhereInput[]
    id_productoPersonalizable?: IntFilter<"VarianteDetalle"> | number
    id_valor?: IntFilter<"VarianteDetalle"> | number
    valor?: XOR<ValorAtributoScalarRelationFilter, ValorAtributoWhereInput>
    productoPersonalizable?: XOR<ProductoPersonalizableScalarRelationFilter, ProductoPersonalizableWhereInput>
  }, "id_productoPersonalizable_id_valor">

  export type VarianteDetalleOrderByWithAggregationInput = {
    id_productoPersonalizable?: SortOrder
    id_valor?: SortOrder
    _count?: VarianteDetalleCountOrderByAggregateInput
    _avg?: VarianteDetalleAvgOrderByAggregateInput
    _max?: VarianteDetalleMaxOrderByAggregateInput
    _min?: VarianteDetalleMinOrderByAggregateInput
    _sum?: VarianteDetalleSumOrderByAggregateInput
  }

  export type VarianteDetalleScalarWhereWithAggregatesInput = {
    AND?: VarianteDetalleScalarWhereWithAggregatesInput | VarianteDetalleScalarWhereWithAggregatesInput[]
    OR?: VarianteDetalleScalarWhereWithAggregatesInput[]
    NOT?: VarianteDetalleScalarWhereWithAggregatesInput | VarianteDetalleScalarWhereWithAggregatesInput[]
    id_productoPersonalizable?: IntWithAggregatesFilter<"VarianteDetalle"> | number
    id_valor?: IntWithAggregatesFilter<"VarianteDetalle"> | number
  }

  export type PromocionWhereInput = {
    AND?: PromocionWhereInput | PromocionWhereInput[]
    OR?: PromocionWhereInput[]
    NOT?: PromocionWhereInput | PromocionWhereInput[]
    id?: IntFilter<"Promocion"> | number
    nombre?: StringFilter<"Promocion"> | string
    tipo?: EnumTipoPromocionFilter<"Promocion"> | $Enums.TipoPromocion
    referencia_id_producto?: IntNullableFilter<"Promocion"> | number | null
    referencia_id_categoria?: IntNullableFilter<"Promocion"> | number | null
    valor?: FloatFilter<"Promocion"> | number
    fecha_inicio?: DateTimeFilter<"Promocion"> | Date | string
    fecha_fin?: DateTimeFilter<"Promocion"> | Date | string
    producto?: XOR<ProductoNullableScalarRelationFilter, ProductoWhereInput> | null
    categoria?: XOR<CategoriaNullableScalarRelationFilter, CategoriaWhereInput> | null
    historial?: HistorialPromocionAplicadaListRelationFilter
  }

  export type PromocionOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    referencia_id_producto?: SortOrderInput | SortOrder
    referencia_id_categoria?: SortOrderInput | SortOrder
    valor?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    producto?: ProductoOrderByWithRelationInput
    categoria?: CategoriaOrderByWithRelationInput
    historial?: HistorialPromocionAplicadaOrderByRelationAggregateInput
    _relevance?: PromocionOrderByRelevanceInput
  }

  export type PromocionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PromocionWhereInput | PromocionWhereInput[]
    OR?: PromocionWhereInput[]
    NOT?: PromocionWhereInput | PromocionWhereInput[]
    nombre?: StringFilter<"Promocion"> | string
    tipo?: EnumTipoPromocionFilter<"Promocion"> | $Enums.TipoPromocion
    referencia_id_producto?: IntNullableFilter<"Promocion"> | number | null
    referencia_id_categoria?: IntNullableFilter<"Promocion"> | number | null
    valor?: FloatFilter<"Promocion"> | number
    fecha_inicio?: DateTimeFilter<"Promocion"> | Date | string
    fecha_fin?: DateTimeFilter<"Promocion"> | Date | string
    producto?: XOR<ProductoNullableScalarRelationFilter, ProductoWhereInput> | null
    categoria?: XOR<CategoriaNullableScalarRelationFilter, CategoriaWhereInput> | null
    historial?: HistorialPromocionAplicadaListRelationFilter
  }, "id">

  export type PromocionOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    referencia_id_producto?: SortOrderInput | SortOrder
    referencia_id_categoria?: SortOrderInput | SortOrder
    valor?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    _count?: PromocionCountOrderByAggregateInput
    _avg?: PromocionAvgOrderByAggregateInput
    _max?: PromocionMaxOrderByAggregateInput
    _min?: PromocionMinOrderByAggregateInput
    _sum?: PromocionSumOrderByAggregateInput
  }

  export type PromocionScalarWhereWithAggregatesInput = {
    AND?: PromocionScalarWhereWithAggregatesInput | PromocionScalarWhereWithAggregatesInput[]
    OR?: PromocionScalarWhereWithAggregatesInput[]
    NOT?: PromocionScalarWhereWithAggregatesInput | PromocionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Promocion"> | number
    nombre?: StringWithAggregatesFilter<"Promocion"> | string
    tipo?: EnumTipoPromocionWithAggregatesFilter<"Promocion"> | $Enums.TipoPromocion
    referencia_id_producto?: IntNullableWithAggregatesFilter<"Promocion"> | number | null
    referencia_id_categoria?: IntNullableWithAggregatesFilter<"Promocion"> | number | null
    valor?: FloatWithAggregatesFilter<"Promocion"> | number
    fecha_inicio?: DateTimeWithAggregatesFilter<"Promocion"> | Date | string
    fecha_fin?: DateTimeWithAggregatesFilter<"Promocion"> | Date | string
  }

  export type HistorialPromocionAplicadaWhereInput = {
    AND?: HistorialPromocionAplicadaWhereInput | HistorialPromocionAplicadaWhereInput[]
    OR?: HistorialPromocionAplicadaWhereInput[]
    NOT?: HistorialPromocionAplicadaWhereInput | HistorialPromocionAplicadaWhereInput[]
    id?: IntFilter<"HistorialPromocionAplicada"> | number
    promocion_id?: IntFilter<"HistorialPromocionAplicada"> | number
    pedido_id?: IntFilter<"HistorialPromocionAplicada"> | number
    fecha?: DateTimeFilter<"HistorialPromocionAplicada"> | Date | string
    promocion?: XOR<PromocionScalarRelationFilter, PromocionWhereInput>
    pedido?: XOR<PedidoScalarRelationFilter, PedidoWhereInput>
  }

  export type HistorialPromocionAplicadaOrderByWithRelationInput = {
    id?: SortOrder
    promocion_id?: SortOrder
    pedido_id?: SortOrder
    fecha?: SortOrder
    promocion?: PromocionOrderByWithRelationInput
    pedido?: PedidoOrderByWithRelationInput
  }

  export type HistorialPromocionAplicadaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HistorialPromocionAplicadaWhereInput | HistorialPromocionAplicadaWhereInput[]
    OR?: HistorialPromocionAplicadaWhereInput[]
    NOT?: HistorialPromocionAplicadaWhereInput | HistorialPromocionAplicadaWhereInput[]
    promocion_id?: IntFilter<"HistorialPromocionAplicada"> | number
    pedido_id?: IntFilter<"HistorialPromocionAplicada"> | number
    fecha?: DateTimeFilter<"HistorialPromocionAplicada"> | Date | string
    promocion?: XOR<PromocionScalarRelationFilter, PromocionWhereInput>
    pedido?: XOR<PedidoScalarRelationFilter, PedidoWhereInput>
  }, "id">

  export type HistorialPromocionAplicadaOrderByWithAggregationInput = {
    id?: SortOrder
    promocion_id?: SortOrder
    pedido_id?: SortOrder
    fecha?: SortOrder
    _count?: HistorialPromocionAplicadaCountOrderByAggregateInput
    _avg?: HistorialPromocionAplicadaAvgOrderByAggregateInput
    _max?: HistorialPromocionAplicadaMaxOrderByAggregateInput
    _min?: HistorialPromocionAplicadaMinOrderByAggregateInput
    _sum?: HistorialPromocionAplicadaSumOrderByAggregateInput
  }

  export type HistorialPromocionAplicadaScalarWhereWithAggregatesInput = {
    AND?: HistorialPromocionAplicadaScalarWhereWithAggregatesInput | HistorialPromocionAplicadaScalarWhereWithAggregatesInput[]
    OR?: HistorialPromocionAplicadaScalarWhereWithAggregatesInput[]
    NOT?: HistorialPromocionAplicadaScalarWhereWithAggregatesInput | HistorialPromocionAplicadaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HistorialPromocionAplicada"> | number
    promocion_id?: IntWithAggregatesFilter<"HistorialPromocionAplicada"> | number
    pedido_id?: IntWithAggregatesFilter<"HistorialPromocionAplicada"> | number
    fecha?: DateTimeWithAggregatesFilter<"HistorialPromocionAplicada"> | Date | string
  }

  export type PedidoWhereInput = {
    AND?: PedidoWhereInput | PedidoWhereInput[]
    OR?: PedidoWhereInput[]
    NOT?: PedidoWhereInput | PedidoWhereInput[]
    id?: IntFilter<"Pedido"> | number
    usuario_id?: IntFilter<"Pedido"> | number
    fecha_pedido?: DateTimeFilter<"Pedido"> | Date | string
    direccion_envio?: StringFilter<"Pedido"> | string
    metodo_pago?: EnumMetodoPagoFilter<"Pedido"> | $Enums.MetodoPago
    subtotal?: FloatFilter<"Pedido"> | number
    total?: FloatFilter<"Pedido"> | number
    impuestos?: FloatFilter<"Pedido"> | number
    estado_carrito?: BoolFilter<"Pedido"> | boolean
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    items?: PedidoItemListRelationFilter
    transiciones?: TransicionEstadoPedidoListRelationFilter
    promociones_aplicadas?: HistorialPromocionAplicadaListRelationFilter
  }

  export type PedidoOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    fecha_pedido?: SortOrder
    direccion_envio?: SortOrder
    metodo_pago?: SortOrder
    subtotal?: SortOrder
    total?: SortOrder
    impuestos?: SortOrder
    estado_carrito?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    items?: PedidoItemOrderByRelationAggregateInput
    transiciones?: TransicionEstadoPedidoOrderByRelationAggregateInput
    promociones_aplicadas?: HistorialPromocionAplicadaOrderByRelationAggregateInput
    _relevance?: PedidoOrderByRelevanceInput
  }

  export type PedidoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PedidoWhereInput | PedidoWhereInput[]
    OR?: PedidoWhereInput[]
    NOT?: PedidoWhereInput | PedidoWhereInput[]
    usuario_id?: IntFilter<"Pedido"> | number
    fecha_pedido?: DateTimeFilter<"Pedido"> | Date | string
    direccion_envio?: StringFilter<"Pedido"> | string
    metodo_pago?: EnumMetodoPagoFilter<"Pedido"> | $Enums.MetodoPago
    subtotal?: FloatFilter<"Pedido"> | number
    total?: FloatFilter<"Pedido"> | number
    impuestos?: FloatFilter<"Pedido"> | number
    estado_carrito?: BoolFilter<"Pedido"> | boolean
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    items?: PedidoItemListRelationFilter
    transiciones?: TransicionEstadoPedidoListRelationFilter
    promociones_aplicadas?: HistorialPromocionAplicadaListRelationFilter
  }, "id">

  export type PedidoOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    fecha_pedido?: SortOrder
    direccion_envio?: SortOrder
    metodo_pago?: SortOrder
    subtotal?: SortOrder
    total?: SortOrder
    impuestos?: SortOrder
    estado_carrito?: SortOrder
    _count?: PedidoCountOrderByAggregateInput
    _avg?: PedidoAvgOrderByAggregateInput
    _max?: PedidoMaxOrderByAggregateInput
    _min?: PedidoMinOrderByAggregateInput
    _sum?: PedidoSumOrderByAggregateInput
  }

  export type PedidoScalarWhereWithAggregatesInput = {
    AND?: PedidoScalarWhereWithAggregatesInput | PedidoScalarWhereWithAggregatesInput[]
    OR?: PedidoScalarWhereWithAggregatesInput[]
    NOT?: PedidoScalarWhereWithAggregatesInput | PedidoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pedido"> | number
    usuario_id?: IntWithAggregatesFilter<"Pedido"> | number
    fecha_pedido?: DateTimeWithAggregatesFilter<"Pedido"> | Date | string
    direccion_envio?: StringWithAggregatesFilter<"Pedido"> | string
    metodo_pago?: EnumMetodoPagoWithAggregatesFilter<"Pedido"> | $Enums.MetodoPago
    subtotal?: FloatWithAggregatesFilter<"Pedido"> | number
    total?: FloatWithAggregatesFilter<"Pedido"> | number
    impuestos?: FloatWithAggregatesFilter<"Pedido"> | number
    estado_carrito?: BoolWithAggregatesFilter<"Pedido"> | boolean
  }

  export type PedidoItemWhereInput = {
    AND?: PedidoItemWhereInput | PedidoItemWhereInput[]
    OR?: PedidoItemWhereInput[]
    NOT?: PedidoItemWhereInput | PedidoItemWhereInput[]
    pedido_id?: IntFilter<"PedidoItem"> | number
    producto_id?: IntFilter<"PedidoItem"> | number
    cantidad?: IntFilter<"PedidoItem"> | number
    producto_personalizado_id?: IntNullableFilter<"PedidoItem"> | number | null
    pedido?: XOR<PedidoScalarRelationFilter, PedidoWhereInput>
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
    producto_personalizado?: XOR<ProductoPersonalizableNullableScalarRelationFilter, ProductoPersonalizableWhereInput> | null
  }

  export type PedidoItemOrderByWithRelationInput = {
    pedido_id?: SortOrder
    producto_id?: SortOrder
    cantidad?: SortOrder
    producto_personalizado_id?: SortOrderInput | SortOrder
    pedido?: PedidoOrderByWithRelationInput
    producto?: ProductoOrderByWithRelationInput
    producto_personalizado?: ProductoPersonalizableOrderByWithRelationInput
  }

  export type PedidoItemWhereUniqueInput = Prisma.AtLeast<{
    pedido_id_producto_id?: PedidoItemPedido_idProducto_idCompoundUniqueInput
    AND?: PedidoItemWhereInput | PedidoItemWhereInput[]
    OR?: PedidoItemWhereInput[]
    NOT?: PedidoItemWhereInput | PedidoItemWhereInput[]
    pedido_id?: IntFilter<"PedidoItem"> | number
    producto_id?: IntFilter<"PedidoItem"> | number
    cantidad?: IntFilter<"PedidoItem"> | number
    producto_personalizado_id?: IntNullableFilter<"PedidoItem"> | number | null
    pedido?: XOR<PedidoScalarRelationFilter, PedidoWhereInput>
    producto?: XOR<ProductoScalarRelationFilter, ProductoWhereInput>
    producto_personalizado?: XOR<ProductoPersonalizableNullableScalarRelationFilter, ProductoPersonalizableWhereInput> | null
  }, "pedido_id_producto_id">

  export type PedidoItemOrderByWithAggregationInput = {
    pedido_id?: SortOrder
    producto_id?: SortOrder
    cantidad?: SortOrder
    producto_personalizado_id?: SortOrderInput | SortOrder
    _count?: PedidoItemCountOrderByAggregateInput
    _avg?: PedidoItemAvgOrderByAggregateInput
    _max?: PedidoItemMaxOrderByAggregateInput
    _min?: PedidoItemMinOrderByAggregateInput
    _sum?: PedidoItemSumOrderByAggregateInput
  }

  export type PedidoItemScalarWhereWithAggregatesInput = {
    AND?: PedidoItemScalarWhereWithAggregatesInput | PedidoItemScalarWhereWithAggregatesInput[]
    OR?: PedidoItemScalarWhereWithAggregatesInput[]
    NOT?: PedidoItemScalarWhereWithAggregatesInput | PedidoItemScalarWhereWithAggregatesInput[]
    pedido_id?: IntWithAggregatesFilter<"PedidoItem"> | number
    producto_id?: IntWithAggregatesFilter<"PedidoItem"> | number
    cantidad?: IntWithAggregatesFilter<"PedidoItem"> | number
    producto_personalizado_id?: IntNullableWithAggregatesFilter<"PedidoItem"> | number | null
  }

  export type TransicionEstadoPedidoWhereInput = {
    AND?: TransicionEstadoPedidoWhereInput | TransicionEstadoPedidoWhereInput[]
    OR?: TransicionEstadoPedidoWhereInput[]
    NOT?: TransicionEstadoPedidoWhereInput | TransicionEstadoPedidoWhereInput[]
    id?: IntFilter<"TransicionEstadoPedido"> | number
    pedido_id?: IntFilter<"TransicionEstadoPedido"> | number
    estado?: EnumEstadoPedidoFilter<"TransicionEstadoPedido"> | $Enums.EstadoPedido
    fecha_hora?: DateTimeFilter<"TransicionEstadoPedido"> | Date | string
    admin_id?: IntFilter<"TransicionEstadoPedido"> | number
    pedido?: XOR<PedidoScalarRelationFilter, PedidoWhereInput>
    admin?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type TransicionEstadoPedidoOrderByWithRelationInput = {
    id?: SortOrder
    pedido_id?: SortOrder
    estado?: SortOrder
    fecha_hora?: SortOrder
    admin_id?: SortOrder
    pedido?: PedidoOrderByWithRelationInput
    admin?: UsuarioOrderByWithRelationInput
  }

  export type TransicionEstadoPedidoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransicionEstadoPedidoWhereInput | TransicionEstadoPedidoWhereInput[]
    OR?: TransicionEstadoPedidoWhereInput[]
    NOT?: TransicionEstadoPedidoWhereInput | TransicionEstadoPedidoWhereInput[]
    pedido_id?: IntFilter<"TransicionEstadoPedido"> | number
    estado?: EnumEstadoPedidoFilter<"TransicionEstadoPedido"> | $Enums.EstadoPedido
    fecha_hora?: DateTimeFilter<"TransicionEstadoPedido"> | Date | string
    admin_id?: IntFilter<"TransicionEstadoPedido"> | number
    pedido?: XOR<PedidoScalarRelationFilter, PedidoWhereInput>
    admin?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type TransicionEstadoPedidoOrderByWithAggregationInput = {
    id?: SortOrder
    pedido_id?: SortOrder
    estado?: SortOrder
    fecha_hora?: SortOrder
    admin_id?: SortOrder
    _count?: TransicionEstadoPedidoCountOrderByAggregateInput
    _avg?: TransicionEstadoPedidoAvgOrderByAggregateInput
    _max?: TransicionEstadoPedidoMaxOrderByAggregateInput
    _min?: TransicionEstadoPedidoMinOrderByAggregateInput
    _sum?: TransicionEstadoPedidoSumOrderByAggregateInput
  }

  export type TransicionEstadoPedidoScalarWhereWithAggregatesInput = {
    AND?: TransicionEstadoPedidoScalarWhereWithAggregatesInput | TransicionEstadoPedidoScalarWhereWithAggregatesInput[]
    OR?: TransicionEstadoPedidoScalarWhereWithAggregatesInput[]
    NOT?: TransicionEstadoPedidoScalarWhereWithAggregatesInput | TransicionEstadoPedidoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TransicionEstadoPedido"> | number
    pedido_id?: IntWithAggregatesFilter<"TransicionEstadoPedido"> | number
    estado?: EnumEstadoPedidoWithAggregatesFilter<"TransicionEstadoPedido"> | $Enums.EstadoPedido
    fecha_hora?: DateTimeWithAggregatesFilter<"TransicionEstadoPedido"> | Date | string
    admin_id?: IntWithAggregatesFilter<"TransicionEstadoPedido"> | number
  }

  export type ReporteResenaWhereInput = {
    AND?: ReporteResenaWhereInput | ReporteResenaWhereInput[]
    OR?: ReporteResenaWhereInput[]
    NOT?: ReporteResenaWhereInput | ReporteResenaWhereInput[]
    id?: IntFilter<"ReporteResena"> | number
    resena_id?: IntFilter<"ReporteResena"> | number
    usuario_id?: IntFilter<"ReporteResena"> | number
    comentario?: StringFilter<"ReporteResena"> | string
    resena?: XOR<ResenaScalarRelationFilter, ResenaWhereInput>
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type ReporteResenaOrderByWithRelationInput = {
    id?: SortOrder
    resena_id?: SortOrder
    usuario_id?: SortOrder
    comentario?: SortOrder
    resena?: ResenaOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
    _relevance?: ReporteResenaOrderByRelevanceInput
  }

  export type ReporteResenaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReporteResenaWhereInput | ReporteResenaWhereInput[]
    OR?: ReporteResenaWhereInput[]
    NOT?: ReporteResenaWhereInput | ReporteResenaWhereInput[]
    resena_id?: IntFilter<"ReporteResena"> | number
    usuario_id?: IntFilter<"ReporteResena"> | number
    comentario?: StringFilter<"ReporteResena"> | string
    resena?: XOR<ResenaScalarRelationFilter, ResenaWhereInput>
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type ReporteResenaOrderByWithAggregationInput = {
    id?: SortOrder
    resena_id?: SortOrder
    usuario_id?: SortOrder
    comentario?: SortOrder
    _count?: ReporteResenaCountOrderByAggregateInput
    _avg?: ReporteResenaAvgOrderByAggregateInput
    _max?: ReporteResenaMaxOrderByAggregateInput
    _min?: ReporteResenaMinOrderByAggregateInput
    _sum?: ReporteResenaSumOrderByAggregateInput
  }

  export type ReporteResenaScalarWhereWithAggregatesInput = {
    AND?: ReporteResenaScalarWhereWithAggregatesInput | ReporteResenaScalarWhereWithAggregatesInput[]
    OR?: ReporteResenaScalarWhereWithAggregatesInput[]
    NOT?: ReporteResenaScalarWhereWithAggregatesInput | ReporteResenaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReporteResena"> | number
    resena_id?: IntWithAggregatesFilter<"ReporteResena"> | number
    usuario_id?: IntWithAggregatesFilter<"ReporteResena"> | number
    comentario?: StringWithAggregatesFilter<"ReporteResena"> | string
  }

  export type UsuarioCreateInput = {
    nombre_usuario: string
    correo: string
    contraseña: string
    rol: $Enums.Rol
    ultimo_inicio_sesion?: Date | string | null
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    transiciones_estado?: TransicionEstadoPedidoCreateNestedManyWithoutAdminInput
    reportes_resena?: ReporteResenaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nombre_usuario: string
    correo: string
    contraseña: string
    rol: $Enums.Rol
    ultimo_inicio_sesion?: Date | string | null
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    transiciones_estado?: TransicionEstadoPedidoUncheckedCreateNestedManyWithoutAdminInput
    reportes_resena?: ReporteResenaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contraseña?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ultimo_inicio_sesion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    transiciones_estado?: TransicionEstadoPedidoUpdateManyWithoutAdminNestedInput
    reportes_resena?: ReporteResenaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contraseña?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ultimo_inicio_sesion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    transiciones_estado?: TransicionEstadoPedidoUncheckedUpdateManyWithoutAdminNestedInput
    reportes_resena?: ReporteResenaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nombre_usuario: string
    correo: string
    contraseña: string
    rol: $Enums.Rol
    ultimo_inicio_sesion?: Date | string | null
  }

  export type UsuarioUpdateManyMutationInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contraseña?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ultimo_inicio_sesion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contraseña?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ultimo_inicio_sesion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoriaCreateInput = {
    nombre: string
    descripcion: string
    productos?: ProductoCreateNestedManyWithoutCategoriaInput
    promociones?: PromocionCreateNestedManyWithoutCategoriaInput
    productosPersonalizables?: ProductoPersonalizableCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion: string
    productos?: ProductoUncheckedCreateNestedManyWithoutCategoriaInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutCategoriaInput
    productosPersonalizables?: ProductoPersonalizableUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    productos?: ProductoUpdateManyWithoutCategoriaNestedInput
    promociones?: PromocionUpdateManyWithoutCategoriaNestedInput
    productosPersonalizables?: ProductoPersonalizableUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    productos?: ProductoUncheckedUpdateManyWithoutCategoriaNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutCategoriaNestedInput
    productosPersonalizables?: ProductoPersonalizableUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaCreateManyInput = {
    id?: number
    nombre: string
    descripcion: string
  }

  export type CategoriaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type EtiquetaCreateInput = {
    nombre: string
    productos?: ProductoEtiquetaCreateNestedManyWithoutEtiquetaInput
  }

  export type EtiquetaUncheckedCreateInput = {
    id?: number
    nombre: string
    productos?: ProductoEtiquetaUncheckedCreateNestedManyWithoutEtiquetaInput
  }

  export type EtiquetaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    productos?: ProductoEtiquetaUpdateManyWithoutEtiquetaNestedInput
  }

  export type EtiquetaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    productos?: ProductoEtiquetaUncheckedUpdateManyWithoutEtiquetaNestedInput
  }

  export type EtiquetaCreateManyInput = {
    id?: number
    nombre: string
  }

  export type EtiquetaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type EtiquetaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoCreateInput = {
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    promedio_valoracion?: number
    activo?: boolean
    categoria: CategoriaCreateNestedOneWithoutProductosInput
    imagenes?: ImagenProductoCreateNestedManyWithoutProductoInput
    etiquetas?: ProductoEtiquetaCreateNestedManyWithoutProductoInput
    resenas?: ResenaCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    promociones?: PromocionCreateNestedManyWithoutProductoInput
    productosPersonalizables?: ProductoPersonalizableCreateNestedManyWithoutProducto_baseInput
  }

  export type ProductoUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    categoria_id: number
    promedio_valoracion?: number
    activo?: boolean
    imagenes?: ImagenProductoUncheckedCreateNestedManyWithoutProductoInput
    etiquetas?: ProductoEtiquetaUncheckedCreateNestedManyWithoutProductoInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutProductoInput
    productosPersonalizables?: ProductoPersonalizableUncheckedCreateNestedManyWithoutProducto_baseInput
  }

  export type ProductoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductosNestedInput
    imagenes?: ImagenProductoUpdateManyWithoutProductoNestedInput
    etiquetas?: ProductoEtiquetaUpdateManyWithoutProductoNestedInput
    resenas?: ResenaUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    promociones?: PromocionUpdateManyWithoutProductoNestedInput
    productosPersonalizables?: ProductoPersonalizableUpdateManyWithoutProducto_baseNestedInput
  }

  export type ProductoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    imagenes?: ImagenProductoUncheckedUpdateManyWithoutProductoNestedInput
    etiquetas?: ProductoEtiquetaUncheckedUpdateManyWithoutProductoNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutProductoNestedInput
    productosPersonalizables?: ProductoPersonalizableUncheckedUpdateManyWithoutProducto_baseNestedInput
  }

  export type ProductoCreateManyInput = {
    id?: number
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    categoria_id: number
    promedio_valoracion?: number
    activo?: boolean
  }

  export type ProductoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ImagenProductoCreateInput = {
    url?: string
    producto: ProductoCreateNestedOneWithoutImagenesInput
  }

  export type ImagenProductoUncheckedCreateInput = {
    id?: number
    producto_id: number
    url?: string
  }

  export type ImagenProductoUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    producto?: ProductoUpdateOneRequiredWithoutImagenesNestedInput
  }

  export type ImagenProductoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    producto_id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ImagenProductoCreateManyInput = {
    id?: number
    producto_id: number
    url?: string
  }

  export type ImagenProductoUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ImagenProductoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    producto_id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoEtiquetaCreateInput = {
    producto: ProductoCreateNestedOneWithoutEtiquetasInput
    etiqueta: EtiquetaCreateNestedOneWithoutProductosInput
  }

  export type ProductoEtiquetaUncheckedCreateInput = {
    producto_id: number
    etiqueta_id: number
  }

  export type ProductoEtiquetaUpdateInput = {
    producto?: ProductoUpdateOneRequiredWithoutEtiquetasNestedInput
    etiqueta?: EtiquetaUpdateOneRequiredWithoutProductosNestedInput
  }

  export type ProductoEtiquetaUncheckedUpdateInput = {
    producto_id?: IntFieldUpdateOperationsInput | number
    etiqueta_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProductoEtiquetaCreateManyInput = {
    producto_id: number
    etiqueta_id: number
  }

  export type ProductoEtiquetaUpdateManyMutationInput = {

  }

  export type ProductoEtiquetaUncheckedUpdateManyInput = {
    producto_id?: IntFieldUpdateOperationsInput | number
    etiqueta_id?: IntFieldUpdateOperationsInput | number
  }

  export type ResenaCreateInput = {
    comentario: string
    valoracion: number
    fecha: Date | string
    visible?: boolean
    usuario: UsuarioCreateNestedOneWithoutResenasInput
    producto: ProductoCreateNestedOneWithoutResenasInput
    reportes?: ReporteResenaCreateNestedManyWithoutResenaInput
  }

  export type ResenaUncheckedCreateInput = {
    id?: number
    usuario_id: number
    producto_id: number
    comentario: string
    valoracion: number
    fecha: Date | string
    visible?: boolean
    reportes?: ReporteResenaUncheckedCreateNestedManyWithoutResenaInput
  }

  export type ResenaUpdateInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    valoracion?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUpdateOneRequiredWithoutResenasNestedInput
    producto?: ProductoUpdateOneRequiredWithoutResenasNestedInput
    reportes?: ReporteResenaUpdateManyWithoutResenaNestedInput
  }

  export type ResenaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    producto_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    valoracion?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    reportes?: ReporteResenaUncheckedUpdateManyWithoutResenaNestedInput
  }

  export type ResenaCreateManyInput = {
    id?: number
    usuario_id: number
    producto_id: number
    comentario: string
    valoracion: number
    fecha: Date | string
    visible?: boolean
  }

  export type ResenaUpdateManyMutationInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    valoracion?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResenaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    producto_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    valoracion?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductoPersonalizableCreateInput = {
    nombre: string
    descripcion_general: string
    activo?: boolean
    categoria: CategoriaCreateNestedOneWithoutProductosPersonalizablesInput
    producto_base: ProductoCreateNestedOneWithoutProductosPersonalizablesInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProducto_personalizadoInput
    variantes?: VarianteDetalleCreateNestedManyWithoutProductoPersonalizableInput
  }

  export type ProductoPersonalizableUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion_general: string
    id_categoria: number
    id_producto_base: number
    activo?: boolean
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProducto_personalizadoInput
    variantes?: VarianteDetalleUncheckedCreateNestedManyWithoutProductoPersonalizableInput
  }

  export type ProductoPersonalizableUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion_general?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductosPersonalizablesNestedInput
    producto_base?: ProductoUpdateOneRequiredWithoutProductosPersonalizablesNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProducto_personalizadoNestedInput
    variantes?: VarianteDetalleUpdateManyWithoutProductoPersonalizableNestedInput
  }

  export type ProductoPersonalizableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion_general?: StringFieldUpdateOperationsInput | string
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_producto_base?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProducto_personalizadoNestedInput
    variantes?: VarianteDetalleUncheckedUpdateManyWithoutProductoPersonalizableNestedInput
  }

  export type ProductoPersonalizableCreateManyInput = {
    id?: number
    nombre: string
    descripcion_general: string
    id_categoria: number
    id_producto_base: number
    activo?: boolean
  }

  export type ProductoPersonalizableUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion_general?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductoPersonalizableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion_general?: StringFieldUpdateOperationsInput | string
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_producto_base?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AtributoCreateInput = {
    nombre: string
    tipo: string
    valores?: ValorAtributoCreateNestedManyWithoutAtributoInput
  }

  export type AtributoUncheckedCreateInput = {
    id_atributo?: number
    nombre: string
    tipo: string
    valores?: ValorAtributoUncheckedCreateNestedManyWithoutAtributoInput
  }

  export type AtributoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    valores?: ValorAtributoUpdateManyWithoutAtributoNestedInput
  }

  export type AtributoUncheckedUpdateInput = {
    id_atributo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    valores?: ValorAtributoUncheckedUpdateManyWithoutAtributoNestedInput
  }

  export type AtributoCreateManyInput = {
    id_atributo?: number
    nombre: string
    tipo: string
  }

  export type AtributoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type AtributoUncheckedUpdateManyInput = {
    id_atributo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type ValorAtributoCreateInput = {
    valor: string
    precio_extra?: number
    atributo: AtributoCreateNestedOneWithoutValoresInput
    varianteDetalles?: VarianteDetalleCreateNestedManyWithoutValorInput
  }

  export type ValorAtributoUncheckedCreateInput = {
    id_valor?: number
    id_atributo: number
    valor: string
    precio_extra?: number
    varianteDetalles?: VarianteDetalleUncheckedCreateNestedManyWithoutValorInput
  }

  export type ValorAtributoUpdateInput = {
    valor?: StringFieldUpdateOperationsInput | string
    precio_extra?: FloatFieldUpdateOperationsInput | number
    atributo?: AtributoUpdateOneRequiredWithoutValoresNestedInput
    varianteDetalles?: VarianteDetalleUpdateManyWithoutValorNestedInput
  }

  export type ValorAtributoUncheckedUpdateInput = {
    id_valor?: IntFieldUpdateOperationsInput | number
    id_atributo?: IntFieldUpdateOperationsInput | number
    valor?: StringFieldUpdateOperationsInput | string
    precio_extra?: FloatFieldUpdateOperationsInput | number
    varianteDetalles?: VarianteDetalleUncheckedUpdateManyWithoutValorNestedInput
  }

  export type ValorAtributoCreateManyInput = {
    id_valor?: number
    id_atributo: number
    valor: string
    precio_extra?: number
  }

  export type ValorAtributoUpdateManyMutationInput = {
    valor?: StringFieldUpdateOperationsInput | string
    precio_extra?: FloatFieldUpdateOperationsInput | number
  }

  export type ValorAtributoUncheckedUpdateManyInput = {
    id_valor?: IntFieldUpdateOperationsInput | number
    id_atributo?: IntFieldUpdateOperationsInput | number
    valor?: StringFieldUpdateOperationsInput | string
    precio_extra?: FloatFieldUpdateOperationsInput | number
  }

  export type VarianteDetalleCreateInput = {
    valor: ValorAtributoCreateNestedOneWithoutVarianteDetallesInput
    productoPersonalizable: ProductoPersonalizableCreateNestedOneWithoutVariantesInput
  }

  export type VarianteDetalleUncheckedCreateInput = {
    id_productoPersonalizable: number
    id_valor: number
  }

  export type VarianteDetalleUpdateInput = {
    valor?: ValorAtributoUpdateOneRequiredWithoutVarianteDetallesNestedInput
    productoPersonalizable?: ProductoPersonalizableUpdateOneRequiredWithoutVariantesNestedInput
  }

  export type VarianteDetalleUncheckedUpdateInput = {
    id_productoPersonalizable?: IntFieldUpdateOperationsInput | number
    id_valor?: IntFieldUpdateOperationsInput | number
  }

  export type VarianteDetalleCreateManyInput = {
    id_productoPersonalizable: number
    id_valor: number
  }

  export type VarianteDetalleUpdateManyMutationInput = {

  }

  export type VarianteDetalleUncheckedUpdateManyInput = {
    id_productoPersonalizable?: IntFieldUpdateOperationsInput | number
    id_valor?: IntFieldUpdateOperationsInput | number
  }

  export type PromocionCreateInput = {
    nombre: string
    tipo: $Enums.TipoPromocion
    valor: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    producto?: ProductoCreateNestedOneWithoutPromocionesInput
    categoria?: CategoriaCreateNestedOneWithoutPromocionesInput
    historial?: HistorialPromocionAplicadaCreateNestedManyWithoutPromocionInput
  }

  export type PromocionUncheckedCreateInput = {
    id?: number
    nombre: string
    tipo: $Enums.TipoPromocion
    referencia_id_producto?: number | null
    referencia_id_categoria?: number | null
    valor: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    historial?: HistorialPromocionAplicadaUncheckedCreateNestedManyWithoutPromocionInput
  }

  export type PromocionUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoPromocionFieldUpdateOperationsInput | $Enums.TipoPromocion
    valor?: FloatFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: ProductoUpdateOneWithoutPromocionesNestedInput
    categoria?: CategoriaUpdateOneWithoutPromocionesNestedInput
    historial?: HistorialPromocionAplicadaUpdateManyWithoutPromocionNestedInput
  }

  export type PromocionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoPromocionFieldUpdateOperationsInput | $Enums.TipoPromocion
    referencia_id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    referencia_id_categoria?: NullableIntFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    historial?: HistorialPromocionAplicadaUncheckedUpdateManyWithoutPromocionNestedInput
  }

  export type PromocionCreateManyInput = {
    id?: number
    nombre: string
    tipo: $Enums.TipoPromocion
    referencia_id_producto?: number | null
    referencia_id_categoria?: number | null
    valor: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
  }

  export type PromocionUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoPromocionFieldUpdateOperationsInput | $Enums.TipoPromocion
    valor?: FloatFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromocionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoPromocionFieldUpdateOperationsInput | $Enums.TipoPromocion
    referencia_id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    referencia_id_categoria?: NullableIntFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialPromocionAplicadaCreateInput = {
    fecha: Date | string
    promocion: PromocionCreateNestedOneWithoutHistorialInput
    pedido: PedidoCreateNestedOneWithoutPromociones_aplicadasInput
  }

  export type HistorialPromocionAplicadaUncheckedCreateInput = {
    id?: number
    promocion_id: number
    pedido_id: number
    fecha: Date | string
  }

  export type HistorialPromocionAplicadaUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    promocion?: PromocionUpdateOneRequiredWithoutHistorialNestedInput
    pedido?: PedidoUpdateOneRequiredWithoutPromociones_aplicadasNestedInput
  }

  export type HistorialPromocionAplicadaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    promocion_id?: IntFieldUpdateOperationsInput | number
    pedido_id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialPromocionAplicadaCreateManyInput = {
    id?: number
    promocion_id: number
    pedido_id: number
    fecha: Date | string
  }

  export type HistorialPromocionAplicadaUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialPromocionAplicadaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    promocion_id?: IntFieldUpdateOperationsInput | number
    pedido_id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoCreateInput = {
    fecha_pedido: Date | string
    direccion_envio: string
    metodo_pago: $Enums.MetodoPago
    subtotal: number
    total: number
    impuestos: number
    estado_carrito?: boolean
    usuario: UsuarioCreateNestedOneWithoutPedidosInput
    items?: PedidoItemCreateNestedManyWithoutPedidoInput
    transiciones?: TransicionEstadoPedidoCreateNestedManyWithoutPedidoInput
    promociones_aplicadas?: HistorialPromocionAplicadaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateInput = {
    id?: number
    usuario_id: number
    fecha_pedido: Date | string
    direccion_envio: string
    metodo_pago: $Enums.MetodoPago
    subtotal: number
    total: number
    impuestos: number
    estado_carrito?: boolean
    items?: PedidoItemUncheckedCreateNestedManyWithoutPedidoInput
    transiciones?: TransicionEstadoPedidoUncheckedCreateNestedManyWithoutPedidoInput
    promociones_aplicadas?: HistorialPromocionAplicadaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUpdateInput = {
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion_envio?: StringFieldUpdateOperationsInput | string
    metodo_pago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    subtotal?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    impuestos?: FloatFieldUpdateOperationsInput | number
    estado_carrito?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
    items?: PedidoItemUpdateManyWithoutPedidoNestedInput
    transiciones?: TransicionEstadoPedidoUpdateManyWithoutPedidoNestedInput
    promociones_aplicadas?: HistorialPromocionAplicadaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion_envio?: StringFieldUpdateOperationsInput | string
    metodo_pago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    subtotal?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    impuestos?: FloatFieldUpdateOperationsInput | number
    estado_carrito?: BoolFieldUpdateOperationsInput | boolean
    items?: PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput
    transiciones?: TransicionEstadoPedidoUncheckedUpdateManyWithoutPedidoNestedInput
    promociones_aplicadas?: HistorialPromocionAplicadaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoCreateManyInput = {
    id?: number
    usuario_id: number
    fecha_pedido: Date | string
    direccion_envio: string
    metodo_pago: $Enums.MetodoPago
    subtotal: number
    total: number
    impuestos: number
    estado_carrito?: boolean
  }

  export type PedidoUpdateManyMutationInput = {
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion_envio?: StringFieldUpdateOperationsInput | string
    metodo_pago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    subtotal?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    impuestos?: FloatFieldUpdateOperationsInput | number
    estado_carrito?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PedidoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion_envio?: StringFieldUpdateOperationsInput | string
    metodo_pago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    subtotal?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    impuestos?: FloatFieldUpdateOperationsInput | number
    estado_carrito?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PedidoItemCreateInput = {
    cantidad: number
    pedido: PedidoCreateNestedOneWithoutItemsInput
    producto: ProductoCreateNestedOneWithoutPedidoItemsInput
    producto_personalizado?: ProductoPersonalizableCreateNestedOneWithoutPedidoItemsInput
  }

  export type PedidoItemUncheckedCreateInput = {
    pedido_id: number
    producto_id: number
    cantidad: number
    producto_personalizado_id?: number | null
  }

  export type PedidoItemUpdateInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    pedido?: PedidoUpdateOneRequiredWithoutItemsNestedInput
    producto?: ProductoUpdateOneRequiredWithoutPedidoItemsNestedInput
    producto_personalizado?: ProductoPersonalizableUpdateOneWithoutPedidoItemsNestedInput
  }

  export type PedidoItemUncheckedUpdateInput = {
    pedido_id?: IntFieldUpdateOperationsInput | number
    producto_id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    producto_personalizado_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PedidoItemCreateManyInput = {
    pedido_id: number
    producto_id: number
    cantidad: number
    producto_personalizado_id?: number | null
  }

  export type PedidoItemUpdateManyMutationInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoItemUncheckedUpdateManyInput = {
    pedido_id?: IntFieldUpdateOperationsInput | number
    producto_id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    producto_personalizado_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransicionEstadoPedidoCreateInput = {
    estado: $Enums.EstadoPedido
    fecha_hora: Date | string
    pedido: PedidoCreateNestedOneWithoutTransicionesInput
    admin: UsuarioCreateNestedOneWithoutTransiciones_estadoInput
  }

  export type TransicionEstadoPedidoUncheckedCreateInput = {
    id?: number
    pedido_id: number
    estado: $Enums.EstadoPedido
    fecha_hora: Date | string
    admin_id: number
  }

  export type TransicionEstadoPedidoUpdateInput = {
    estado?: EnumEstadoPedidoFieldUpdateOperationsInput | $Enums.EstadoPedido
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutTransicionesNestedInput
    admin?: UsuarioUpdateOneRequiredWithoutTransiciones_estadoNestedInput
  }

  export type TransicionEstadoPedidoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedido_id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoPedidoFieldUpdateOperationsInput | $Enums.EstadoPedido
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_id?: IntFieldUpdateOperationsInput | number
  }

  export type TransicionEstadoPedidoCreateManyInput = {
    id?: number
    pedido_id: number
    estado: $Enums.EstadoPedido
    fecha_hora: Date | string
    admin_id: number
  }

  export type TransicionEstadoPedidoUpdateManyMutationInput = {
    estado?: EnumEstadoPedidoFieldUpdateOperationsInput | $Enums.EstadoPedido
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransicionEstadoPedidoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedido_id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoPedidoFieldUpdateOperationsInput | $Enums.EstadoPedido
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_id?: IntFieldUpdateOperationsInput | number
  }

  export type ReporteResenaCreateInput = {
    comentario: string
    resena: ResenaCreateNestedOneWithoutReportesInput
    usuario: UsuarioCreateNestedOneWithoutReportes_resenaInput
  }

  export type ReporteResenaUncheckedCreateInput = {
    id?: number
    resena_id: number
    usuario_id: number
    comentario: string
  }

  export type ReporteResenaUpdateInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    resena?: ResenaUpdateOneRequiredWithoutReportesNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutReportes_resenaNestedInput
  }

  export type ReporteResenaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    resena_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
  }

  export type ReporteResenaCreateManyInput = {
    id?: number
    resena_id: number
    usuario_id: number
    comentario: string
  }

  export type ReporteResenaUpdateManyMutationInput = {
    comentario?: StringFieldUpdateOperationsInput | string
  }

  export type ReporteResenaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    resena_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ResenaListRelationFilter = {
    every?: ResenaWhereInput
    some?: ResenaWhereInput
    none?: ResenaWhereInput
  }

  export type PedidoListRelationFilter = {
    every?: PedidoWhereInput
    some?: PedidoWhereInput
    none?: PedidoWhereInput
  }

  export type TransicionEstadoPedidoListRelationFilter = {
    every?: TransicionEstadoPedidoWhereInput
    some?: TransicionEstadoPedidoWhereInput
    none?: TransicionEstadoPedidoWhereInput
  }

  export type ReporteResenaListRelationFilter = {
    every?: ReporteResenaWhereInput
    some?: ReporteResenaWhereInput
    none?: ReporteResenaWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ResenaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransicionEstadoPedidoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReporteResenaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioOrderByRelevanceInput = {
    fields: UsuarioOrderByRelevanceFieldEnum | UsuarioOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre_usuario?: SortOrder
    correo?: SortOrder
    contraseña?: SortOrder
    rol?: SortOrder
    ultimo_inicio_sesion?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre_usuario?: SortOrder
    correo?: SortOrder
    contraseña?: SortOrder
    rol?: SortOrder
    ultimo_inicio_sesion?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre_usuario?: SortOrder
    correo?: SortOrder
    contraseña?: SortOrder
    rol?: SortOrder
    ultimo_inicio_sesion?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ProductoListRelationFilter = {
    every?: ProductoWhereInput
    some?: ProductoWhereInput
    none?: ProductoWhereInput
  }

  export type PromocionListRelationFilter = {
    every?: PromocionWhereInput
    some?: PromocionWhereInput
    none?: PromocionWhereInput
  }

  export type ProductoPersonalizableListRelationFilter = {
    every?: ProductoPersonalizableWhereInput
    some?: ProductoPersonalizableWhereInput
    none?: ProductoPersonalizableWhereInput
  }

  export type ProductoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromocionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductoPersonalizableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoriaOrderByRelevanceInput = {
    fields: CategoriaOrderByRelevanceFieldEnum | CategoriaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CategoriaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type CategoriaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type CategoriaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type CategoriaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductoEtiquetaListRelationFilter = {
    every?: ProductoEtiquetaWhereInput
    some?: ProductoEtiquetaWhereInput
    none?: ProductoEtiquetaWhereInput
  }

  export type ProductoEtiquetaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EtiquetaOrderByRelevanceInput = {
    fields: EtiquetaOrderByRelevanceFieldEnum | EtiquetaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EtiquetaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type EtiquetaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EtiquetaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type EtiquetaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type EtiquetaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CategoriaScalarRelationFilter = {
    is?: CategoriaWhereInput
    isNot?: CategoriaWhereInput
  }

  export type ImagenProductoListRelationFilter = {
    every?: ImagenProductoWhereInput
    some?: ImagenProductoWhereInput
    none?: ImagenProductoWhereInput
  }

  export type PedidoItemListRelationFilter = {
    every?: PedidoItemWhereInput
    some?: PedidoItemWhereInput
    none?: PedidoItemWhereInput
  }

  export type ImagenProductoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductoOrderByRelevanceInput = {
    fields: ProductoOrderByRelevanceFieldEnum | ProductoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio_base?: SortOrder
    stock?: SortOrder
    categoria_id?: SortOrder
    promedio_valoracion?: SortOrder
    activo?: SortOrder
  }

  export type ProductoAvgOrderByAggregateInput = {
    id?: SortOrder
    precio_base?: SortOrder
    stock?: SortOrder
    categoria_id?: SortOrder
    promedio_valoracion?: SortOrder
  }

  export type ProductoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio_base?: SortOrder
    stock?: SortOrder
    categoria_id?: SortOrder
    promedio_valoracion?: SortOrder
    activo?: SortOrder
  }

  export type ProductoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio_base?: SortOrder
    stock?: SortOrder
    categoria_id?: SortOrder
    promedio_valoracion?: SortOrder
    activo?: SortOrder
  }

  export type ProductoSumOrderByAggregateInput = {
    id?: SortOrder
    precio_base?: SortOrder
    stock?: SortOrder
    categoria_id?: SortOrder
    promedio_valoracion?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ProductoScalarRelationFilter = {
    is?: ProductoWhereInput
    isNot?: ProductoWhereInput
  }

  export type ImagenProductoOrderByRelevanceInput = {
    fields: ImagenProductoOrderByRelevanceFieldEnum | ImagenProductoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ImagenProductoCountOrderByAggregateInput = {
    id?: SortOrder
    producto_id?: SortOrder
    url?: SortOrder
  }

  export type ImagenProductoAvgOrderByAggregateInput = {
    id?: SortOrder
    producto_id?: SortOrder
  }

  export type ImagenProductoMaxOrderByAggregateInput = {
    id?: SortOrder
    producto_id?: SortOrder
    url?: SortOrder
  }

  export type ImagenProductoMinOrderByAggregateInput = {
    id?: SortOrder
    producto_id?: SortOrder
    url?: SortOrder
  }

  export type ImagenProductoSumOrderByAggregateInput = {
    id?: SortOrder
    producto_id?: SortOrder
  }

  export type EtiquetaScalarRelationFilter = {
    is?: EtiquetaWhereInput
    isNot?: EtiquetaWhereInput
  }

  export type ProductoEtiquetaProducto_idEtiqueta_idCompoundUniqueInput = {
    producto_id: number
    etiqueta_id: number
  }

  export type ProductoEtiquetaCountOrderByAggregateInput = {
    producto_id?: SortOrder
    etiqueta_id?: SortOrder
  }

  export type ProductoEtiquetaAvgOrderByAggregateInput = {
    producto_id?: SortOrder
    etiqueta_id?: SortOrder
  }

  export type ProductoEtiquetaMaxOrderByAggregateInput = {
    producto_id?: SortOrder
    etiqueta_id?: SortOrder
  }

  export type ProductoEtiquetaMinOrderByAggregateInput = {
    producto_id?: SortOrder
    etiqueta_id?: SortOrder
  }

  export type ProductoEtiquetaSumOrderByAggregateInput = {
    producto_id?: SortOrder
    etiqueta_id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsuarioScalarRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type ResenaOrderByRelevanceInput = {
    fields: ResenaOrderByRelevanceFieldEnum | ResenaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ResenaCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    producto_id?: SortOrder
    comentario?: SortOrder
    valoracion?: SortOrder
    fecha?: SortOrder
    visible?: SortOrder
  }

  export type ResenaAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    producto_id?: SortOrder
    valoracion?: SortOrder
  }

  export type ResenaMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    producto_id?: SortOrder
    comentario?: SortOrder
    valoracion?: SortOrder
    fecha?: SortOrder
    visible?: SortOrder
  }

  export type ResenaMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    producto_id?: SortOrder
    comentario?: SortOrder
    valoracion?: SortOrder
    fecha?: SortOrder
    visible?: SortOrder
  }

  export type ResenaSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    producto_id?: SortOrder
    valoracion?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type VarianteDetalleListRelationFilter = {
    every?: VarianteDetalleWhereInput
    some?: VarianteDetalleWhereInput
    none?: VarianteDetalleWhereInput
  }

  export type VarianteDetalleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductoPersonalizableOrderByRelevanceInput = {
    fields: ProductoPersonalizableOrderByRelevanceFieldEnum | ProductoPersonalizableOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductoPersonalizableCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion_general?: SortOrder
    id_categoria?: SortOrder
    id_producto_base?: SortOrder
    activo?: SortOrder
  }

  export type ProductoPersonalizableAvgOrderByAggregateInput = {
    id?: SortOrder
    id_categoria?: SortOrder
    id_producto_base?: SortOrder
  }

  export type ProductoPersonalizableMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion_general?: SortOrder
    id_categoria?: SortOrder
    id_producto_base?: SortOrder
    activo?: SortOrder
  }

  export type ProductoPersonalizableMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion_general?: SortOrder
    id_categoria?: SortOrder
    id_producto_base?: SortOrder
    activo?: SortOrder
  }

  export type ProductoPersonalizableSumOrderByAggregateInput = {
    id?: SortOrder
    id_categoria?: SortOrder
    id_producto_base?: SortOrder
  }

  export type ValorAtributoListRelationFilter = {
    every?: ValorAtributoWhereInput
    some?: ValorAtributoWhereInput
    none?: ValorAtributoWhereInput
  }

  export type ValorAtributoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AtributoOrderByRelevanceInput = {
    fields: AtributoOrderByRelevanceFieldEnum | AtributoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AtributoCountOrderByAggregateInput = {
    id_atributo?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
  }

  export type AtributoAvgOrderByAggregateInput = {
    id_atributo?: SortOrder
  }

  export type AtributoMaxOrderByAggregateInput = {
    id_atributo?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
  }

  export type AtributoMinOrderByAggregateInput = {
    id_atributo?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
  }

  export type AtributoSumOrderByAggregateInput = {
    id_atributo?: SortOrder
  }

  export type AtributoScalarRelationFilter = {
    is?: AtributoWhereInput
    isNot?: AtributoWhereInput
  }

  export type ValorAtributoOrderByRelevanceInput = {
    fields: ValorAtributoOrderByRelevanceFieldEnum | ValorAtributoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ValorAtributoCountOrderByAggregateInput = {
    id_valor?: SortOrder
    id_atributo?: SortOrder
    valor?: SortOrder
    precio_extra?: SortOrder
  }

  export type ValorAtributoAvgOrderByAggregateInput = {
    id_valor?: SortOrder
    id_atributo?: SortOrder
    precio_extra?: SortOrder
  }

  export type ValorAtributoMaxOrderByAggregateInput = {
    id_valor?: SortOrder
    id_atributo?: SortOrder
    valor?: SortOrder
    precio_extra?: SortOrder
  }

  export type ValorAtributoMinOrderByAggregateInput = {
    id_valor?: SortOrder
    id_atributo?: SortOrder
    valor?: SortOrder
    precio_extra?: SortOrder
  }

  export type ValorAtributoSumOrderByAggregateInput = {
    id_valor?: SortOrder
    id_atributo?: SortOrder
    precio_extra?: SortOrder
  }

  export type ValorAtributoScalarRelationFilter = {
    is?: ValorAtributoWhereInput
    isNot?: ValorAtributoWhereInput
  }

  export type ProductoPersonalizableScalarRelationFilter = {
    is?: ProductoPersonalizableWhereInput
    isNot?: ProductoPersonalizableWhereInput
  }

  export type VarianteDetalleId_productoPersonalizableId_valorCompoundUniqueInput = {
    id_productoPersonalizable: number
    id_valor: number
  }

  export type VarianteDetalleCountOrderByAggregateInput = {
    id_productoPersonalizable?: SortOrder
    id_valor?: SortOrder
  }

  export type VarianteDetalleAvgOrderByAggregateInput = {
    id_productoPersonalizable?: SortOrder
    id_valor?: SortOrder
  }

  export type VarianteDetalleMaxOrderByAggregateInput = {
    id_productoPersonalizable?: SortOrder
    id_valor?: SortOrder
  }

  export type VarianteDetalleMinOrderByAggregateInput = {
    id_productoPersonalizable?: SortOrder
    id_valor?: SortOrder
  }

  export type VarianteDetalleSumOrderByAggregateInput = {
    id_productoPersonalizable?: SortOrder
    id_valor?: SortOrder
  }

  export type EnumTipoPromocionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoPromocion | EnumTipoPromocionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoPromocion[]
    notIn?: $Enums.TipoPromocion[]
    not?: NestedEnumTipoPromocionFilter<$PrismaModel> | $Enums.TipoPromocion
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProductoNullableScalarRelationFilter = {
    is?: ProductoWhereInput | null
    isNot?: ProductoWhereInput | null
  }

  export type CategoriaNullableScalarRelationFilter = {
    is?: CategoriaWhereInput | null
    isNot?: CategoriaWhereInput | null
  }

  export type HistorialPromocionAplicadaListRelationFilter = {
    every?: HistorialPromocionAplicadaWhereInput
    some?: HistorialPromocionAplicadaWhereInput
    none?: HistorialPromocionAplicadaWhereInput
  }

  export type HistorialPromocionAplicadaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromocionOrderByRelevanceInput = {
    fields: PromocionOrderByRelevanceFieldEnum | PromocionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PromocionCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    referencia_id_producto?: SortOrder
    referencia_id_categoria?: SortOrder
    valor?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
  }

  export type PromocionAvgOrderByAggregateInput = {
    id?: SortOrder
    referencia_id_producto?: SortOrder
    referencia_id_categoria?: SortOrder
    valor?: SortOrder
  }

  export type PromocionMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    referencia_id_producto?: SortOrder
    referencia_id_categoria?: SortOrder
    valor?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
  }

  export type PromocionMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    referencia_id_producto?: SortOrder
    referencia_id_categoria?: SortOrder
    valor?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
  }

  export type PromocionSumOrderByAggregateInput = {
    id?: SortOrder
    referencia_id_producto?: SortOrder
    referencia_id_categoria?: SortOrder
    valor?: SortOrder
  }

  export type EnumTipoPromocionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoPromocion | EnumTipoPromocionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoPromocion[]
    notIn?: $Enums.TipoPromocion[]
    not?: NestedEnumTipoPromocionWithAggregatesFilter<$PrismaModel> | $Enums.TipoPromocion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoPromocionFilter<$PrismaModel>
    _max?: NestedEnumTipoPromocionFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PromocionScalarRelationFilter = {
    is?: PromocionWhereInput
    isNot?: PromocionWhereInput
  }

  export type PedidoScalarRelationFilter = {
    is?: PedidoWhereInput
    isNot?: PedidoWhereInput
  }

  export type HistorialPromocionAplicadaCountOrderByAggregateInput = {
    id?: SortOrder
    promocion_id?: SortOrder
    pedido_id?: SortOrder
    fecha?: SortOrder
  }

  export type HistorialPromocionAplicadaAvgOrderByAggregateInput = {
    id?: SortOrder
    promocion_id?: SortOrder
    pedido_id?: SortOrder
  }

  export type HistorialPromocionAplicadaMaxOrderByAggregateInput = {
    id?: SortOrder
    promocion_id?: SortOrder
    pedido_id?: SortOrder
    fecha?: SortOrder
  }

  export type HistorialPromocionAplicadaMinOrderByAggregateInput = {
    id?: SortOrder
    promocion_id?: SortOrder
    pedido_id?: SortOrder
    fecha?: SortOrder
  }

  export type HistorialPromocionAplicadaSumOrderByAggregateInput = {
    id?: SortOrder
    promocion_id?: SortOrder
    pedido_id?: SortOrder
  }

  export type EnumMetodoPagoFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoPago | EnumMetodoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoPago[]
    notIn?: $Enums.MetodoPago[]
    not?: NestedEnumMetodoPagoFilter<$PrismaModel> | $Enums.MetodoPago
  }

  export type PedidoOrderByRelevanceInput = {
    fields: PedidoOrderByRelevanceFieldEnum | PedidoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PedidoCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    fecha_pedido?: SortOrder
    direccion_envio?: SortOrder
    metodo_pago?: SortOrder
    subtotal?: SortOrder
    total?: SortOrder
    impuestos?: SortOrder
    estado_carrito?: SortOrder
  }

  export type PedidoAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    subtotal?: SortOrder
    total?: SortOrder
    impuestos?: SortOrder
  }

  export type PedidoMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    fecha_pedido?: SortOrder
    direccion_envio?: SortOrder
    metodo_pago?: SortOrder
    subtotal?: SortOrder
    total?: SortOrder
    impuestos?: SortOrder
    estado_carrito?: SortOrder
  }

  export type PedidoMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    fecha_pedido?: SortOrder
    direccion_envio?: SortOrder
    metodo_pago?: SortOrder
    subtotal?: SortOrder
    total?: SortOrder
    impuestos?: SortOrder
    estado_carrito?: SortOrder
  }

  export type PedidoSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    subtotal?: SortOrder
    total?: SortOrder
    impuestos?: SortOrder
  }

  export type EnumMetodoPagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoPago | EnumMetodoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoPago[]
    notIn?: $Enums.MetodoPago[]
    not?: NestedEnumMetodoPagoWithAggregatesFilter<$PrismaModel> | $Enums.MetodoPago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetodoPagoFilter<$PrismaModel>
    _max?: NestedEnumMetodoPagoFilter<$PrismaModel>
  }

  export type ProductoPersonalizableNullableScalarRelationFilter = {
    is?: ProductoPersonalizableWhereInput | null
    isNot?: ProductoPersonalizableWhereInput | null
  }

  export type PedidoItemPedido_idProducto_idCompoundUniqueInput = {
    pedido_id: number
    producto_id: number
  }

  export type PedidoItemCountOrderByAggregateInput = {
    pedido_id?: SortOrder
    producto_id?: SortOrder
    cantidad?: SortOrder
    producto_personalizado_id?: SortOrder
  }

  export type PedidoItemAvgOrderByAggregateInput = {
    pedido_id?: SortOrder
    producto_id?: SortOrder
    cantidad?: SortOrder
    producto_personalizado_id?: SortOrder
  }

  export type PedidoItemMaxOrderByAggregateInput = {
    pedido_id?: SortOrder
    producto_id?: SortOrder
    cantidad?: SortOrder
    producto_personalizado_id?: SortOrder
  }

  export type PedidoItemMinOrderByAggregateInput = {
    pedido_id?: SortOrder
    producto_id?: SortOrder
    cantidad?: SortOrder
    producto_personalizado_id?: SortOrder
  }

  export type PedidoItemSumOrderByAggregateInput = {
    pedido_id?: SortOrder
    producto_id?: SortOrder
    cantidad?: SortOrder
    producto_personalizado_id?: SortOrder
  }

  export type EnumEstadoPedidoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPedido | EnumEstadoPedidoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPedido[]
    notIn?: $Enums.EstadoPedido[]
    not?: NestedEnumEstadoPedidoFilter<$PrismaModel> | $Enums.EstadoPedido
  }

  export type TransicionEstadoPedidoCountOrderByAggregateInput = {
    id?: SortOrder
    pedido_id?: SortOrder
    estado?: SortOrder
    fecha_hora?: SortOrder
    admin_id?: SortOrder
  }

  export type TransicionEstadoPedidoAvgOrderByAggregateInput = {
    id?: SortOrder
    pedido_id?: SortOrder
    admin_id?: SortOrder
  }

  export type TransicionEstadoPedidoMaxOrderByAggregateInput = {
    id?: SortOrder
    pedido_id?: SortOrder
    estado?: SortOrder
    fecha_hora?: SortOrder
    admin_id?: SortOrder
  }

  export type TransicionEstadoPedidoMinOrderByAggregateInput = {
    id?: SortOrder
    pedido_id?: SortOrder
    estado?: SortOrder
    fecha_hora?: SortOrder
    admin_id?: SortOrder
  }

  export type TransicionEstadoPedidoSumOrderByAggregateInput = {
    id?: SortOrder
    pedido_id?: SortOrder
    admin_id?: SortOrder
  }

  export type EnumEstadoPedidoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPedido | EnumEstadoPedidoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPedido[]
    notIn?: $Enums.EstadoPedido[]
    not?: NestedEnumEstadoPedidoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPedido
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPedidoFilter<$PrismaModel>
    _max?: NestedEnumEstadoPedidoFilter<$PrismaModel>
  }

  export type ResenaScalarRelationFilter = {
    is?: ResenaWhereInput
    isNot?: ResenaWhereInput
  }

  export type ReporteResenaOrderByRelevanceInput = {
    fields: ReporteResenaOrderByRelevanceFieldEnum | ReporteResenaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReporteResenaCountOrderByAggregateInput = {
    id?: SortOrder
    resena_id?: SortOrder
    usuario_id?: SortOrder
    comentario?: SortOrder
  }

  export type ReporteResenaAvgOrderByAggregateInput = {
    id?: SortOrder
    resena_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type ReporteResenaMaxOrderByAggregateInput = {
    id?: SortOrder
    resena_id?: SortOrder
    usuario_id?: SortOrder
    comentario?: SortOrder
  }

  export type ReporteResenaMinOrderByAggregateInput = {
    id?: SortOrder
    resena_id?: SortOrder
    usuario_id?: SortOrder
    comentario?: SortOrder
  }

  export type ReporteResenaSumOrderByAggregateInput = {
    id?: SortOrder
    resena_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type ResenaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput> | ResenaCreateWithoutUsuarioInput[] | ResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutUsuarioInput | ResenaCreateOrConnectWithoutUsuarioInput[]
    createMany?: ResenaCreateManyUsuarioInputEnvelope
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
  }

  export type PedidoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput> | PedidoCreateWithoutUsuarioInput[] | PedidoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutUsuarioInput | PedidoCreateOrConnectWithoutUsuarioInput[]
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type TransicionEstadoPedidoCreateNestedManyWithoutAdminInput = {
    create?: XOR<TransicionEstadoPedidoCreateWithoutAdminInput, TransicionEstadoPedidoUncheckedCreateWithoutAdminInput> | TransicionEstadoPedidoCreateWithoutAdminInput[] | TransicionEstadoPedidoUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: TransicionEstadoPedidoCreateOrConnectWithoutAdminInput | TransicionEstadoPedidoCreateOrConnectWithoutAdminInput[]
    createMany?: TransicionEstadoPedidoCreateManyAdminInputEnvelope
    connect?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
  }

  export type ReporteResenaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ReporteResenaCreateWithoutUsuarioInput, ReporteResenaUncheckedCreateWithoutUsuarioInput> | ReporteResenaCreateWithoutUsuarioInput[] | ReporteResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ReporteResenaCreateOrConnectWithoutUsuarioInput | ReporteResenaCreateOrConnectWithoutUsuarioInput[]
    createMany?: ReporteResenaCreateManyUsuarioInputEnvelope
    connect?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
  }

  export type ResenaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput> | ResenaCreateWithoutUsuarioInput[] | ResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutUsuarioInput | ResenaCreateOrConnectWithoutUsuarioInput[]
    createMany?: ResenaCreateManyUsuarioInputEnvelope
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
  }

  export type PedidoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput> | PedidoCreateWithoutUsuarioInput[] | PedidoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutUsuarioInput | PedidoCreateOrConnectWithoutUsuarioInput[]
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type TransicionEstadoPedidoUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<TransicionEstadoPedidoCreateWithoutAdminInput, TransicionEstadoPedidoUncheckedCreateWithoutAdminInput> | TransicionEstadoPedidoCreateWithoutAdminInput[] | TransicionEstadoPedidoUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: TransicionEstadoPedidoCreateOrConnectWithoutAdminInput | TransicionEstadoPedidoCreateOrConnectWithoutAdminInput[]
    createMany?: TransicionEstadoPedidoCreateManyAdminInputEnvelope
    connect?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
  }

  export type ReporteResenaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ReporteResenaCreateWithoutUsuarioInput, ReporteResenaUncheckedCreateWithoutUsuarioInput> | ReporteResenaCreateWithoutUsuarioInput[] | ReporteResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ReporteResenaCreateOrConnectWithoutUsuarioInput | ReporteResenaCreateOrConnectWithoutUsuarioInput[]
    createMany?: ReporteResenaCreateManyUsuarioInputEnvelope
    connect?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRolFieldUpdateOperationsInput = {
    set?: $Enums.Rol
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ResenaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput> | ResenaCreateWithoutUsuarioInput[] | ResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutUsuarioInput | ResenaCreateOrConnectWithoutUsuarioInput[]
    upsert?: ResenaUpsertWithWhereUniqueWithoutUsuarioInput | ResenaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ResenaCreateManyUsuarioInputEnvelope
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    update?: ResenaUpdateWithWhereUniqueWithoutUsuarioInput | ResenaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ResenaUpdateManyWithWhereWithoutUsuarioInput | ResenaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
  }

  export type PedidoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput> | PedidoCreateWithoutUsuarioInput[] | PedidoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutUsuarioInput | PedidoCreateOrConnectWithoutUsuarioInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutUsuarioInput | PedidoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutUsuarioInput | PedidoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutUsuarioInput | PedidoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type TransicionEstadoPedidoUpdateManyWithoutAdminNestedInput = {
    create?: XOR<TransicionEstadoPedidoCreateWithoutAdminInput, TransicionEstadoPedidoUncheckedCreateWithoutAdminInput> | TransicionEstadoPedidoCreateWithoutAdminInput[] | TransicionEstadoPedidoUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: TransicionEstadoPedidoCreateOrConnectWithoutAdminInput | TransicionEstadoPedidoCreateOrConnectWithoutAdminInput[]
    upsert?: TransicionEstadoPedidoUpsertWithWhereUniqueWithoutAdminInput | TransicionEstadoPedidoUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: TransicionEstadoPedidoCreateManyAdminInputEnvelope
    set?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    disconnect?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    delete?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    connect?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    update?: TransicionEstadoPedidoUpdateWithWhereUniqueWithoutAdminInput | TransicionEstadoPedidoUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: TransicionEstadoPedidoUpdateManyWithWhereWithoutAdminInput | TransicionEstadoPedidoUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: TransicionEstadoPedidoScalarWhereInput | TransicionEstadoPedidoScalarWhereInput[]
  }

  export type ReporteResenaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ReporteResenaCreateWithoutUsuarioInput, ReporteResenaUncheckedCreateWithoutUsuarioInput> | ReporteResenaCreateWithoutUsuarioInput[] | ReporteResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ReporteResenaCreateOrConnectWithoutUsuarioInput | ReporteResenaCreateOrConnectWithoutUsuarioInput[]
    upsert?: ReporteResenaUpsertWithWhereUniqueWithoutUsuarioInput | ReporteResenaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ReporteResenaCreateManyUsuarioInputEnvelope
    set?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    disconnect?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    delete?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    connect?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    update?: ReporteResenaUpdateWithWhereUniqueWithoutUsuarioInput | ReporteResenaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ReporteResenaUpdateManyWithWhereWithoutUsuarioInput | ReporteResenaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ReporteResenaScalarWhereInput | ReporteResenaScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ResenaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput> | ResenaCreateWithoutUsuarioInput[] | ResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutUsuarioInput | ResenaCreateOrConnectWithoutUsuarioInput[]
    upsert?: ResenaUpsertWithWhereUniqueWithoutUsuarioInput | ResenaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ResenaCreateManyUsuarioInputEnvelope
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    update?: ResenaUpdateWithWhereUniqueWithoutUsuarioInput | ResenaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ResenaUpdateManyWithWhereWithoutUsuarioInput | ResenaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
  }

  export type PedidoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput> | PedidoCreateWithoutUsuarioInput[] | PedidoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutUsuarioInput | PedidoCreateOrConnectWithoutUsuarioInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutUsuarioInput | PedidoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutUsuarioInput | PedidoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutUsuarioInput | PedidoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type TransicionEstadoPedidoUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<TransicionEstadoPedidoCreateWithoutAdminInput, TransicionEstadoPedidoUncheckedCreateWithoutAdminInput> | TransicionEstadoPedidoCreateWithoutAdminInput[] | TransicionEstadoPedidoUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: TransicionEstadoPedidoCreateOrConnectWithoutAdminInput | TransicionEstadoPedidoCreateOrConnectWithoutAdminInput[]
    upsert?: TransicionEstadoPedidoUpsertWithWhereUniqueWithoutAdminInput | TransicionEstadoPedidoUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: TransicionEstadoPedidoCreateManyAdminInputEnvelope
    set?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    disconnect?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    delete?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    connect?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    update?: TransicionEstadoPedidoUpdateWithWhereUniqueWithoutAdminInput | TransicionEstadoPedidoUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: TransicionEstadoPedidoUpdateManyWithWhereWithoutAdminInput | TransicionEstadoPedidoUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: TransicionEstadoPedidoScalarWhereInput | TransicionEstadoPedidoScalarWhereInput[]
  }

  export type ReporteResenaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ReporteResenaCreateWithoutUsuarioInput, ReporteResenaUncheckedCreateWithoutUsuarioInput> | ReporteResenaCreateWithoutUsuarioInput[] | ReporteResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ReporteResenaCreateOrConnectWithoutUsuarioInput | ReporteResenaCreateOrConnectWithoutUsuarioInput[]
    upsert?: ReporteResenaUpsertWithWhereUniqueWithoutUsuarioInput | ReporteResenaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ReporteResenaCreateManyUsuarioInputEnvelope
    set?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    disconnect?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    delete?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    connect?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    update?: ReporteResenaUpdateWithWhereUniqueWithoutUsuarioInput | ReporteResenaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ReporteResenaUpdateManyWithWhereWithoutUsuarioInput | ReporteResenaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ReporteResenaScalarWhereInput | ReporteResenaScalarWhereInput[]
  }

  export type ProductoCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<ProductoCreateWithoutCategoriaInput, ProductoUncheckedCreateWithoutCategoriaInput> | ProductoCreateWithoutCategoriaInput[] | ProductoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutCategoriaInput | ProductoCreateOrConnectWithoutCategoriaInput[]
    createMany?: ProductoCreateManyCategoriaInputEnvelope
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
  }

  export type PromocionCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<PromocionCreateWithoutCategoriaInput, PromocionUncheckedCreateWithoutCategoriaInput> | PromocionCreateWithoutCategoriaInput[] | PromocionUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: PromocionCreateOrConnectWithoutCategoriaInput | PromocionCreateOrConnectWithoutCategoriaInput[]
    createMany?: PromocionCreateManyCategoriaInputEnvelope
    connect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
  }

  export type ProductoPersonalizableCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<ProductoPersonalizableCreateWithoutCategoriaInput, ProductoPersonalizableUncheckedCreateWithoutCategoriaInput> | ProductoPersonalizableCreateWithoutCategoriaInput[] | ProductoPersonalizableUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProductoPersonalizableCreateOrConnectWithoutCategoriaInput | ProductoPersonalizableCreateOrConnectWithoutCategoriaInput[]
    createMany?: ProductoPersonalizableCreateManyCategoriaInputEnvelope
    connect?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
  }

  export type ProductoUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<ProductoCreateWithoutCategoriaInput, ProductoUncheckedCreateWithoutCategoriaInput> | ProductoCreateWithoutCategoriaInput[] | ProductoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutCategoriaInput | ProductoCreateOrConnectWithoutCategoriaInput[]
    createMany?: ProductoCreateManyCategoriaInputEnvelope
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
  }

  export type PromocionUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<PromocionCreateWithoutCategoriaInput, PromocionUncheckedCreateWithoutCategoriaInput> | PromocionCreateWithoutCategoriaInput[] | PromocionUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: PromocionCreateOrConnectWithoutCategoriaInput | PromocionCreateOrConnectWithoutCategoriaInput[]
    createMany?: PromocionCreateManyCategoriaInputEnvelope
    connect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
  }

  export type ProductoPersonalizableUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<ProductoPersonalizableCreateWithoutCategoriaInput, ProductoPersonalizableUncheckedCreateWithoutCategoriaInput> | ProductoPersonalizableCreateWithoutCategoriaInput[] | ProductoPersonalizableUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProductoPersonalizableCreateOrConnectWithoutCategoriaInput | ProductoPersonalizableCreateOrConnectWithoutCategoriaInput[]
    createMany?: ProductoPersonalizableCreateManyCategoriaInputEnvelope
    connect?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
  }

  export type ProductoUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<ProductoCreateWithoutCategoriaInput, ProductoUncheckedCreateWithoutCategoriaInput> | ProductoCreateWithoutCategoriaInput[] | ProductoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutCategoriaInput | ProductoCreateOrConnectWithoutCategoriaInput[]
    upsert?: ProductoUpsertWithWhereUniqueWithoutCategoriaInput | ProductoUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: ProductoCreateManyCategoriaInputEnvelope
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    update?: ProductoUpdateWithWhereUniqueWithoutCategoriaInput | ProductoUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: ProductoUpdateManyWithWhereWithoutCategoriaInput | ProductoUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
  }

  export type PromocionUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<PromocionCreateWithoutCategoriaInput, PromocionUncheckedCreateWithoutCategoriaInput> | PromocionCreateWithoutCategoriaInput[] | PromocionUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: PromocionCreateOrConnectWithoutCategoriaInput | PromocionCreateOrConnectWithoutCategoriaInput[]
    upsert?: PromocionUpsertWithWhereUniqueWithoutCategoriaInput | PromocionUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: PromocionCreateManyCategoriaInputEnvelope
    set?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    disconnect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    delete?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    connect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    update?: PromocionUpdateWithWhereUniqueWithoutCategoriaInput | PromocionUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: PromocionUpdateManyWithWhereWithoutCategoriaInput | PromocionUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: PromocionScalarWhereInput | PromocionScalarWhereInput[]
  }

  export type ProductoPersonalizableUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<ProductoPersonalizableCreateWithoutCategoriaInput, ProductoPersonalizableUncheckedCreateWithoutCategoriaInput> | ProductoPersonalizableCreateWithoutCategoriaInput[] | ProductoPersonalizableUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProductoPersonalizableCreateOrConnectWithoutCategoriaInput | ProductoPersonalizableCreateOrConnectWithoutCategoriaInput[]
    upsert?: ProductoPersonalizableUpsertWithWhereUniqueWithoutCategoriaInput | ProductoPersonalizableUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: ProductoPersonalizableCreateManyCategoriaInputEnvelope
    set?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    disconnect?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    delete?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    connect?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    update?: ProductoPersonalizableUpdateWithWhereUniqueWithoutCategoriaInput | ProductoPersonalizableUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: ProductoPersonalizableUpdateManyWithWhereWithoutCategoriaInput | ProductoPersonalizableUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: ProductoPersonalizableScalarWhereInput | ProductoPersonalizableScalarWhereInput[]
  }

  export type ProductoUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<ProductoCreateWithoutCategoriaInput, ProductoUncheckedCreateWithoutCategoriaInput> | ProductoCreateWithoutCategoriaInput[] | ProductoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutCategoriaInput | ProductoCreateOrConnectWithoutCategoriaInput[]
    upsert?: ProductoUpsertWithWhereUniqueWithoutCategoriaInput | ProductoUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: ProductoCreateManyCategoriaInputEnvelope
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    update?: ProductoUpdateWithWhereUniqueWithoutCategoriaInput | ProductoUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: ProductoUpdateManyWithWhereWithoutCategoriaInput | ProductoUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
  }

  export type PromocionUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<PromocionCreateWithoutCategoriaInput, PromocionUncheckedCreateWithoutCategoriaInput> | PromocionCreateWithoutCategoriaInput[] | PromocionUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: PromocionCreateOrConnectWithoutCategoriaInput | PromocionCreateOrConnectWithoutCategoriaInput[]
    upsert?: PromocionUpsertWithWhereUniqueWithoutCategoriaInput | PromocionUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: PromocionCreateManyCategoriaInputEnvelope
    set?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    disconnect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    delete?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    connect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    update?: PromocionUpdateWithWhereUniqueWithoutCategoriaInput | PromocionUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: PromocionUpdateManyWithWhereWithoutCategoriaInput | PromocionUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: PromocionScalarWhereInput | PromocionScalarWhereInput[]
  }

  export type ProductoPersonalizableUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<ProductoPersonalizableCreateWithoutCategoriaInput, ProductoPersonalizableUncheckedCreateWithoutCategoriaInput> | ProductoPersonalizableCreateWithoutCategoriaInput[] | ProductoPersonalizableUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ProductoPersonalizableCreateOrConnectWithoutCategoriaInput | ProductoPersonalizableCreateOrConnectWithoutCategoriaInput[]
    upsert?: ProductoPersonalizableUpsertWithWhereUniqueWithoutCategoriaInput | ProductoPersonalizableUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: ProductoPersonalizableCreateManyCategoriaInputEnvelope
    set?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    disconnect?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    delete?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    connect?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    update?: ProductoPersonalizableUpdateWithWhereUniqueWithoutCategoriaInput | ProductoPersonalizableUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: ProductoPersonalizableUpdateManyWithWhereWithoutCategoriaInput | ProductoPersonalizableUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: ProductoPersonalizableScalarWhereInput | ProductoPersonalizableScalarWhereInput[]
  }

  export type ProductoEtiquetaCreateNestedManyWithoutEtiquetaInput = {
    create?: XOR<ProductoEtiquetaCreateWithoutEtiquetaInput, ProductoEtiquetaUncheckedCreateWithoutEtiquetaInput> | ProductoEtiquetaCreateWithoutEtiquetaInput[] | ProductoEtiquetaUncheckedCreateWithoutEtiquetaInput[]
    connectOrCreate?: ProductoEtiquetaCreateOrConnectWithoutEtiquetaInput | ProductoEtiquetaCreateOrConnectWithoutEtiquetaInput[]
    createMany?: ProductoEtiquetaCreateManyEtiquetaInputEnvelope
    connect?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
  }

  export type ProductoEtiquetaUncheckedCreateNestedManyWithoutEtiquetaInput = {
    create?: XOR<ProductoEtiquetaCreateWithoutEtiquetaInput, ProductoEtiquetaUncheckedCreateWithoutEtiquetaInput> | ProductoEtiquetaCreateWithoutEtiquetaInput[] | ProductoEtiquetaUncheckedCreateWithoutEtiquetaInput[]
    connectOrCreate?: ProductoEtiquetaCreateOrConnectWithoutEtiquetaInput | ProductoEtiquetaCreateOrConnectWithoutEtiquetaInput[]
    createMany?: ProductoEtiquetaCreateManyEtiquetaInputEnvelope
    connect?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
  }

  export type ProductoEtiquetaUpdateManyWithoutEtiquetaNestedInput = {
    create?: XOR<ProductoEtiquetaCreateWithoutEtiquetaInput, ProductoEtiquetaUncheckedCreateWithoutEtiquetaInput> | ProductoEtiquetaCreateWithoutEtiquetaInput[] | ProductoEtiquetaUncheckedCreateWithoutEtiquetaInput[]
    connectOrCreate?: ProductoEtiquetaCreateOrConnectWithoutEtiquetaInput | ProductoEtiquetaCreateOrConnectWithoutEtiquetaInput[]
    upsert?: ProductoEtiquetaUpsertWithWhereUniqueWithoutEtiquetaInput | ProductoEtiquetaUpsertWithWhereUniqueWithoutEtiquetaInput[]
    createMany?: ProductoEtiquetaCreateManyEtiquetaInputEnvelope
    set?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    disconnect?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    delete?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    connect?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    update?: ProductoEtiquetaUpdateWithWhereUniqueWithoutEtiquetaInput | ProductoEtiquetaUpdateWithWhereUniqueWithoutEtiquetaInput[]
    updateMany?: ProductoEtiquetaUpdateManyWithWhereWithoutEtiquetaInput | ProductoEtiquetaUpdateManyWithWhereWithoutEtiquetaInput[]
    deleteMany?: ProductoEtiquetaScalarWhereInput | ProductoEtiquetaScalarWhereInput[]
  }

  export type ProductoEtiquetaUncheckedUpdateManyWithoutEtiquetaNestedInput = {
    create?: XOR<ProductoEtiquetaCreateWithoutEtiquetaInput, ProductoEtiquetaUncheckedCreateWithoutEtiquetaInput> | ProductoEtiquetaCreateWithoutEtiquetaInput[] | ProductoEtiquetaUncheckedCreateWithoutEtiquetaInput[]
    connectOrCreate?: ProductoEtiquetaCreateOrConnectWithoutEtiquetaInput | ProductoEtiquetaCreateOrConnectWithoutEtiquetaInput[]
    upsert?: ProductoEtiquetaUpsertWithWhereUniqueWithoutEtiquetaInput | ProductoEtiquetaUpsertWithWhereUniqueWithoutEtiquetaInput[]
    createMany?: ProductoEtiquetaCreateManyEtiquetaInputEnvelope
    set?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    disconnect?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    delete?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    connect?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    update?: ProductoEtiquetaUpdateWithWhereUniqueWithoutEtiquetaInput | ProductoEtiquetaUpdateWithWhereUniqueWithoutEtiquetaInput[]
    updateMany?: ProductoEtiquetaUpdateManyWithWhereWithoutEtiquetaInput | ProductoEtiquetaUpdateManyWithWhereWithoutEtiquetaInput[]
    deleteMany?: ProductoEtiquetaScalarWhereInput | ProductoEtiquetaScalarWhereInput[]
  }

  export type CategoriaCreateNestedOneWithoutProductosInput = {
    create?: XOR<CategoriaCreateWithoutProductosInput, CategoriaUncheckedCreateWithoutProductosInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutProductosInput
    connect?: CategoriaWhereUniqueInput
  }

  export type ImagenProductoCreateNestedManyWithoutProductoInput = {
    create?: XOR<ImagenProductoCreateWithoutProductoInput, ImagenProductoUncheckedCreateWithoutProductoInput> | ImagenProductoCreateWithoutProductoInput[] | ImagenProductoUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ImagenProductoCreateOrConnectWithoutProductoInput | ImagenProductoCreateOrConnectWithoutProductoInput[]
    createMany?: ImagenProductoCreateManyProductoInputEnvelope
    connect?: ImagenProductoWhereUniqueInput | ImagenProductoWhereUniqueInput[]
  }

  export type ProductoEtiquetaCreateNestedManyWithoutProductoInput = {
    create?: XOR<ProductoEtiquetaCreateWithoutProductoInput, ProductoEtiquetaUncheckedCreateWithoutProductoInput> | ProductoEtiquetaCreateWithoutProductoInput[] | ProductoEtiquetaUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ProductoEtiquetaCreateOrConnectWithoutProductoInput | ProductoEtiquetaCreateOrConnectWithoutProductoInput[]
    createMany?: ProductoEtiquetaCreateManyProductoInputEnvelope
    connect?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
  }

  export type ResenaCreateNestedManyWithoutProductoInput = {
    create?: XOR<ResenaCreateWithoutProductoInput, ResenaUncheckedCreateWithoutProductoInput> | ResenaCreateWithoutProductoInput[] | ResenaUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutProductoInput | ResenaCreateOrConnectWithoutProductoInput[]
    createMany?: ResenaCreateManyProductoInputEnvelope
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
  }

  export type PedidoItemCreateNestedManyWithoutProductoInput = {
    create?: XOR<PedidoItemCreateWithoutProductoInput, PedidoItemUncheckedCreateWithoutProductoInput> | PedidoItemCreateWithoutProductoInput[] | PedidoItemUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProductoInput | PedidoItemCreateOrConnectWithoutProductoInput[]
    createMany?: PedidoItemCreateManyProductoInputEnvelope
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
  }

  export type PromocionCreateNestedManyWithoutProductoInput = {
    create?: XOR<PromocionCreateWithoutProductoInput, PromocionUncheckedCreateWithoutProductoInput> | PromocionCreateWithoutProductoInput[] | PromocionUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PromocionCreateOrConnectWithoutProductoInput | PromocionCreateOrConnectWithoutProductoInput[]
    createMany?: PromocionCreateManyProductoInputEnvelope
    connect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
  }

  export type ProductoPersonalizableCreateNestedManyWithoutProducto_baseInput = {
    create?: XOR<ProductoPersonalizableCreateWithoutProducto_baseInput, ProductoPersonalizableUncheckedCreateWithoutProducto_baseInput> | ProductoPersonalizableCreateWithoutProducto_baseInput[] | ProductoPersonalizableUncheckedCreateWithoutProducto_baseInput[]
    connectOrCreate?: ProductoPersonalizableCreateOrConnectWithoutProducto_baseInput | ProductoPersonalizableCreateOrConnectWithoutProducto_baseInput[]
    createMany?: ProductoPersonalizableCreateManyProducto_baseInputEnvelope
    connect?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
  }

  export type ImagenProductoUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<ImagenProductoCreateWithoutProductoInput, ImagenProductoUncheckedCreateWithoutProductoInput> | ImagenProductoCreateWithoutProductoInput[] | ImagenProductoUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ImagenProductoCreateOrConnectWithoutProductoInput | ImagenProductoCreateOrConnectWithoutProductoInput[]
    createMany?: ImagenProductoCreateManyProductoInputEnvelope
    connect?: ImagenProductoWhereUniqueInput | ImagenProductoWhereUniqueInput[]
  }

  export type ProductoEtiquetaUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<ProductoEtiquetaCreateWithoutProductoInput, ProductoEtiquetaUncheckedCreateWithoutProductoInput> | ProductoEtiquetaCreateWithoutProductoInput[] | ProductoEtiquetaUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ProductoEtiquetaCreateOrConnectWithoutProductoInput | ProductoEtiquetaCreateOrConnectWithoutProductoInput[]
    createMany?: ProductoEtiquetaCreateManyProductoInputEnvelope
    connect?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
  }

  export type ResenaUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<ResenaCreateWithoutProductoInput, ResenaUncheckedCreateWithoutProductoInput> | ResenaCreateWithoutProductoInput[] | ResenaUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutProductoInput | ResenaCreateOrConnectWithoutProductoInput[]
    createMany?: ResenaCreateManyProductoInputEnvelope
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
  }

  export type PedidoItemUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<PedidoItemCreateWithoutProductoInput, PedidoItemUncheckedCreateWithoutProductoInput> | PedidoItemCreateWithoutProductoInput[] | PedidoItemUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProductoInput | PedidoItemCreateOrConnectWithoutProductoInput[]
    createMany?: PedidoItemCreateManyProductoInputEnvelope
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
  }

  export type PromocionUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<PromocionCreateWithoutProductoInput, PromocionUncheckedCreateWithoutProductoInput> | PromocionCreateWithoutProductoInput[] | PromocionUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PromocionCreateOrConnectWithoutProductoInput | PromocionCreateOrConnectWithoutProductoInput[]
    createMany?: PromocionCreateManyProductoInputEnvelope
    connect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
  }

  export type ProductoPersonalizableUncheckedCreateNestedManyWithoutProducto_baseInput = {
    create?: XOR<ProductoPersonalizableCreateWithoutProducto_baseInput, ProductoPersonalizableUncheckedCreateWithoutProducto_baseInput> | ProductoPersonalizableCreateWithoutProducto_baseInput[] | ProductoPersonalizableUncheckedCreateWithoutProducto_baseInput[]
    connectOrCreate?: ProductoPersonalizableCreateOrConnectWithoutProducto_baseInput | ProductoPersonalizableCreateOrConnectWithoutProducto_baseInput[]
    createMany?: ProductoPersonalizableCreateManyProducto_baseInputEnvelope
    connect?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CategoriaUpdateOneRequiredWithoutProductosNestedInput = {
    create?: XOR<CategoriaCreateWithoutProductosInput, CategoriaUncheckedCreateWithoutProductosInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutProductosInput
    upsert?: CategoriaUpsertWithoutProductosInput
    connect?: CategoriaWhereUniqueInput
    update?: XOR<XOR<CategoriaUpdateToOneWithWhereWithoutProductosInput, CategoriaUpdateWithoutProductosInput>, CategoriaUncheckedUpdateWithoutProductosInput>
  }

  export type ImagenProductoUpdateManyWithoutProductoNestedInput = {
    create?: XOR<ImagenProductoCreateWithoutProductoInput, ImagenProductoUncheckedCreateWithoutProductoInput> | ImagenProductoCreateWithoutProductoInput[] | ImagenProductoUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ImagenProductoCreateOrConnectWithoutProductoInput | ImagenProductoCreateOrConnectWithoutProductoInput[]
    upsert?: ImagenProductoUpsertWithWhereUniqueWithoutProductoInput | ImagenProductoUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: ImagenProductoCreateManyProductoInputEnvelope
    set?: ImagenProductoWhereUniqueInput | ImagenProductoWhereUniqueInput[]
    disconnect?: ImagenProductoWhereUniqueInput | ImagenProductoWhereUniqueInput[]
    delete?: ImagenProductoWhereUniqueInput | ImagenProductoWhereUniqueInput[]
    connect?: ImagenProductoWhereUniqueInput | ImagenProductoWhereUniqueInput[]
    update?: ImagenProductoUpdateWithWhereUniqueWithoutProductoInput | ImagenProductoUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: ImagenProductoUpdateManyWithWhereWithoutProductoInput | ImagenProductoUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: ImagenProductoScalarWhereInput | ImagenProductoScalarWhereInput[]
  }

  export type ProductoEtiquetaUpdateManyWithoutProductoNestedInput = {
    create?: XOR<ProductoEtiquetaCreateWithoutProductoInput, ProductoEtiquetaUncheckedCreateWithoutProductoInput> | ProductoEtiquetaCreateWithoutProductoInput[] | ProductoEtiquetaUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ProductoEtiquetaCreateOrConnectWithoutProductoInput | ProductoEtiquetaCreateOrConnectWithoutProductoInput[]
    upsert?: ProductoEtiquetaUpsertWithWhereUniqueWithoutProductoInput | ProductoEtiquetaUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: ProductoEtiquetaCreateManyProductoInputEnvelope
    set?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    disconnect?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    delete?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    connect?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    update?: ProductoEtiquetaUpdateWithWhereUniqueWithoutProductoInput | ProductoEtiquetaUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: ProductoEtiquetaUpdateManyWithWhereWithoutProductoInput | ProductoEtiquetaUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: ProductoEtiquetaScalarWhereInput | ProductoEtiquetaScalarWhereInput[]
  }

  export type ResenaUpdateManyWithoutProductoNestedInput = {
    create?: XOR<ResenaCreateWithoutProductoInput, ResenaUncheckedCreateWithoutProductoInput> | ResenaCreateWithoutProductoInput[] | ResenaUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutProductoInput | ResenaCreateOrConnectWithoutProductoInput[]
    upsert?: ResenaUpsertWithWhereUniqueWithoutProductoInput | ResenaUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: ResenaCreateManyProductoInputEnvelope
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    update?: ResenaUpdateWithWhereUniqueWithoutProductoInput | ResenaUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: ResenaUpdateManyWithWhereWithoutProductoInput | ResenaUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
  }

  export type PedidoItemUpdateManyWithoutProductoNestedInput = {
    create?: XOR<PedidoItemCreateWithoutProductoInput, PedidoItemUncheckedCreateWithoutProductoInput> | PedidoItemCreateWithoutProductoInput[] | PedidoItemUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProductoInput | PedidoItemCreateOrConnectWithoutProductoInput[]
    upsert?: PedidoItemUpsertWithWhereUniqueWithoutProductoInput | PedidoItemUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: PedidoItemCreateManyProductoInputEnvelope
    set?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    disconnect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    delete?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    update?: PedidoItemUpdateWithWhereUniqueWithoutProductoInput | PedidoItemUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: PedidoItemUpdateManyWithWhereWithoutProductoInput | PedidoItemUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
  }

  export type PromocionUpdateManyWithoutProductoNestedInput = {
    create?: XOR<PromocionCreateWithoutProductoInput, PromocionUncheckedCreateWithoutProductoInput> | PromocionCreateWithoutProductoInput[] | PromocionUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PromocionCreateOrConnectWithoutProductoInput | PromocionCreateOrConnectWithoutProductoInput[]
    upsert?: PromocionUpsertWithWhereUniqueWithoutProductoInput | PromocionUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: PromocionCreateManyProductoInputEnvelope
    set?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    disconnect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    delete?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    connect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    update?: PromocionUpdateWithWhereUniqueWithoutProductoInput | PromocionUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: PromocionUpdateManyWithWhereWithoutProductoInput | PromocionUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: PromocionScalarWhereInput | PromocionScalarWhereInput[]
  }

  export type ProductoPersonalizableUpdateManyWithoutProducto_baseNestedInput = {
    create?: XOR<ProductoPersonalizableCreateWithoutProducto_baseInput, ProductoPersonalizableUncheckedCreateWithoutProducto_baseInput> | ProductoPersonalizableCreateWithoutProducto_baseInput[] | ProductoPersonalizableUncheckedCreateWithoutProducto_baseInput[]
    connectOrCreate?: ProductoPersonalizableCreateOrConnectWithoutProducto_baseInput | ProductoPersonalizableCreateOrConnectWithoutProducto_baseInput[]
    upsert?: ProductoPersonalizableUpsertWithWhereUniqueWithoutProducto_baseInput | ProductoPersonalizableUpsertWithWhereUniqueWithoutProducto_baseInput[]
    createMany?: ProductoPersonalizableCreateManyProducto_baseInputEnvelope
    set?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    disconnect?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    delete?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    connect?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    update?: ProductoPersonalizableUpdateWithWhereUniqueWithoutProducto_baseInput | ProductoPersonalizableUpdateWithWhereUniqueWithoutProducto_baseInput[]
    updateMany?: ProductoPersonalizableUpdateManyWithWhereWithoutProducto_baseInput | ProductoPersonalizableUpdateManyWithWhereWithoutProducto_baseInput[]
    deleteMany?: ProductoPersonalizableScalarWhereInput | ProductoPersonalizableScalarWhereInput[]
  }

  export type ImagenProductoUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<ImagenProductoCreateWithoutProductoInput, ImagenProductoUncheckedCreateWithoutProductoInput> | ImagenProductoCreateWithoutProductoInput[] | ImagenProductoUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ImagenProductoCreateOrConnectWithoutProductoInput | ImagenProductoCreateOrConnectWithoutProductoInput[]
    upsert?: ImagenProductoUpsertWithWhereUniqueWithoutProductoInput | ImagenProductoUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: ImagenProductoCreateManyProductoInputEnvelope
    set?: ImagenProductoWhereUniqueInput | ImagenProductoWhereUniqueInput[]
    disconnect?: ImagenProductoWhereUniqueInput | ImagenProductoWhereUniqueInput[]
    delete?: ImagenProductoWhereUniqueInput | ImagenProductoWhereUniqueInput[]
    connect?: ImagenProductoWhereUniqueInput | ImagenProductoWhereUniqueInput[]
    update?: ImagenProductoUpdateWithWhereUniqueWithoutProductoInput | ImagenProductoUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: ImagenProductoUpdateManyWithWhereWithoutProductoInput | ImagenProductoUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: ImagenProductoScalarWhereInput | ImagenProductoScalarWhereInput[]
  }

  export type ProductoEtiquetaUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<ProductoEtiquetaCreateWithoutProductoInput, ProductoEtiquetaUncheckedCreateWithoutProductoInput> | ProductoEtiquetaCreateWithoutProductoInput[] | ProductoEtiquetaUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ProductoEtiquetaCreateOrConnectWithoutProductoInput | ProductoEtiquetaCreateOrConnectWithoutProductoInput[]
    upsert?: ProductoEtiquetaUpsertWithWhereUniqueWithoutProductoInput | ProductoEtiquetaUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: ProductoEtiquetaCreateManyProductoInputEnvelope
    set?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    disconnect?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    delete?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    connect?: ProductoEtiquetaWhereUniqueInput | ProductoEtiquetaWhereUniqueInput[]
    update?: ProductoEtiquetaUpdateWithWhereUniqueWithoutProductoInput | ProductoEtiquetaUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: ProductoEtiquetaUpdateManyWithWhereWithoutProductoInput | ProductoEtiquetaUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: ProductoEtiquetaScalarWhereInput | ProductoEtiquetaScalarWhereInput[]
  }

  export type ResenaUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<ResenaCreateWithoutProductoInput, ResenaUncheckedCreateWithoutProductoInput> | ResenaCreateWithoutProductoInput[] | ResenaUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutProductoInput | ResenaCreateOrConnectWithoutProductoInput[]
    upsert?: ResenaUpsertWithWhereUniqueWithoutProductoInput | ResenaUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: ResenaCreateManyProductoInputEnvelope
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    update?: ResenaUpdateWithWhereUniqueWithoutProductoInput | ResenaUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: ResenaUpdateManyWithWhereWithoutProductoInput | ResenaUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
  }

  export type PedidoItemUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<PedidoItemCreateWithoutProductoInput, PedidoItemUncheckedCreateWithoutProductoInput> | PedidoItemCreateWithoutProductoInput[] | PedidoItemUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProductoInput | PedidoItemCreateOrConnectWithoutProductoInput[]
    upsert?: PedidoItemUpsertWithWhereUniqueWithoutProductoInput | PedidoItemUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: PedidoItemCreateManyProductoInputEnvelope
    set?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    disconnect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    delete?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    update?: PedidoItemUpdateWithWhereUniqueWithoutProductoInput | PedidoItemUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: PedidoItemUpdateManyWithWhereWithoutProductoInput | PedidoItemUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
  }

  export type PromocionUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<PromocionCreateWithoutProductoInput, PromocionUncheckedCreateWithoutProductoInput> | PromocionCreateWithoutProductoInput[] | PromocionUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: PromocionCreateOrConnectWithoutProductoInput | PromocionCreateOrConnectWithoutProductoInput[]
    upsert?: PromocionUpsertWithWhereUniqueWithoutProductoInput | PromocionUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: PromocionCreateManyProductoInputEnvelope
    set?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    disconnect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    delete?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    connect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    update?: PromocionUpdateWithWhereUniqueWithoutProductoInput | PromocionUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: PromocionUpdateManyWithWhereWithoutProductoInput | PromocionUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: PromocionScalarWhereInput | PromocionScalarWhereInput[]
  }

  export type ProductoPersonalizableUncheckedUpdateManyWithoutProducto_baseNestedInput = {
    create?: XOR<ProductoPersonalizableCreateWithoutProducto_baseInput, ProductoPersonalizableUncheckedCreateWithoutProducto_baseInput> | ProductoPersonalizableCreateWithoutProducto_baseInput[] | ProductoPersonalizableUncheckedCreateWithoutProducto_baseInput[]
    connectOrCreate?: ProductoPersonalizableCreateOrConnectWithoutProducto_baseInput | ProductoPersonalizableCreateOrConnectWithoutProducto_baseInput[]
    upsert?: ProductoPersonalizableUpsertWithWhereUniqueWithoutProducto_baseInput | ProductoPersonalizableUpsertWithWhereUniqueWithoutProducto_baseInput[]
    createMany?: ProductoPersonalizableCreateManyProducto_baseInputEnvelope
    set?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    disconnect?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    delete?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    connect?: ProductoPersonalizableWhereUniqueInput | ProductoPersonalizableWhereUniqueInput[]
    update?: ProductoPersonalizableUpdateWithWhereUniqueWithoutProducto_baseInput | ProductoPersonalizableUpdateWithWhereUniqueWithoutProducto_baseInput[]
    updateMany?: ProductoPersonalizableUpdateManyWithWhereWithoutProducto_baseInput | ProductoPersonalizableUpdateManyWithWhereWithoutProducto_baseInput[]
    deleteMany?: ProductoPersonalizableScalarWhereInput | ProductoPersonalizableScalarWhereInput[]
  }

  export type ProductoCreateNestedOneWithoutImagenesInput = {
    create?: XOR<ProductoCreateWithoutImagenesInput, ProductoUncheckedCreateWithoutImagenesInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutImagenesInput
    connect?: ProductoWhereUniqueInput
  }

  export type ProductoUpdateOneRequiredWithoutImagenesNestedInput = {
    create?: XOR<ProductoCreateWithoutImagenesInput, ProductoUncheckedCreateWithoutImagenesInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutImagenesInput
    upsert?: ProductoUpsertWithoutImagenesInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutImagenesInput, ProductoUpdateWithoutImagenesInput>, ProductoUncheckedUpdateWithoutImagenesInput>
  }

  export type ProductoCreateNestedOneWithoutEtiquetasInput = {
    create?: XOR<ProductoCreateWithoutEtiquetasInput, ProductoUncheckedCreateWithoutEtiquetasInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutEtiquetasInput
    connect?: ProductoWhereUniqueInput
  }

  export type EtiquetaCreateNestedOneWithoutProductosInput = {
    create?: XOR<EtiquetaCreateWithoutProductosInput, EtiquetaUncheckedCreateWithoutProductosInput>
    connectOrCreate?: EtiquetaCreateOrConnectWithoutProductosInput
    connect?: EtiquetaWhereUniqueInput
  }

  export type ProductoUpdateOneRequiredWithoutEtiquetasNestedInput = {
    create?: XOR<ProductoCreateWithoutEtiquetasInput, ProductoUncheckedCreateWithoutEtiquetasInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutEtiquetasInput
    upsert?: ProductoUpsertWithoutEtiquetasInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutEtiquetasInput, ProductoUpdateWithoutEtiquetasInput>, ProductoUncheckedUpdateWithoutEtiquetasInput>
  }

  export type EtiquetaUpdateOneRequiredWithoutProductosNestedInput = {
    create?: XOR<EtiquetaCreateWithoutProductosInput, EtiquetaUncheckedCreateWithoutProductosInput>
    connectOrCreate?: EtiquetaCreateOrConnectWithoutProductosInput
    upsert?: EtiquetaUpsertWithoutProductosInput
    connect?: EtiquetaWhereUniqueInput
    update?: XOR<XOR<EtiquetaUpdateToOneWithWhereWithoutProductosInput, EtiquetaUpdateWithoutProductosInput>, EtiquetaUncheckedUpdateWithoutProductosInput>
  }

  export type UsuarioCreateNestedOneWithoutResenasInput = {
    create?: XOR<UsuarioCreateWithoutResenasInput, UsuarioUncheckedCreateWithoutResenasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutResenasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ProductoCreateNestedOneWithoutResenasInput = {
    create?: XOR<ProductoCreateWithoutResenasInput, ProductoUncheckedCreateWithoutResenasInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutResenasInput
    connect?: ProductoWhereUniqueInput
  }

  export type ReporteResenaCreateNestedManyWithoutResenaInput = {
    create?: XOR<ReporteResenaCreateWithoutResenaInput, ReporteResenaUncheckedCreateWithoutResenaInput> | ReporteResenaCreateWithoutResenaInput[] | ReporteResenaUncheckedCreateWithoutResenaInput[]
    connectOrCreate?: ReporteResenaCreateOrConnectWithoutResenaInput | ReporteResenaCreateOrConnectWithoutResenaInput[]
    createMany?: ReporteResenaCreateManyResenaInputEnvelope
    connect?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
  }

  export type ReporteResenaUncheckedCreateNestedManyWithoutResenaInput = {
    create?: XOR<ReporteResenaCreateWithoutResenaInput, ReporteResenaUncheckedCreateWithoutResenaInput> | ReporteResenaCreateWithoutResenaInput[] | ReporteResenaUncheckedCreateWithoutResenaInput[]
    connectOrCreate?: ReporteResenaCreateOrConnectWithoutResenaInput | ReporteResenaCreateOrConnectWithoutResenaInput[]
    createMany?: ReporteResenaCreateManyResenaInputEnvelope
    connect?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UsuarioUpdateOneRequiredWithoutResenasNestedInput = {
    create?: XOR<UsuarioCreateWithoutResenasInput, UsuarioUncheckedCreateWithoutResenasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutResenasInput
    upsert?: UsuarioUpsertWithoutResenasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutResenasInput, UsuarioUpdateWithoutResenasInput>, UsuarioUncheckedUpdateWithoutResenasInput>
  }

  export type ProductoUpdateOneRequiredWithoutResenasNestedInput = {
    create?: XOR<ProductoCreateWithoutResenasInput, ProductoUncheckedCreateWithoutResenasInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutResenasInput
    upsert?: ProductoUpsertWithoutResenasInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutResenasInput, ProductoUpdateWithoutResenasInput>, ProductoUncheckedUpdateWithoutResenasInput>
  }

  export type ReporteResenaUpdateManyWithoutResenaNestedInput = {
    create?: XOR<ReporteResenaCreateWithoutResenaInput, ReporteResenaUncheckedCreateWithoutResenaInput> | ReporteResenaCreateWithoutResenaInput[] | ReporteResenaUncheckedCreateWithoutResenaInput[]
    connectOrCreate?: ReporteResenaCreateOrConnectWithoutResenaInput | ReporteResenaCreateOrConnectWithoutResenaInput[]
    upsert?: ReporteResenaUpsertWithWhereUniqueWithoutResenaInput | ReporteResenaUpsertWithWhereUniqueWithoutResenaInput[]
    createMany?: ReporteResenaCreateManyResenaInputEnvelope
    set?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    disconnect?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    delete?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    connect?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    update?: ReporteResenaUpdateWithWhereUniqueWithoutResenaInput | ReporteResenaUpdateWithWhereUniqueWithoutResenaInput[]
    updateMany?: ReporteResenaUpdateManyWithWhereWithoutResenaInput | ReporteResenaUpdateManyWithWhereWithoutResenaInput[]
    deleteMany?: ReporteResenaScalarWhereInput | ReporteResenaScalarWhereInput[]
  }

  export type ReporteResenaUncheckedUpdateManyWithoutResenaNestedInput = {
    create?: XOR<ReporteResenaCreateWithoutResenaInput, ReporteResenaUncheckedCreateWithoutResenaInput> | ReporteResenaCreateWithoutResenaInput[] | ReporteResenaUncheckedCreateWithoutResenaInput[]
    connectOrCreate?: ReporteResenaCreateOrConnectWithoutResenaInput | ReporteResenaCreateOrConnectWithoutResenaInput[]
    upsert?: ReporteResenaUpsertWithWhereUniqueWithoutResenaInput | ReporteResenaUpsertWithWhereUniqueWithoutResenaInput[]
    createMany?: ReporteResenaCreateManyResenaInputEnvelope
    set?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    disconnect?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    delete?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    connect?: ReporteResenaWhereUniqueInput | ReporteResenaWhereUniqueInput[]
    update?: ReporteResenaUpdateWithWhereUniqueWithoutResenaInput | ReporteResenaUpdateWithWhereUniqueWithoutResenaInput[]
    updateMany?: ReporteResenaUpdateManyWithWhereWithoutResenaInput | ReporteResenaUpdateManyWithWhereWithoutResenaInput[]
    deleteMany?: ReporteResenaScalarWhereInput | ReporteResenaScalarWhereInput[]
  }

  export type CategoriaCreateNestedOneWithoutProductosPersonalizablesInput = {
    create?: XOR<CategoriaCreateWithoutProductosPersonalizablesInput, CategoriaUncheckedCreateWithoutProductosPersonalizablesInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutProductosPersonalizablesInput
    connect?: CategoriaWhereUniqueInput
  }

  export type ProductoCreateNestedOneWithoutProductosPersonalizablesInput = {
    create?: XOR<ProductoCreateWithoutProductosPersonalizablesInput, ProductoUncheckedCreateWithoutProductosPersonalizablesInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutProductosPersonalizablesInput
    connect?: ProductoWhereUniqueInput
  }

  export type PedidoItemCreateNestedManyWithoutProducto_personalizadoInput = {
    create?: XOR<PedidoItemCreateWithoutProducto_personalizadoInput, PedidoItemUncheckedCreateWithoutProducto_personalizadoInput> | PedidoItemCreateWithoutProducto_personalizadoInput[] | PedidoItemUncheckedCreateWithoutProducto_personalizadoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProducto_personalizadoInput | PedidoItemCreateOrConnectWithoutProducto_personalizadoInput[]
    createMany?: PedidoItemCreateManyProducto_personalizadoInputEnvelope
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
  }

  export type VarianteDetalleCreateNestedManyWithoutProductoPersonalizableInput = {
    create?: XOR<VarianteDetalleCreateWithoutProductoPersonalizableInput, VarianteDetalleUncheckedCreateWithoutProductoPersonalizableInput> | VarianteDetalleCreateWithoutProductoPersonalizableInput[] | VarianteDetalleUncheckedCreateWithoutProductoPersonalizableInput[]
    connectOrCreate?: VarianteDetalleCreateOrConnectWithoutProductoPersonalizableInput | VarianteDetalleCreateOrConnectWithoutProductoPersonalizableInput[]
    createMany?: VarianteDetalleCreateManyProductoPersonalizableInputEnvelope
    connect?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
  }

  export type PedidoItemUncheckedCreateNestedManyWithoutProducto_personalizadoInput = {
    create?: XOR<PedidoItemCreateWithoutProducto_personalizadoInput, PedidoItemUncheckedCreateWithoutProducto_personalizadoInput> | PedidoItemCreateWithoutProducto_personalizadoInput[] | PedidoItemUncheckedCreateWithoutProducto_personalizadoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProducto_personalizadoInput | PedidoItemCreateOrConnectWithoutProducto_personalizadoInput[]
    createMany?: PedidoItemCreateManyProducto_personalizadoInputEnvelope
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
  }

  export type VarianteDetalleUncheckedCreateNestedManyWithoutProductoPersonalizableInput = {
    create?: XOR<VarianteDetalleCreateWithoutProductoPersonalizableInput, VarianteDetalleUncheckedCreateWithoutProductoPersonalizableInput> | VarianteDetalleCreateWithoutProductoPersonalizableInput[] | VarianteDetalleUncheckedCreateWithoutProductoPersonalizableInput[]
    connectOrCreate?: VarianteDetalleCreateOrConnectWithoutProductoPersonalizableInput | VarianteDetalleCreateOrConnectWithoutProductoPersonalizableInput[]
    createMany?: VarianteDetalleCreateManyProductoPersonalizableInputEnvelope
    connect?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
  }

  export type CategoriaUpdateOneRequiredWithoutProductosPersonalizablesNestedInput = {
    create?: XOR<CategoriaCreateWithoutProductosPersonalizablesInput, CategoriaUncheckedCreateWithoutProductosPersonalizablesInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutProductosPersonalizablesInput
    upsert?: CategoriaUpsertWithoutProductosPersonalizablesInput
    connect?: CategoriaWhereUniqueInput
    update?: XOR<XOR<CategoriaUpdateToOneWithWhereWithoutProductosPersonalizablesInput, CategoriaUpdateWithoutProductosPersonalizablesInput>, CategoriaUncheckedUpdateWithoutProductosPersonalizablesInput>
  }

  export type ProductoUpdateOneRequiredWithoutProductosPersonalizablesNestedInput = {
    create?: XOR<ProductoCreateWithoutProductosPersonalizablesInput, ProductoUncheckedCreateWithoutProductosPersonalizablesInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutProductosPersonalizablesInput
    upsert?: ProductoUpsertWithoutProductosPersonalizablesInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutProductosPersonalizablesInput, ProductoUpdateWithoutProductosPersonalizablesInput>, ProductoUncheckedUpdateWithoutProductosPersonalizablesInput>
  }

  export type PedidoItemUpdateManyWithoutProducto_personalizadoNestedInput = {
    create?: XOR<PedidoItemCreateWithoutProducto_personalizadoInput, PedidoItemUncheckedCreateWithoutProducto_personalizadoInput> | PedidoItemCreateWithoutProducto_personalizadoInput[] | PedidoItemUncheckedCreateWithoutProducto_personalizadoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProducto_personalizadoInput | PedidoItemCreateOrConnectWithoutProducto_personalizadoInput[]
    upsert?: PedidoItemUpsertWithWhereUniqueWithoutProducto_personalizadoInput | PedidoItemUpsertWithWhereUniqueWithoutProducto_personalizadoInput[]
    createMany?: PedidoItemCreateManyProducto_personalizadoInputEnvelope
    set?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    disconnect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    delete?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    update?: PedidoItemUpdateWithWhereUniqueWithoutProducto_personalizadoInput | PedidoItemUpdateWithWhereUniqueWithoutProducto_personalizadoInput[]
    updateMany?: PedidoItemUpdateManyWithWhereWithoutProducto_personalizadoInput | PedidoItemUpdateManyWithWhereWithoutProducto_personalizadoInput[]
    deleteMany?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
  }

  export type VarianteDetalleUpdateManyWithoutProductoPersonalizableNestedInput = {
    create?: XOR<VarianteDetalleCreateWithoutProductoPersonalizableInput, VarianteDetalleUncheckedCreateWithoutProductoPersonalizableInput> | VarianteDetalleCreateWithoutProductoPersonalizableInput[] | VarianteDetalleUncheckedCreateWithoutProductoPersonalizableInput[]
    connectOrCreate?: VarianteDetalleCreateOrConnectWithoutProductoPersonalizableInput | VarianteDetalleCreateOrConnectWithoutProductoPersonalizableInput[]
    upsert?: VarianteDetalleUpsertWithWhereUniqueWithoutProductoPersonalizableInput | VarianteDetalleUpsertWithWhereUniqueWithoutProductoPersonalizableInput[]
    createMany?: VarianteDetalleCreateManyProductoPersonalizableInputEnvelope
    set?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    disconnect?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    delete?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    connect?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    update?: VarianteDetalleUpdateWithWhereUniqueWithoutProductoPersonalizableInput | VarianteDetalleUpdateWithWhereUniqueWithoutProductoPersonalizableInput[]
    updateMany?: VarianteDetalleUpdateManyWithWhereWithoutProductoPersonalizableInput | VarianteDetalleUpdateManyWithWhereWithoutProductoPersonalizableInput[]
    deleteMany?: VarianteDetalleScalarWhereInput | VarianteDetalleScalarWhereInput[]
  }

  export type PedidoItemUncheckedUpdateManyWithoutProducto_personalizadoNestedInput = {
    create?: XOR<PedidoItemCreateWithoutProducto_personalizadoInput, PedidoItemUncheckedCreateWithoutProducto_personalizadoInput> | PedidoItemCreateWithoutProducto_personalizadoInput[] | PedidoItemUncheckedCreateWithoutProducto_personalizadoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutProducto_personalizadoInput | PedidoItemCreateOrConnectWithoutProducto_personalizadoInput[]
    upsert?: PedidoItemUpsertWithWhereUniqueWithoutProducto_personalizadoInput | PedidoItemUpsertWithWhereUniqueWithoutProducto_personalizadoInput[]
    createMany?: PedidoItemCreateManyProducto_personalizadoInputEnvelope
    set?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    disconnect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    delete?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    update?: PedidoItemUpdateWithWhereUniqueWithoutProducto_personalizadoInput | PedidoItemUpdateWithWhereUniqueWithoutProducto_personalizadoInput[]
    updateMany?: PedidoItemUpdateManyWithWhereWithoutProducto_personalizadoInput | PedidoItemUpdateManyWithWhereWithoutProducto_personalizadoInput[]
    deleteMany?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
  }

  export type VarianteDetalleUncheckedUpdateManyWithoutProductoPersonalizableNestedInput = {
    create?: XOR<VarianteDetalleCreateWithoutProductoPersonalizableInput, VarianteDetalleUncheckedCreateWithoutProductoPersonalizableInput> | VarianteDetalleCreateWithoutProductoPersonalizableInput[] | VarianteDetalleUncheckedCreateWithoutProductoPersonalizableInput[]
    connectOrCreate?: VarianteDetalleCreateOrConnectWithoutProductoPersonalizableInput | VarianteDetalleCreateOrConnectWithoutProductoPersonalizableInput[]
    upsert?: VarianteDetalleUpsertWithWhereUniqueWithoutProductoPersonalizableInput | VarianteDetalleUpsertWithWhereUniqueWithoutProductoPersonalizableInput[]
    createMany?: VarianteDetalleCreateManyProductoPersonalizableInputEnvelope
    set?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    disconnect?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    delete?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    connect?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    update?: VarianteDetalleUpdateWithWhereUniqueWithoutProductoPersonalizableInput | VarianteDetalleUpdateWithWhereUniqueWithoutProductoPersonalizableInput[]
    updateMany?: VarianteDetalleUpdateManyWithWhereWithoutProductoPersonalizableInput | VarianteDetalleUpdateManyWithWhereWithoutProductoPersonalizableInput[]
    deleteMany?: VarianteDetalleScalarWhereInput | VarianteDetalleScalarWhereInput[]
  }

  export type ValorAtributoCreateNestedManyWithoutAtributoInput = {
    create?: XOR<ValorAtributoCreateWithoutAtributoInput, ValorAtributoUncheckedCreateWithoutAtributoInput> | ValorAtributoCreateWithoutAtributoInput[] | ValorAtributoUncheckedCreateWithoutAtributoInput[]
    connectOrCreate?: ValorAtributoCreateOrConnectWithoutAtributoInput | ValorAtributoCreateOrConnectWithoutAtributoInput[]
    createMany?: ValorAtributoCreateManyAtributoInputEnvelope
    connect?: ValorAtributoWhereUniqueInput | ValorAtributoWhereUniqueInput[]
  }

  export type ValorAtributoUncheckedCreateNestedManyWithoutAtributoInput = {
    create?: XOR<ValorAtributoCreateWithoutAtributoInput, ValorAtributoUncheckedCreateWithoutAtributoInput> | ValorAtributoCreateWithoutAtributoInput[] | ValorAtributoUncheckedCreateWithoutAtributoInput[]
    connectOrCreate?: ValorAtributoCreateOrConnectWithoutAtributoInput | ValorAtributoCreateOrConnectWithoutAtributoInput[]
    createMany?: ValorAtributoCreateManyAtributoInputEnvelope
    connect?: ValorAtributoWhereUniqueInput | ValorAtributoWhereUniqueInput[]
  }

  export type ValorAtributoUpdateManyWithoutAtributoNestedInput = {
    create?: XOR<ValorAtributoCreateWithoutAtributoInput, ValorAtributoUncheckedCreateWithoutAtributoInput> | ValorAtributoCreateWithoutAtributoInput[] | ValorAtributoUncheckedCreateWithoutAtributoInput[]
    connectOrCreate?: ValorAtributoCreateOrConnectWithoutAtributoInput | ValorAtributoCreateOrConnectWithoutAtributoInput[]
    upsert?: ValorAtributoUpsertWithWhereUniqueWithoutAtributoInput | ValorAtributoUpsertWithWhereUniqueWithoutAtributoInput[]
    createMany?: ValorAtributoCreateManyAtributoInputEnvelope
    set?: ValorAtributoWhereUniqueInput | ValorAtributoWhereUniqueInput[]
    disconnect?: ValorAtributoWhereUniqueInput | ValorAtributoWhereUniqueInput[]
    delete?: ValorAtributoWhereUniqueInput | ValorAtributoWhereUniqueInput[]
    connect?: ValorAtributoWhereUniqueInput | ValorAtributoWhereUniqueInput[]
    update?: ValorAtributoUpdateWithWhereUniqueWithoutAtributoInput | ValorAtributoUpdateWithWhereUniqueWithoutAtributoInput[]
    updateMany?: ValorAtributoUpdateManyWithWhereWithoutAtributoInput | ValorAtributoUpdateManyWithWhereWithoutAtributoInput[]
    deleteMany?: ValorAtributoScalarWhereInput | ValorAtributoScalarWhereInput[]
  }

  export type ValorAtributoUncheckedUpdateManyWithoutAtributoNestedInput = {
    create?: XOR<ValorAtributoCreateWithoutAtributoInput, ValorAtributoUncheckedCreateWithoutAtributoInput> | ValorAtributoCreateWithoutAtributoInput[] | ValorAtributoUncheckedCreateWithoutAtributoInput[]
    connectOrCreate?: ValorAtributoCreateOrConnectWithoutAtributoInput | ValorAtributoCreateOrConnectWithoutAtributoInput[]
    upsert?: ValorAtributoUpsertWithWhereUniqueWithoutAtributoInput | ValorAtributoUpsertWithWhereUniqueWithoutAtributoInput[]
    createMany?: ValorAtributoCreateManyAtributoInputEnvelope
    set?: ValorAtributoWhereUniqueInput | ValorAtributoWhereUniqueInput[]
    disconnect?: ValorAtributoWhereUniqueInput | ValorAtributoWhereUniqueInput[]
    delete?: ValorAtributoWhereUniqueInput | ValorAtributoWhereUniqueInput[]
    connect?: ValorAtributoWhereUniqueInput | ValorAtributoWhereUniqueInput[]
    update?: ValorAtributoUpdateWithWhereUniqueWithoutAtributoInput | ValorAtributoUpdateWithWhereUniqueWithoutAtributoInput[]
    updateMany?: ValorAtributoUpdateManyWithWhereWithoutAtributoInput | ValorAtributoUpdateManyWithWhereWithoutAtributoInput[]
    deleteMany?: ValorAtributoScalarWhereInput | ValorAtributoScalarWhereInput[]
  }

  export type AtributoCreateNestedOneWithoutValoresInput = {
    create?: XOR<AtributoCreateWithoutValoresInput, AtributoUncheckedCreateWithoutValoresInput>
    connectOrCreate?: AtributoCreateOrConnectWithoutValoresInput
    connect?: AtributoWhereUniqueInput
  }

  export type VarianteDetalleCreateNestedManyWithoutValorInput = {
    create?: XOR<VarianteDetalleCreateWithoutValorInput, VarianteDetalleUncheckedCreateWithoutValorInput> | VarianteDetalleCreateWithoutValorInput[] | VarianteDetalleUncheckedCreateWithoutValorInput[]
    connectOrCreate?: VarianteDetalleCreateOrConnectWithoutValorInput | VarianteDetalleCreateOrConnectWithoutValorInput[]
    createMany?: VarianteDetalleCreateManyValorInputEnvelope
    connect?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
  }

  export type VarianteDetalleUncheckedCreateNestedManyWithoutValorInput = {
    create?: XOR<VarianteDetalleCreateWithoutValorInput, VarianteDetalleUncheckedCreateWithoutValorInput> | VarianteDetalleCreateWithoutValorInput[] | VarianteDetalleUncheckedCreateWithoutValorInput[]
    connectOrCreate?: VarianteDetalleCreateOrConnectWithoutValorInput | VarianteDetalleCreateOrConnectWithoutValorInput[]
    createMany?: VarianteDetalleCreateManyValorInputEnvelope
    connect?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
  }

  export type AtributoUpdateOneRequiredWithoutValoresNestedInput = {
    create?: XOR<AtributoCreateWithoutValoresInput, AtributoUncheckedCreateWithoutValoresInput>
    connectOrCreate?: AtributoCreateOrConnectWithoutValoresInput
    upsert?: AtributoUpsertWithoutValoresInput
    connect?: AtributoWhereUniqueInput
    update?: XOR<XOR<AtributoUpdateToOneWithWhereWithoutValoresInput, AtributoUpdateWithoutValoresInput>, AtributoUncheckedUpdateWithoutValoresInput>
  }

  export type VarianteDetalleUpdateManyWithoutValorNestedInput = {
    create?: XOR<VarianteDetalleCreateWithoutValorInput, VarianteDetalleUncheckedCreateWithoutValorInput> | VarianteDetalleCreateWithoutValorInput[] | VarianteDetalleUncheckedCreateWithoutValorInput[]
    connectOrCreate?: VarianteDetalleCreateOrConnectWithoutValorInput | VarianteDetalleCreateOrConnectWithoutValorInput[]
    upsert?: VarianteDetalleUpsertWithWhereUniqueWithoutValorInput | VarianteDetalleUpsertWithWhereUniqueWithoutValorInput[]
    createMany?: VarianteDetalleCreateManyValorInputEnvelope
    set?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    disconnect?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    delete?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    connect?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    update?: VarianteDetalleUpdateWithWhereUniqueWithoutValorInput | VarianteDetalleUpdateWithWhereUniqueWithoutValorInput[]
    updateMany?: VarianteDetalleUpdateManyWithWhereWithoutValorInput | VarianteDetalleUpdateManyWithWhereWithoutValorInput[]
    deleteMany?: VarianteDetalleScalarWhereInput | VarianteDetalleScalarWhereInput[]
  }

  export type VarianteDetalleUncheckedUpdateManyWithoutValorNestedInput = {
    create?: XOR<VarianteDetalleCreateWithoutValorInput, VarianteDetalleUncheckedCreateWithoutValorInput> | VarianteDetalleCreateWithoutValorInput[] | VarianteDetalleUncheckedCreateWithoutValorInput[]
    connectOrCreate?: VarianteDetalleCreateOrConnectWithoutValorInput | VarianteDetalleCreateOrConnectWithoutValorInput[]
    upsert?: VarianteDetalleUpsertWithWhereUniqueWithoutValorInput | VarianteDetalleUpsertWithWhereUniqueWithoutValorInput[]
    createMany?: VarianteDetalleCreateManyValorInputEnvelope
    set?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    disconnect?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    delete?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    connect?: VarianteDetalleWhereUniqueInput | VarianteDetalleWhereUniqueInput[]
    update?: VarianteDetalleUpdateWithWhereUniqueWithoutValorInput | VarianteDetalleUpdateWithWhereUniqueWithoutValorInput[]
    updateMany?: VarianteDetalleUpdateManyWithWhereWithoutValorInput | VarianteDetalleUpdateManyWithWhereWithoutValorInput[]
    deleteMany?: VarianteDetalleScalarWhereInput | VarianteDetalleScalarWhereInput[]
  }

  export type ValorAtributoCreateNestedOneWithoutVarianteDetallesInput = {
    create?: XOR<ValorAtributoCreateWithoutVarianteDetallesInput, ValorAtributoUncheckedCreateWithoutVarianteDetallesInput>
    connectOrCreate?: ValorAtributoCreateOrConnectWithoutVarianteDetallesInput
    connect?: ValorAtributoWhereUniqueInput
  }

  export type ProductoPersonalizableCreateNestedOneWithoutVariantesInput = {
    create?: XOR<ProductoPersonalizableCreateWithoutVariantesInput, ProductoPersonalizableUncheckedCreateWithoutVariantesInput>
    connectOrCreate?: ProductoPersonalizableCreateOrConnectWithoutVariantesInput
    connect?: ProductoPersonalizableWhereUniqueInput
  }

  export type ValorAtributoUpdateOneRequiredWithoutVarianteDetallesNestedInput = {
    create?: XOR<ValorAtributoCreateWithoutVarianteDetallesInput, ValorAtributoUncheckedCreateWithoutVarianteDetallesInput>
    connectOrCreate?: ValorAtributoCreateOrConnectWithoutVarianteDetallesInput
    upsert?: ValorAtributoUpsertWithoutVarianteDetallesInput
    connect?: ValorAtributoWhereUniqueInput
    update?: XOR<XOR<ValorAtributoUpdateToOneWithWhereWithoutVarianteDetallesInput, ValorAtributoUpdateWithoutVarianteDetallesInput>, ValorAtributoUncheckedUpdateWithoutVarianteDetallesInput>
  }

  export type ProductoPersonalizableUpdateOneRequiredWithoutVariantesNestedInput = {
    create?: XOR<ProductoPersonalizableCreateWithoutVariantesInput, ProductoPersonalizableUncheckedCreateWithoutVariantesInput>
    connectOrCreate?: ProductoPersonalizableCreateOrConnectWithoutVariantesInput
    upsert?: ProductoPersonalizableUpsertWithoutVariantesInput
    connect?: ProductoPersonalizableWhereUniqueInput
    update?: XOR<XOR<ProductoPersonalizableUpdateToOneWithWhereWithoutVariantesInput, ProductoPersonalizableUpdateWithoutVariantesInput>, ProductoPersonalizableUncheckedUpdateWithoutVariantesInput>
  }

  export type ProductoCreateNestedOneWithoutPromocionesInput = {
    create?: XOR<ProductoCreateWithoutPromocionesInput, ProductoUncheckedCreateWithoutPromocionesInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPromocionesInput
    connect?: ProductoWhereUniqueInput
  }

  export type CategoriaCreateNestedOneWithoutPromocionesInput = {
    create?: XOR<CategoriaCreateWithoutPromocionesInput, CategoriaUncheckedCreateWithoutPromocionesInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutPromocionesInput
    connect?: CategoriaWhereUniqueInput
  }

  export type HistorialPromocionAplicadaCreateNestedManyWithoutPromocionInput = {
    create?: XOR<HistorialPromocionAplicadaCreateWithoutPromocionInput, HistorialPromocionAplicadaUncheckedCreateWithoutPromocionInput> | HistorialPromocionAplicadaCreateWithoutPromocionInput[] | HistorialPromocionAplicadaUncheckedCreateWithoutPromocionInput[]
    connectOrCreate?: HistorialPromocionAplicadaCreateOrConnectWithoutPromocionInput | HistorialPromocionAplicadaCreateOrConnectWithoutPromocionInput[]
    createMany?: HistorialPromocionAplicadaCreateManyPromocionInputEnvelope
    connect?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
  }

  export type HistorialPromocionAplicadaUncheckedCreateNestedManyWithoutPromocionInput = {
    create?: XOR<HistorialPromocionAplicadaCreateWithoutPromocionInput, HistorialPromocionAplicadaUncheckedCreateWithoutPromocionInput> | HistorialPromocionAplicadaCreateWithoutPromocionInput[] | HistorialPromocionAplicadaUncheckedCreateWithoutPromocionInput[]
    connectOrCreate?: HistorialPromocionAplicadaCreateOrConnectWithoutPromocionInput | HistorialPromocionAplicadaCreateOrConnectWithoutPromocionInput[]
    createMany?: HistorialPromocionAplicadaCreateManyPromocionInputEnvelope
    connect?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
  }

  export type EnumTipoPromocionFieldUpdateOperationsInput = {
    set?: $Enums.TipoPromocion
  }

  export type ProductoUpdateOneWithoutPromocionesNestedInput = {
    create?: XOR<ProductoCreateWithoutPromocionesInput, ProductoUncheckedCreateWithoutPromocionesInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPromocionesInput
    upsert?: ProductoUpsertWithoutPromocionesInput
    disconnect?: ProductoWhereInput | boolean
    delete?: ProductoWhereInput | boolean
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutPromocionesInput, ProductoUpdateWithoutPromocionesInput>, ProductoUncheckedUpdateWithoutPromocionesInput>
  }

  export type CategoriaUpdateOneWithoutPromocionesNestedInput = {
    create?: XOR<CategoriaCreateWithoutPromocionesInput, CategoriaUncheckedCreateWithoutPromocionesInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutPromocionesInput
    upsert?: CategoriaUpsertWithoutPromocionesInput
    disconnect?: CategoriaWhereInput | boolean
    delete?: CategoriaWhereInput | boolean
    connect?: CategoriaWhereUniqueInput
    update?: XOR<XOR<CategoriaUpdateToOneWithWhereWithoutPromocionesInput, CategoriaUpdateWithoutPromocionesInput>, CategoriaUncheckedUpdateWithoutPromocionesInput>
  }

  export type HistorialPromocionAplicadaUpdateManyWithoutPromocionNestedInput = {
    create?: XOR<HistorialPromocionAplicadaCreateWithoutPromocionInput, HistorialPromocionAplicadaUncheckedCreateWithoutPromocionInput> | HistorialPromocionAplicadaCreateWithoutPromocionInput[] | HistorialPromocionAplicadaUncheckedCreateWithoutPromocionInput[]
    connectOrCreate?: HistorialPromocionAplicadaCreateOrConnectWithoutPromocionInput | HistorialPromocionAplicadaCreateOrConnectWithoutPromocionInput[]
    upsert?: HistorialPromocionAplicadaUpsertWithWhereUniqueWithoutPromocionInput | HistorialPromocionAplicadaUpsertWithWhereUniqueWithoutPromocionInput[]
    createMany?: HistorialPromocionAplicadaCreateManyPromocionInputEnvelope
    set?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    disconnect?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    delete?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    connect?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    update?: HistorialPromocionAplicadaUpdateWithWhereUniqueWithoutPromocionInput | HistorialPromocionAplicadaUpdateWithWhereUniqueWithoutPromocionInput[]
    updateMany?: HistorialPromocionAplicadaUpdateManyWithWhereWithoutPromocionInput | HistorialPromocionAplicadaUpdateManyWithWhereWithoutPromocionInput[]
    deleteMany?: HistorialPromocionAplicadaScalarWhereInput | HistorialPromocionAplicadaScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HistorialPromocionAplicadaUncheckedUpdateManyWithoutPromocionNestedInput = {
    create?: XOR<HistorialPromocionAplicadaCreateWithoutPromocionInput, HistorialPromocionAplicadaUncheckedCreateWithoutPromocionInput> | HistorialPromocionAplicadaCreateWithoutPromocionInput[] | HistorialPromocionAplicadaUncheckedCreateWithoutPromocionInput[]
    connectOrCreate?: HistorialPromocionAplicadaCreateOrConnectWithoutPromocionInput | HistorialPromocionAplicadaCreateOrConnectWithoutPromocionInput[]
    upsert?: HistorialPromocionAplicadaUpsertWithWhereUniqueWithoutPromocionInput | HistorialPromocionAplicadaUpsertWithWhereUniqueWithoutPromocionInput[]
    createMany?: HistorialPromocionAplicadaCreateManyPromocionInputEnvelope
    set?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    disconnect?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    delete?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    connect?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    update?: HistorialPromocionAplicadaUpdateWithWhereUniqueWithoutPromocionInput | HistorialPromocionAplicadaUpdateWithWhereUniqueWithoutPromocionInput[]
    updateMany?: HistorialPromocionAplicadaUpdateManyWithWhereWithoutPromocionInput | HistorialPromocionAplicadaUpdateManyWithWhereWithoutPromocionInput[]
    deleteMany?: HistorialPromocionAplicadaScalarWhereInput | HistorialPromocionAplicadaScalarWhereInput[]
  }

  export type PromocionCreateNestedOneWithoutHistorialInput = {
    create?: XOR<PromocionCreateWithoutHistorialInput, PromocionUncheckedCreateWithoutHistorialInput>
    connectOrCreate?: PromocionCreateOrConnectWithoutHistorialInput
    connect?: PromocionWhereUniqueInput
  }

  export type PedidoCreateNestedOneWithoutPromociones_aplicadasInput = {
    create?: XOR<PedidoCreateWithoutPromociones_aplicadasInput, PedidoUncheckedCreateWithoutPromociones_aplicadasInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutPromociones_aplicadasInput
    connect?: PedidoWhereUniqueInput
  }

  export type PromocionUpdateOneRequiredWithoutHistorialNestedInput = {
    create?: XOR<PromocionCreateWithoutHistorialInput, PromocionUncheckedCreateWithoutHistorialInput>
    connectOrCreate?: PromocionCreateOrConnectWithoutHistorialInput
    upsert?: PromocionUpsertWithoutHistorialInput
    connect?: PromocionWhereUniqueInput
    update?: XOR<XOR<PromocionUpdateToOneWithWhereWithoutHistorialInput, PromocionUpdateWithoutHistorialInput>, PromocionUncheckedUpdateWithoutHistorialInput>
  }

  export type PedidoUpdateOneRequiredWithoutPromociones_aplicadasNestedInput = {
    create?: XOR<PedidoCreateWithoutPromociones_aplicadasInput, PedidoUncheckedCreateWithoutPromociones_aplicadasInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutPromociones_aplicadasInput
    upsert?: PedidoUpsertWithoutPromociones_aplicadasInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<XOR<PedidoUpdateToOneWithWhereWithoutPromociones_aplicadasInput, PedidoUpdateWithoutPromociones_aplicadasInput>, PedidoUncheckedUpdateWithoutPromociones_aplicadasInput>
  }

  export type UsuarioCreateNestedOneWithoutPedidosInput = {
    create?: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPedidosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PedidoItemCreateNestedManyWithoutPedidoInput = {
    create?: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput> | PedidoItemCreateWithoutPedidoInput[] | PedidoItemUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutPedidoInput | PedidoItemCreateOrConnectWithoutPedidoInput[]
    createMany?: PedidoItemCreateManyPedidoInputEnvelope
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
  }

  export type TransicionEstadoPedidoCreateNestedManyWithoutPedidoInput = {
    create?: XOR<TransicionEstadoPedidoCreateWithoutPedidoInput, TransicionEstadoPedidoUncheckedCreateWithoutPedidoInput> | TransicionEstadoPedidoCreateWithoutPedidoInput[] | TransicionEstadoPedidoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: TransicionEstadoPedidoCreateOrConnectWithoutPedidoInput | TransicionEstadoPedidoCreateOrConnectWithoutPedidoInput[]
    createMany?: TransicionEstadoPedidoCreateManyPedidoInputEnvelope
    connect?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
  }

  export type HistorialPromocionAplicadaCreateNestedManyWithoutPedidoInput = {
    create?: XOR<HistorialPromocionAplicadaCreateWithoutPedidoInput, HistorialPromocionAplicadaUncheckedCreateWithoutPedidoInput> | HistorialPromocionAplicadaCreateWithoutPedidoInput[] | HistorialPromocionAplicadaUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: HistorialPromocionAplicadaCreateOrConnectWithoutPedidoInput | HistorialPromocionAplicadaCreateOrConnectWithoutPedidoInput[]
    createMany?: HistorialPromocionAplicadaCreateManyPedidoInputEnvelope
    connect?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
  }

  export type PedidoItemUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput> | PedidoItemCreateWithoutPedidoInput[] | PedidoItemUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutPedidoInput | PedidoItemCreateOrConnectWithoutPedidoInput[]
    createMany?: PedidoItemCreateManyPedidoInputEnvelope
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
  }

  export type TransicionEstadoPedidoUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<TransicionEstadoPedidoCreateWithoutPedidoInput, TransicionEstadoPedidoUncheckedCreateWithoutPedidoInput> | TransicionEstadoPedidoCreateWithoutPedidoInput[] | TransicionEstadoPedidoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: TransicionEstadoPedidoCreateOrConnectWithoutPedidoInput | TransicionEstadoPedidoCreateOrConnectWithoutPedidoInput[]
    createMany?: TransicionEstadoPedidoCreateManyPedidoInputEnvelope
    connect?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
  }

  export type HistorialPromocionAplicadaUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<HistorialPromocionAplicadaCreateWithoutPedidoInput, HistorialPromocionAplicadaUncheckedCreateWithoutPedidoInput> | HistorialPromocionAplicadaCreateWithoutPedidoInput[] | HistorialPromocionAplicadaUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: HistorialPromocionAplicadaCreateOrConnectWithoutPedidoInput | HistorialPromocionAplicadaCreateOrConnectWithoutPedidoInput[]
    createMany?: HistorialPromocionAplicadaCreateManyPedidoInputEnvelope
    connect?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
  }

  export type EnumMetodoPagoFieldUpdateOperationsInput = {
    set?: $Enums.MetodoPago
  }

  export type UsuarioUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPedidosInput
    upsert?: UsuarioUpsertWithoutPedidosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPedidosInput, UsuarioUpdateWithoutPedidosInput>, UsuarioUncheckedUpdateWithoutPedidosInput>
  }

  export type PedidoItemUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput> | PedidoItemCreateWithoutPedidoInput[] | PedidoItemUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutPedidoInput | PedidoItemCreateOrConnectWithoutPedidoInput[]
    upsert?: PedidoItemUpsertWithWhereUniqueWithoutPedidoInput | PedidoItemUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: PedidoItemCreateManyPedidoInputEnvelope
    set?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    disconnect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    delete?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    update?: PedidoItemUpdateWithWhereUniqueWithoutPedidoInput | PedidoItemUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: PedidoItemUpdateManyWithWhereWithoutPedidoInput | PedidoItemUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
  }

  export type TransicionEstadoPedidoUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<TransicionEstadoPedidoCreateWithoutPedidoInput, TransicionEstadoPedidoUncheckedCreateWithoutPedidoInput> | TransicionEstadoPedidoCreateWithoutPedidoInput[] | TransicionEstadoPedidoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: TransicionEstadoPedidoCreateOrConnectWithoutPedidoInput | TransicionEstadoPedidoCreateOrConnectWithoutPedidoInput[]
    upsert?: TransicionEstadoPedidoUpsertWithWhereUniqueWithoutPedidoInput | TransicionEstadoPedidoUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: TransicionEstadoPedidoCreateManyPedidoInputEnvelope
    set?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    disconnect?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    delete?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    connect?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    update?: TransicionEstadoPedidoUpdateWithWhereUniqueWithoutPedidoInput | TransicionEstadoPedidoUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: TransicionEstadoPedidoUpdateManyWithWhereWithoutPedidoInput | TransicionEstadoPedidoUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: TransicionEstadoPedidoScalarWhereInput | TransicionEstadoPedidoScalarWhereInput[]
  }

  export type HistorialPromocionAplicadaUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<HistorialPromocionAplicadaCreateWithoutPedidoInput, HistorialPromocionAplicadaUncheckedCreateWithoutPedidoInput> | HistorialPromocionAplicadaCreateWithoutPedidoInput[] | HistorialPromocionAplicadaUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: HistorialPromocionAplicadaCreateOrConnectWithoutPedidoInput | HistorialPromocionAplicadaCreateOrConnectWithoutPedidoInput[]
    upsert?: HistorialPromocionAplicadaUpsertWithWhereUniqueWithoutPedidoInput | HistorialPromocionAplicadaUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: HistorialPromocionAplicadaCreateManyPedidoInputEnvelope
    set?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    disconnect?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    delete?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    connect?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    update?: HistorialPromocionAplicadaUpdateWithWhereUniqueWithoutPedidoInput | HistorialPromocionAplicadaUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: HistorialPromocionAplicadaUpdateManyWithWhereWithoutPedidoInput | HistorialPromocionAplicadaUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: HistorialPromocionAplicadaScalarWhereInput | HistorialPromocionAplicadaScalarWhereInput[]
  }

  export type PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput> | PedidoItemCreateWithoutPedidoInput[] | PedidoItemUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoItemCreateOrConnectWithoutPedidoInput | PedidoItemCreateOrConnectWithoutPedidoInput[]
    upsert?: PedidoItemUpsertWithWhereUniqueWithoutPedidoInput | PedidoItemUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: PedidoItemCreateManyPedidoInputEnvelope
    set?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    disconnect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    delete?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    connect?: PedidoItemWhereUniqueInput | PedidoItemWhereUniqueInput[]
    update?: PedidoItemUpdateWithWhereUniqueWithoutPedidoInput | PedidoItemUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: PedidoItemUpdateManyWithWhereWithoutPedidoInput | PedidoItemUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
  }

  export type TransicionEstadoPedidoUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<TransicionEstadoPedidoCreateWithoutPedidoInput, TransicionEstadoPedidoUncheckedCreateWithoutPedidoInput> | TransicionEstadoPedidoCreateWithoutPedidoInput[] | TransicionEstadoPedidoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: TransicionEstadoPedidoCreateOrConnectWithoutPedidoInput | TransicionEstadoPedidoCreateOrConnectWithoutPedidoInput[]
    upsert?: TransicionEstadoPedidoUpsertWithWhereUniqueWithoutPedidoInput | TransicionEstadoPedidoUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: TransicionEstadoPedidoCreateManyPedidoInputEnvelope
    set?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    disconnect?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    delete?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    connect?: TransicionEstadoPedidoWhereUniqueInput | TransicionEstadoPedidoWhereUniqueInput[]
    update?: TransicionEstadoPedidoUpdateWithWhereUniqueWithoutPedidoInput | TransicionEstadoPedidoUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: TransicionEstadoPedidoUpdateManyWithWhereWithoutPedidoInput | TransicionEstadoPedidoUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: TransicionEstadoPedidoScalarWhereInput | TransicionEstadoPedidoScalarWhereInput[]
  }

  export type HistorialPromocionAplicadaUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<HistorialPromocionAplicadaCreateWithoutPedidoInput, HistorialPromocionAplicadaUncheckedCreateWithoutPedidoInput> | HistorialPromocionAplicadaCreateWithoutPedidoInput[] | HistorialPromocionAplicadaUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: HistorialPromocionAplicadaCreateOrConnectWithoutPedidoInput | HistorialPromocionAplicadaCreateOrConnectWithoutPedidoInput[]
    upsert?: HistorialPromocionAplicadaUpsertWithWhereUniqueWithoutPedidoInput | HistorialPromocionAplicadaUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: HistorialPromocionAplicadaCreateManyPedidoInputEnvelope
    set?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    disconnect?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    delete?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    connect?: HistorialPromocionAplicadaWhereUniqueInput | HistorialPromocionAplicadaWhereUniqueInput[]
    update?: HistorialPromocionAplicadaUpdateWithWhereUniqueWithoutPedidoInput | HistorialPromocionAplicadaUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: HistorialPromocionAplicadaUpdateManyWithWhereWithoutPedidoInput | HistorialPromocionAplicadaUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: HistorialPromocionAplicadaScalarWhereInput | HistorialPromocionAplicadaScalarWhereInput[]
  }

  export type PedidoCreateNestedOneWithoutItemsInput = {
    create?: XOR<PedidoCreateWithoutItemsInput, PedidoUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutItemsInput
    connect?: PedidoWhereUniqueInput
  }

  export type ProductoCreateNestedOneWithoutPedidoItemsInput = {
    create?: XOR<ProductoCreateWithoutPedidoItemsInput, ProductoUncheckedCreateWithoutPedidoItemsInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPedidoItemsInput
    connect?: ProductoWhereUniqueInput
  }

  export type ProductoPersonalizableCreateNestedOneWithoutPedidoItemsInput = {
    create?: XOR<ProductoPersonalizableCreateWithoutPedidoItemsInput, ProductoPersonalizableUncheckedCreateWithoutPedidoItemsInput>
    connectOrCreate?: ProductoPersonalizableCreateOrConnectWithoutPedidoItemsInput
    connect?: ProductoPersonalizableWhereUniqueInput
  }

  export type PedidoUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PedidoCreateWithoutItemsInput, PedidoUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutItemsInput
    upsert?: PedidoUpsertWithoutItemsInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<XOR<PedidoUpdateToOneWithWhereWithoutItemsInput, PedidoUpdateWithoutItemsInput>, PedidoUncheckedUpdateWithoutItemsInput>
  }

  export type ProductoUpdateOneRequiredWithoutPedidoItemsNestedInput = {
    create?: XOR<ProductoCreateWithoutPedidoItemsInput, ProductoUncheckedCreateWithoutPedidoItemsInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutPedidoItemsInput
    upsert?: ProductoUpsertWithoutPedidoItemsInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<XOR<ProductoUpdateToOneWithWhereWithoutPedidoItemsInput, ProductoUpdateWithoutPedidoItemsInput>, ProductoUncheckedUpdateWithoutPedidoItemsInput>
  }

  export type ProductoPersonalizableUpdateOneWithoutPedidoItemsNestedInput = {
    create?: XOR<ProductoPersonalizableCreateWithoutPedidoItemsInput, ProductoPersonalizableUncheckedCreateWithoutPedidoItemsInput>
    connectOrCreate?: ProductoPersonalizableCreateOrConnectWithoutPedidoItemsInput
    upsert?: ProductoPersonalizableUpsertWithoutPedidoItemsInput
    disconnect?: ProductoPersonalizableWhereInput | boolean
    delete?: ProductoPersonalizableWhereInput | boolean
    connect?: ProductoPersonalizableWhereUniqueInput
    update?: XOR<XOR<ProductoPersonalizableUpdateToOneWithWhereWithoutPedidoItemsInput, ProductoPersonalizableUpdateWithoutPedidoItemsInput>, ProductoPersonalizableUncheckedUpdateWithoutPedidoItemsInput>
  }

  export type PedidoCreateNestedOneWithoutTransicionesInput = {
    create?: XOR<PedidoCreateWithoutTransicionesInput, PedidoUncheckedCreateWithoutTransicionesInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutTransicionesInput
    connect?: PedidoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutTransiciones_estadoInput = {
    create?: XOR<UsuarioCreateWithoutTransiciones_estadoInput, UsuarioUncheckedCreateWithoutTransiciones_estadoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTransiciones_estadoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EnumEstadoPedidoFieldUpdateOperationsInput = {
    set?: $Enums.EstadoPedido
  }

  export type PedidoUpdateOneRequiredWithoutTransicionesNestedInput = {
    create?: XOR<PedidoCreateWithoutTransicionesInput, PedidoUncheckedCreateWithoutTransicionesInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutTransicionesInput
    upsert?: PedidoUpsertWithoutTransicionesInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<XOR<PedidoUpdateToOneWithWhereWithoutTransicionesInput, PedidoUpdateWithoutTransicionesInput>, PedidoUncheckedUpdateWithoutTransicionesInput>
  }

  export type UsuarioUpdateOneRequiredWithoutTransiciones_estadoNestedInput = {
    create?: XOR<UsuarioCreateWithoutTransiciones_estadoInput, UsuarioUncheckedCreateWithoutTransiciones_estadoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTransiciones_estadoInput
    upsert?: UsuarioUpsertWithoutTransiciones_estadoInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutTransiciones_estadoInput, UsuarioUpdateWithoutTransiciones_estadoInput>, UsuarioUncheckedUpdateWithoutTransiciones_estadoInput>
  }

  export type ResenaCreateNestedOneWithoutReportesInput = {
    create?: XOR<ResenaCreateWithoutReportesInput, ResenaUncheckedCreateWithoutReportesInput>
    connectOrCreate?: ResenaCreateOrConnectWithoutReportesInput
    connect?: ResenaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutReportes_resenaInput = {
    create?: XOR<UsuarioCreateWithoutReportes_resenaInput, UsuarioUncheckedCreateWithoutReportes_resenaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutReportes_resenaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ResenaUpdateOneRequiredWithoutReportesNestedInput = {
    create?: XOR<ResenaCreateWithoutReportesInput, ResenaUncheckedCreateWithoutReportesInput>
    connectOrCreate?: ResenaCreateOrConnectWithoutReportesInput
    upsert?: ResenaUpsertWithoutReportesInput
    connect?: ResenaWhereUniqueInput
    update?: XOR<XOR<ResenaUpdateToOneWithWhereWithoutReportesInput, ResenaUpdateWithoutReportesInput>, ResenaUncheckedUpdateWithoutReportesInput>
  }

  export type UsuarioUpdateOneRequiredWithoutReportes_resenaNestedInput = {
    create?: XOR<UsuarioCreateWithoutReportes_resenaInput, UsuarioUncheckedCreateWithoutReportes_resenaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutReportes_resenaInput
    upsert?: UsuarioUpsertWithoutReportes_resenaInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutReportes_resenaInput, UsuarioUpdateWithoutReportes_resenaInput>, UsuarioUncheckedUpdateWithoutReportes_resenaInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTipoPromocionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoPromocion | EnumTipoPromocionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoPromocion[]
    notIn?: $Enums.TipoPromocion[]
    not?: NestedEnumTipoPromocionFilter<$PrismaModel> | $Enums.TipoPromocion
  }

  export type NestedEnumTipoPromocionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoPromocion | EnumTipoPromocionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoPromocion[]
    notIn?: $Enums.TipoPromocion[]
    not?: NestedEnumTipoPromocionWithAggregatesFilter<$PrismaModel> | $Enums.TipoPromocion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoPromocionFilter<$PrismaModel>
    _max?: NestedEnumTipoPromocionFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMetodoPagoFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoPago | EnumMetodoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoPago[]
    notIn?: $Enums.MetodoPago[]
    not?: NestedEnumMetodoPagoFilter<$PrismaModel> | $Enums.MetodoPago
  }

  export type NestedEnumMetodoPagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoPago | EnumMetodoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoPago[]
    notIn?: $Enums.MetodoPago[]
    not?: NestedEnumMetodoPagoWithAggregatesFilter<$PrismaModel> | $Enums.MetodoPago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetodoPagoFilter<$PrismaModel>
    _max?: NestedEnumMetodoPagoFilter<$PrismaModel>
  }

  export type NestedEnumEstadoPedidoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPedido | EnumEstadoPedidoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPedido[]
    notIn?: $Enums.EstadoPedido[]
    not?: NestedEnumEstadoPedidoFilter<$PrismaModel> | $Enums.EstadoPedido
  }

  export type NestedEnumEstadoPedidoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPedido | EnumEstadoPedidoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPedido[]
    notIn?: $Enums.EstadoPedido[]
    not?: NestedEnumEstadoPedidoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPedido
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPedidoFilter<$PrismaModel>
    _max?: NestedEnumEstadoPedidoFilter<$PrismaModel>
  }

  export type ResenaCreateWithoutUsuarioInput = {
    comentario: string
    valoracion: number
    fecha: Date | string
    visible?: boolean
    producto: ProductoCreateNestedOneWithoutResenasInput
    reportes?: ReporteResenaCreateNestedManyWithoutResenaInput
  }

  export type ResenaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    producto_id: number
    comentario: string
    valoracion: number
    fecha: Date | string
    visible?: boolean
    reportes?: ReporteResenaUncheckedCreateNestedManyWithoutResenaInput
  }

  export type ResenaCreateOrConnectWithoutUsuarioInput = {
    where: ResenaWhereUniqueInput
    create: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput>
  }

  export type ResenaCreateManyUsuarioInputEnvelope = {
    data: ResenaCreateManyUsuarioInput | ResenaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type PedidoCreateWithoutUsuarioInput = {
    fecha_pedido: Date | string
    direccion_envio: string
    metodo_pago: $Enums.MetodoPago
    subtotal: number
    total: number
    impuestos: number
    estado_carrito?: boolean
    items?: PedidoItemCreateNestedManyWithoutPedidoInput
    transiciones?: TransicionEstadoPedidoCreateNestedManyWithoutPedidoInput
    promociones_aplicadas?: HistorialPromocionAplicadaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    fecha_pedido: Date | string
    direccion_envio: string
    metodo_pago: $Enums.MetodoPago
    subtotal: number
    total: number
    impuestos: number
    estado_carrito?: boolean
    items?: PedidoItemUncheckedCreateNestedManyWithoutPedidoInput
    transiciones?: TransicionEstadoPedidoUncheckedCreateNestedManyWithoutPedidoInput
    promociones_aplicadas?: HistorialPromocionAplicadaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput>
  }

  export type PedidoCreateManyUsuarioInputEnvelope = {
    data: PedidoCreateManyUsuarioInput | PedidoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type TransicionEstadoPedidoCreateWithoutAdminInput = {
    estado: $Enums.EstadoPedido
    fecha_hora: Date | string
    pedido: PedidoCreateNestedOneWithoutTransicionesInput
  }

  export type TransicionEstadoPedidoUncheckedCreateWithoutAdminInput = {
    id?: number
    pedido_id: number
    estado: $Enums.EstadoPedido
    fecha_hora: Date | string
  }

  export type TransicionEstadoPedidoCreateOrConnectWithoutAdminInput = {
    where: TransicionEstadoPedidoWhereUniqueInput
    create: XOR<TransicionEstadoPedidoCreateWithoutAdminInput, TransicionEstadoPedidoUncheckedCreateWithoutAdminInput>
  }

  export type TransicionEstadoPedidoCreateManyAdminInputEnvelope = {
    data: TransicionEstadoPedidoCreateManyAdminInput | TransicionEstadoPedidoCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type ReporteResenaCreateWithoutUsuarioInput = {
    comentario: string
    resena: ResenaCreateNestedOneWithoutReportesInput
  }

  export type ReporteResenaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    resena_id: number
    comentario: string
  }

  export type ReporteResenaCreateOrConnectWithoutUsuarioInput = {
    where: ReporteResenaWhereUniqueInput
    create: XOR<ReporteResenaCreateWithoutUsuarioInput, ReporteResenaUncheckedCreateWithoutUsuarioInput>
  }

  export type ReporteResenaCreateManyUsuarioInputEnvelope = {
    data: ReporteResenaCreateManyUsuarioInput | ReporteResenaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type ResenaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ResenaWhereUniqueInput
    update: XOR<ResenaUpdateWithoutUsuarioInput, ResenaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput>
  }

  export type ResenaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ResenaWhereUniqueInput
    data: XOR<ResenaUpdateWithoutUsuarioInput, ResenaUncheckedUpdateWithoutUsuarioInput>
  }

  export type ResenaUpdateManyWithWhereWithoutUsuarioInput = {
    where: ResenaScalarWhereInput
    data: XOR<ResenaUpdateManyMutationInput, ResenaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ResenaScalarWhereInput = {
    AND?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
    OR?: ResenaScalarWhereInput[]
    NOT?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
    id?: IntFilter<"Resena"> | number
    usuario_id?: IntFilter<"Resena"> | number
    producto_id?: IntFilter<"Resena"> | number
    comentario?: StringFilter<"Resena"> | string
    valoracion?: IntFilter<"Resena"> | number
    fecha?: DateTimeFilter<"Resena"> | Date | string
    visible?: BoolFilter<"Resena"> | boolean
  }

  export type PedidoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutUsuarioInput, PedidoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutUsuarioInput, PedidoUncheckedUpdateWithoutUsuarioInput>
  }

  export type PedidoUpdateManyWithWhereWithoutUsuarioInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type PedidoScalarWhereInput = {
    AND?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
    OR?: PedidoScalarWhereInput[]
    NOT?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
    id?: IntFilter<"Pedido"> | number
    usuario_id?: IntFilter<"Pedido"> | number
    fecha_pedido?: DateTimeFilter<"Pedido"> | Date | string
    direccion_envio?: StringFilter<"Pedido"> | string
    metodo_pago?: EnumMetodoPagoFilter<"Pedido"> | $Enums.MetodoPago
    subtotal?: FloatFilter<"Pedido"> | number
    total?: FloatFilter<"Pedido"> | number
    impuestos?: FloatFilter<"Pedido"> | number
    estado_carrito?: BoolFilter<"Pedido"> | boolean
  }

  export type TransicionEstadoPedidoUpsertWithWhereUniqueWithoutAdminInput = {
    where: TransicionEstadoPedidoWhereUniqueInput
    update: XOR<TransicionEstadoPedidoUpdateWithoutAdminInput, TransicionEstadoPedidoUncheckedUpdateWithoutAdminInput>
    create: XOR<TransicionEstadoPedidoCreateWithoutAdminInput, TransicionEstadoPedidoUncheckedCreateWithoutAdminInput>
  }

  export type TransicionEstadoPedidoUpdateWithWhereUniqueWithoutAdminInput = {
    where: TransicionEstadoPedidoWhereUniqueInput
    data: XOR<TransicionEstadoPedidoUpdateWithoutAdminInput, TransicionEstadoPedidoUncheckedUpdateWithoutAdminInput>
  }

  export type TransicionEstadoPedidoUpdateManyWithWhereWithoutAdminInput = {
    where: TransicionEstadoPedidoScalarWhereInput
    data: XOR<TransicionEstadoPedidoUpdateManyMutationInput, TransicionEstadoPedidoUncheckedUpdateManyWithoutAdminInput>
  }

  export type TransicionEstadoPedidoScalarWhereInput = {
    AND?: TransicionEstadoPedidoScalarWhereInput | TransicionEstadoPedidoScalarWhereInput[]
    OR?: TransicionEstadoPedidoScalarWhereInput[]
    NOT?: TransicionEstadoPedidoScalarWhereInput | TransicionEstadoPedidoScalarWhereInput[]
    id?: IntFilter<"TransicionEstadoPedido"> | number
    pedido_id?: IntFilter<"TransicionEstadoPedido"> | number
    estado?: EnumEstadoPedidoFilter<"TransicionEstadoPedido"> | $Enums.EstadoPedido
    fecha_hora?: DateTimeFilter<"TransicionEstadoPedido"> | Date | string
    admin_id?: IntFilter<"TransicionEstadoPedido"> | number
  }

  export type ReporteResenaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ReporteResenaWhereUniqueInput
    update: XOR<ReporteResenaUpdateWithoutUsuarioInput, ReporteResenaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ReporteResenaCreateWithoutUsuarioInput, ReporteResenaUncheckedCreateWithoutUsuarioInput>
  }

  export type ReporteResenaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ReporteResenaWhereUniqueInput
    data: XOR<ReporteResenaUpdateWithoutUsuarioInput, ReporteResenaUncheckedUpdateWithoutUsuarioInput>
  }

  export type ReporteResenaUpdateManyWithWhereWithoutUsuarioInput = {
    where: ReporteResenaScalarWhereInput
    data: XOR<ReporteResenaUpdateManyMutationInput, ReporteResenaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ReporteResenaScalarWhereInput = {
    AND?: ReporteResenaScalarWhereInput | ReporteResenaScalarWhereInput[]
    OR?: ReporteResenaScalarWhereInput[]
    NOT?: ReporteResenaScalarWhereInput | ReporteResenaScalarWhereInput[]
    id?: IntFilter<"ReporteResena"> | number
    resena_id?: IntFilter<"ReporteResena"> | number
    usuario_id?: IntFilter<"ReporteResena"> | number
    comentario?: StringFilter<"ReporteResena"> | string
  }

  export type ProductoCreateWithoutCategoriaInput = {
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    promedio_valoracion?: number
    activo?: boolean
    imagenes?: ImagenProductoCreateNestedManyWithoutProductoInput
    etiquetas?: ProductoEtiquetaCreateNestedManyWithoutProductoInput
    resenas?: ResenaCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    promociones?: PromocionCreateNestedManyWithoutProductoInput
    productosPersonalizables?: ProductoPersonalizableCreateNestedManyWithoutProducto_baseInput
  }

  export type ProductoUncheckedCreateWithoutCategoriaInput = {
    id?: number
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    promedio_valoracion?: number
    activo?: boolean
    imagenes?: ImagenProductoUncheckedCreateNestedManyWithoutProductoInput
    etiquetas?: ProductoEtiquetaUncheckedCreateNestedManyWithoutProductoInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutProductoInput
    productosPersonalizables?: ProductoPersonalizableUncheckedCreateNestedManyWithoutProducto_baseInput
  }

  export type ProductoCreateOrConnectWithoutCategoriaInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutCategoriaInput, ProductoUncheckedCreateWithoutCategoriaInput>
  }

  export type ProductoCreateManyCategoriaInputEnvelope = {
    data: ProductoCreateManyCategoriaInput | ProductoCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type PromocionCreateWithoutCategoriaInput = {
    nombre: string
    tipo: $Enums.TipoPromocion
    valor: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    producto?: ProductoCreateNestedOneWithoutPromocionesInput
    historial?: HistorialPromocionAplicadaCreateNestedManyWithoutPromocionInput
  }

  export type PromocionUncheckedCreateWithoutCategoriaInput = {
    id?: number
    nombre: string
    tipo: $Enums.TipoPromocion
    referencia_id_producto?: number | null
    valor: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    historial?: HistorialPromocionAplicadaUncheckedCreateNestedManyWithoutPromocionInput
  }

  export type PromocionCreateOrConnectWithoutCategoriaInput = {
    where: PromocionWhereUniqueInput
    create: XOR<PromocionCreateWithoutCategoriaInput, PromocionUncheckedCreateWithoutCategoriaInput>
  }

  export type PromocionCreateManyCategoriaInputEnvelope = {
    data: PromocionCreateManyCategoriaInput | PromocionCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type ProductoPersonalizableCreateWithoutCategoriaInput = {
    nombre: string
    descripcion_general: string
    activo?: boolean
    producto_base: ProductoCreateNestedOneWithoutProductosPersonalizablesInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProducto_personalizadoInput
    variantes?: VarianteDetalleCreateNestedManyWithoutProductoPersonalizableInput
  }

  export type ProductoPersonalizableUncheckedCreateWithoutCategoriaInput = {
    id?: number
    nombre: string
    descripcion_general: string
    id_producto_base: number
    activo?: boolean
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProducto_personalizadoInput
    variantes?: VarianteDetalleUncheckedCreateNestedManyWithoutProductoPersonalizableInput
  }

  export type ProductoPersonalizableCreateOrConnectWithoutCategoriaInput = {
    where: ProductoPersonalizableWhereUniqueInput
    create: XOR<ProductoPersonalizableCreateWithoutCategoriaInput, ProductoPersonalizableUncheckedCreateWithoutCategoriaInput>
  }

  export type ProductoPersonalizableCreateManyCategoriaInputEnvelope = {
    data: ProductoPersonalizableCreateManyCategoriaInput | ProductoPersonalizableCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type ProductoUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: ProductoWhereUniqueInput
    update: XOR<ProductoUpdateWithoutCategoriaInput, ProductoUncheckedUpdateWithoutCategoriaInput>
    create: XOR<ProductoCreateWithoutCategoriaInput, ProductoUncheckedCreateWithoutCategoriaInput>
  }

  export type ProductoUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: ProductoWhereUniqueInput
    data: XOR<ProductoUpdateWithoutCategoriaInput, ProductoUncheckedUpdateWithoutCategoriaInput>
  }

  export type ProductoUpdateManyWithWhereWithoutCategoriaInput = {
    where: ProductoScalarWhereInput
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type ProductoScalarWhereInput = {
    AND?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
    OR?: ProductoScalarWhereInput[]
    NOT?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
    id?: IntFilter<"Producto"> | number
    nombre?: StringFilter<"Producto"> | string
    descripcion?: StringFilter<"Producto"> | string
    precio_base?: FloatFilter<"Producto"> | number
    stock?: IntFilter<"Producto"> | number
    categoria_id?: IntFilter<"Producto"> | number
    promedio_valoracion?: FloatFilter<"Producto"> | number
    activo?: BoolFilter<"Producto"> | boolean
  }

  export type PromocionUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: PromocionWhereUniqueInput
    update: XOR<PromocionUpdateWithoutCategoriaInput, PromocionUncheckedUpdateWithoutCategoriaInput>
    create: XOR<PromocionCreateWithoutCategoriaInput, PromocionUncheckedCreateWithoutCategoriaInput>
  }

  export type PromocionUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: PromocionWhereUniqueInput
    data: XOR<PromocionUpdateWithoutCategoriaInput, PromocionUncheckedUpdateWithoutCategoriaInput>
  }

  export type PromocionUpdateManyWithWhereWithoutCategoriaInput = {
    where: PromocionScalarWhereInput
    data: XOR<PromocionUpdateManyMutationInput, PromocionUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type PromocionScalarWhereInput = {
    AND?: PromocionScalarWhereInput | PromocionScalarWhereInput[]
    OR?: PromocionScalarWhereInput[]
    NOT?: PromocionScalarWhereInput | PromocionScalarWhereInput[]
    id?: IntFilter<"Promocion"> | number
    nombre?: StringFilter<"Promocion"> | string
    tipo?: EnumTipoPromocionFilter<"Promocion"> | $Enums.TipoPromocion
    referencia_id_producto?: IntNullableFilter<"Promocion"> | number | null
    referencia_id_categoria?: IntNullableFilter<"Promocion"> | number | null
    valor?: FloatFilter<"Promocion"> | number
    fecha_inicio?: DateTimeFilter<"Promocion"> | Date | string
    fecha_fin?: DateTimeFilter<"Promocion"> | Date | string
  }

  export type ProductoPersonalizableUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: ProductoPersonalizableWhereUniqueInput
    update: XOR<ProductoPersonalizableUpdateWithoutCategoriaInput, ProductoPersonalizableUncheckedUpdateWithoutCategoriaInput>
    create: XOR<ProductoPersonalizableCreateWithoutCategoriaInput, ProductoPersonalizableUncheckedCreateWithoutCategoriaInput>
  }

  export type ProductoPersonalizableUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: ProductoPersonalizableWhereUniqueInput
    data: XOR<ProductoPersonalizableUpdateWithoutCategoriaInput, ProductoPersonalizableUncheckedUpdateWithoutCategoriaInput>
  }

  export type ProductoPersonalizableUpdateManyWithWhereWithoutCategoriaInput = {
    where: ProductoPersonalizableScalarWhereInput
    data: XOR<ProductoPersonalizableUpdateManyMutationInput, ProductoPersonalizableUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type ProductoPersonalizableScalarWhereInput = {
    AND?: ProductoPersonalizableScalarWhereInput | ProductoPersonalizableScalarWhereInput[]
    OR?: ProductoPersonalizableScalarWhereInput[]
    NOT?: ProductoPersonalizableScalarWhereInput | ProductoPersonalizableScalarWhereInput[]
    id?: IntFilter<"ProductoPersonalizable"> | number
    nombre?: StringFilter<"ProductoPersonalizable"> | string
    descripcion_general?: StringFilter<"ProductoPersonalizable"> | string
    id_categoria?: IntFilter<"ProductoPersonalizable"> | number
    id_producto_base?: IntFilter<"ProductoPersonalizable"> | number
    activo?: BoolFilter<"ProductoPersonalizable"> | boolean
  }

  export type ProductoEtiquetaCreateWithoutEtiquetaInput = {
    producto: ProductoCreateNestedOneWithoutEtiquetasInput
  }

  export type ProductoEtiquetaUncheckedCreateWithoutEtiquetaInput = {
    producto_id: number
  }

  export type ProductoEtiquetaCreateOrConnectWithoutEtiquetaInput = {
    where: ProductoEtiquetaWhereUniqueInput
    create: XOR<ProductoEtiquetaCreateWithoutEtiquetaInput, ProductoEtiquetaUncheckedCreateWithoutEtiquetaInput>
  }

  export type ProductoEtiquetaCreateManyEtiquetaInputEnvelope = {
    data: ProductoEtiquetaCreateManyEtiquetaInput | ProductoEtiquetaCreateManyEtiquetaInput[]
    skipDuplicates?: boolean
  }

  export type ProductoEtiquetaUpsertWithWhereUniqueWithoutEtiquetaInput = {
    where: ProductoEtiquetaWhereUniqueInput
    update: XOR<ProductoEtiquetaUpdateWithoutEtiquetaInput, ProductoEtiquetaUncheckedUpdateWithoutEtiquetaInput>
    create: XOR<ProductoEtiquetaCreateWithoutEtiquetaInput, ProductoEtiquetaUncheckedCreateWithoutEtiquetaInput>
  }

  export type ProductoEtiquetaUpdateWithWhereUniqueWithoutEtiquetaInput = {
    where: ProductoEtiquetaWhereUniqueInput
    data: XOR<ProductoEtiquetaUpdateWithoutEtiquetaInput, ProductoEtiquetaUncheckedUpdateWithoutEtiquetaInput>
  }

  export type ProductoEtiquetaUpdateManyWithWhereWithoutEtiquetaInput = {
    where: ProductoEtiquetaScalarWhereInput
    data: XOR<ProductoEtiquetaUpdateManyMutationInput, ProductoEtiquetaUncheckedUpdateManyWithoutEtiquetaInput>
  }

  export type ProductoEtiquetaScalarWhereInput = {
    AND?: ProductoEtiquetaScalarWhereInput | ProductoEtiquetaScalarWhereInput[]
    OR?: ProductoEtiquetaScalarWhereInput[]
    NOT?: ProductoEtiquetaScalarWhereInput | ProductoEtiquetaScalarWhereInput[]
    producto_id?: IntFilter<"ProductoEtiqueta"> | number
    etiqueta_id?: IntFilter<"ProductoEtiqueta"> | number
  }

  export type CategoriaCreateWithoutProductosInput = {
    nombre: string
    descripcion: string
    promociones?: PromocionCreateNestedManyWithoutCategoriaInput
    productosPersonalizables?: ProductoPersonalizableCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateWithoutProductosInput = {
    id?: number
    nombre: string
    descripcion: string
    promociones?: PromocionUncheckedCreateNestedManyWithoutCategoriaInput
    productosPersonalizables?: ProductoPersonalizableUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaCreateOrConnectWithoutProductosInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutProductosInput, CategoriaUncheckedCreateWithoutProductosInput>
  }

  export type ImagenProductoCreateWithoutProductoInput = {
    url?: string
  }

  export type ImagenProductoUncheckedCreateWithoutProductoInput = {
    id?: number
    url?: string
  }

  export type ImagenProductoCreateOrConnectWithoutProductoInput = {
    where: ImagenProductoWhereUniqueInput
    create: XOR<ImagenProductoCreateWithoutProductoInput, ImagenProductoUncheckedCreateWithoutProductoInput>
  }

  export type ImagenProductoCreateManyProductoInputEnvelope = {
    data: ImagenProductoCreateManyProductoInput | ImagenProductoCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type ProductoEtiquetaCreateWithoutProductoInput = {
    etiqueta: EtiquetaCreateNestedOneWithoutProductosInput
  }

  export type ProductoEtiquetaUncheckedCreateWithoutProductoInput = {
    etiqueta_id: number
  }

  export type ProductoEtiquetaCreateOrConnectWithoutProductoInput = {
    where: ProductoEtiquetaWhereUniqueInput
    create: XOR<ProductoEtiquetaCreateWithoutProductoInput, ProductoEtiquetaUncheckedCreateWithoutProductoInput>
  }

  export type ProductoEtiquetaCreateManyProductoInputEnvelope = {
    data: ProductoEtiquetaCreateManyProductoInput | ProductoEtiquetaCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type ResenaCreateWithoutProductoInput = {
    comentario: string
    valoracion: number
    fecha: Date | string
    visible?: boolean
    usuario: UsuarioCreateNestedOneWithoutResenasInput
    reportes?: ReporteResenaCreateNestedManyWithoutResenaInput
  }

  export type ResenaUncheckedCreateWithoutProductoInput = {
    id?: number
    usuario_id: number
    comentario: string
    valoracion: number
    fecha: Date | string
    visible?: boolean
    reportes?: ReporteResenaUncheckedCreateNestedManyWithoutResenaInput
  }

  export type ResenaCreateOrConnectWithoutProductoInput = {
    where: ResenaWhereUniqueInput
    create: XOR<ResenaCreateWithoutProductoInput, ResenaUncheckedCreateWithoutProductoInput>
  }

  export type ResenaCreateManyProductoInputEnvelope = {
    data: ResenaCreateManyProductoInput | ResenaCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type PedidoItemCreateWithoutProductoInput = {
    cantidad: number
    pedido: PedidoCreateNestedOneWithoutItemsInput
    producto_personalizado?: ProductoPersonalizableCreateNestedOneWithoutPedidoItemsInput
  }

  export type PedidoItemUncheckedCreateWithoutProductoInput = {
    pedido_id: number
    cantidad: number
    producto_personalizado_id?: number | null
  }

  export type PedidoItemCreateOrConnectWithoutProductoInput = {
    where: PedidoItemWhereUniqueInput
    create: XOR<PedidoItemCreateWithoutProductoInput, PedidoItemUncheckedCreateWithoutProductoInput>
  }

  export type PedidoItemCreateManyProductoInputEnvelope = {
    data: PedidoItemCreateManyProductoInput | PedidoItemCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type PromocionCreateWithoutProductoInput = {
    nombre: string
    tipo: $Enums.TipoPromocion
    valor: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    categoria?: CategoriaCreateNestedOneWithoutPromocionesInput
    historial?: HistorialPromocionAplicadaCreateNestedManyWithoutPromocionInput
  }

  export type PromocionUncheckedCreateWithoutProductoInput = {
    id?: number
    nombre: string
    tipo: $Enums.TipoPromocion
    referencia_id_categoria?: number | null
    valor: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    historial?: HistorialPromocionAplicadaUncheckedCreateNestedManyWithoutPromocionInput
  }

  export type PromocionCreateOrConnectWithoutProductoInput = {
    where: PromocionWhereUniqueInput
    create: XOR<PromocionCreateWithoutProductoInput, PromocionUncheckedCreateWithoutProductoInput>
  }

  export type PromocionCreateManyProductoInputEnvelope = {
    data: PromocionCreateManyProductoInput | PromocionCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type ProductoPersonalizableCreateWithoutProducto_baseInput = {
    nombre: string
    descripcion_general: string
    activo?: boolean
    categoria: CategoriaCreateNestedOneWithoutProductosPersonalizablesInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProducto_personalizadoInput
    variantes?: VarianteDetalleCreateNestedManyWithoutProductoPersonalizableInput
  }

  export type ProductoPersonalizableUncheckedCreateWithoutProducto_baseInput = {
    id?: number
    nombre: string
    descripcion_general: string
    id_categoria: number
    activo?: boolean
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProducto_personalizadoInput
    variantes?: VarianteDetalleUncheckedCreateNestedManyWithoutProductoPersonalizableInput
  }

  export type ProductoPersonalizableCreateOrConnectWithoutProducto_baseInput = {
    where: ProductoPersonalizableWhereUniqueInput
    create: XOR<ProductoPersonalizableCreateWithoutProducto_baseInput, ProductoPersonalizableUncheckedCreateWithoutProducto_baseInput>
  }

  export type ProductoPersonalizableCreateManyProducto_baseInputEnvelope = {
    data: ProductoPersonalizableCreateManyProducto_baseInput | ProductoPersonalizableCreateManyProducto_baseInput[]
    skipDuplicates?: boolean
  }

  export type CategoriaUpsertWithoutProductosInput = {
    update: XOR<CategoriaUpdateWithoutProductosInput, CategoriaUncheckedUpdateWithoutProductosInput>
    create: XOR<CategoriaCreateWithoutProductosInput, CategoriaUncheckedCreateWithoutProductosInput>
    where?: CategoriaWhereInput
  }

  export type CategoriaUpdateToOneWithWhereWithoutProductosInput = {
    where?: CategoriaWhereInput
    data: XOR<CategoriaUpdateWithoutProductosInput, CategoriaUncheckedUpdateWithoutProductosInput>
  }

  export type CategoriaUpdateWithoutProductosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    promociones?: PromocionUpdateManyWithoutCategoriaNestedInput
    productosPersonalizables?: ProductoPersonalizableUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    promociones?: PromocionUncheckedUpdateManyWithoutCategoriaNestedInput
    productosPersonalizables?: ProductoPersonalizableUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type ImagenProductoUpsertWithWhereUniqueWithoutProductoInput = {
    where: ImagenProductoWhereUniqueInput
    update: XOR<ImagenProductoUpdateWithoutProductoInput, ImagenProductoUncheckedUpdateWithoutProductoInput>
    create: XOR<ImagenProductoCreateWithoutProductoInput, ImagenProductoUncheckedCreateWithoutProductoInput>
  }

  export type ImagenProductoUpdateWithWhereUniqueWithoutProductoInput = {
    where: ImagenProductoWhereUniqueInput
    data: XOR<ImagenProductoUpdateWithoutProductoInput, ImagenProductoUncheckedUpdateWithoutProductoInput>
  }

  export type ImagenProductoUpdateManyWithWhereWithoutProductoInput = {
    where: ImagenProductoScalarWhereInput
    data: XOR<ImagenProductoUpdateManyMutationInput, ImagenProductoUncheckedUpdateManyWithoutProductoInput>
  }

  export type ImagenProductoScalarWhereInput = {
    AND?: ImagenProductoScalarWhereInput | ImagenProductoScalarWhereInput[]
    OR?: ImagenProductoScalarWhereInput[]
    NOT?: ImagenProductoScalarWhereInput | ImagenProductoScalarWhereInput[]
    id?: IntFilter<"ImagenProducto"> | number
    producto_id?: IntFilter<"ImagenProducto"> | number
    url?: StringFilter<"ImagenProducto"> | string
  }

  export type ProductoEtiquetaUpsertWithWhereUniqueWithoutProductoInput = {
    where: ProductoEtiquetaWhereUniqueInput
    update: XOR<ProductoEtiquetaUpdateWithoutProductoInput, ProductoEtiquetaUncheckedUpdateWithoutProductoInput>
    create: XOR<ProductoEtiquetaCreateWithoutProductoInput, ProductoEtiquetaUncheckedCreateWithoutProductoInput>
  }

  export type ProductoEtiquetaUpdateWithWhereUniqueWithoutProductoInput = {
    where: ProductoEtiquetaWhereUniqueInput
    data: XOR<ProductoEtiquetaUpdateWithoutProductoInput, ProductoEtiquetaUncheckedUpdateWithoutProductoInput>
  }

  export type ProductoEtiquetaUpdateManyWithWhereWithoutProductoInput = {
    where: ProductoEtiquetaScalarWhereInput
    data: XOR<ProductoEtiquetaUpdateManyMutationInput, ProductoEtiquetaUncheckedUpdateManyWithoutProductoInput>
  }

  export type ResenaUpsertWithWhereUniqueWithoutProductoInput = {
    where: ResenaWhereUniqueInput
    update: XOR<ResenaUpdateWithoutProductoInput, ResenaUncheckedUpdateWithoutProductoInput>
    create: XOR<ResenaCreateWithoutProductoInput, ResenaUncheckedCreateWithoutProductoInput>
  }

  export type ResenaUpdateWithWhereUniqueWithoutProductoInput = {
    where: ResenaWhereUniqueInput
    data: XOR<ResenaUpdateWithoutProductoInput, ResenaUncheckedUpdateWithoutProductoInput>
  }

  export type ResenaUpdateManyWithWhereWithoutProductoInput = {
    where: ResenaScalarWhereInput
    data: XOR<ResenaUpdateManyMutationInput, ResenaUncheckedUpdateManyWithoutProductoInput>
  }

  export type PedidoItemUpsertWithWhereUniqueWithoutProductoInput = {
    where: PedidoItemWhereUniqueInput
    update: XOR<PedidoItemUpdateWithoutProductoInput, PedidoItemUncheckedUpdateWithoutProductoInput>
    create: XOR<PedidoItemCreateWithoutProductoInput, PedidoItemUncheckedCreateWithoutProductoInput>
  }

  export type PedidoItemUpdateWithWhereUniqueWithoutProductoInput = {
    where: PedidoItemWhereUniqueInput
    data: XOR<PedidoItemUpdateWithoutProductoInput, PedidoItemUncheckedUpdateWithoutProductoInput>
  }

  export type PedidoItemUpdateManyWithWhereWithoutProductoInput = {
    where: PedidoItemScalarWhereInput
    data: XOR<PedidoItemUpdateManyMutationInput, PedidoItemUncheckedUpdateManyWithoutProductoInput>
  }

  export type PedidoItemScalarWhereInput = {
    AND?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
    OR?: PedidoItemScalarWhereInput[]
    NOT?: PedidoItemScalarWhereInput | PedidoItemScalarWhereInput[]
    pedido_id?: IntFilter<"PedidoItem"> | number
    producto_id?: IntFilter<"PedidoItem"> | number
    cantidad?: IntFilter<"PedidoItem"> | number
    producto_personalizado_id?: IntNullableFilter<"PedidoItem"> | number | null
  }

  export type PromocionUpsertWithWhereUniqueWithoutProductoInput = {
    where: PromocionWhereUniqueInput
    update: XOR<PromocionUpdateWithoutProductoInput, PromocionUncheckedUpdateWithoutProductoInput>
    create: XOR<PromocionCreateWithoutProductoInput, PromocionUncheckedCreateWithoutProductoInput>
  }

  export type PromocionUpdateWithWhereUniqueWithoutProductoInput = {
    where: PromocionWhereUniqueInput
    data: XOR<PromocionUpdateWithoutProductoInput, PromocionUncheckedUpdateWithoutProductoInput>
  }

  export type PromocionUpdateManyWithWhereWithoutProductoInput = {
    where: PromocionScalarWhereInput
    data: XOR<PromocionUpdateManyMutationInput, PromocionUncheckedUpdateManyWithoutProductoInput>
  }

  export type ProductoPersonalizableUpsertWithWhereUniqueWithoutProducto_baseInput = {
    where: ProductoPersonalizableWhereUniqueInput
    update: XOR<ProductoPersonalizableUpdateWithoutProducto_baseInput, ProductoPersonalizableUncheckedUpdateWithoutProducto_baseInput>
    create: XOR<ProductoPersonalizableCreateWithoutProducto_baseInput, ProductoPersonalizableUncheckedCreateWithoutProducto_baseInput>
  }

  export type ProductoPersonalizableUpdateWithWhereUniqueWithoutProducto_baseInput = {
    where: ProductoPersonalizableWhereUniqueInput
    data: XOR<ProductoPersonalizableUpdateWithoutProducto_baseInput, ProductoPersonalizableUncheckedUpdateWithoutProducto_baseInput>
  }

  export type ProductoPersonalizableUpdateManyWithWhereWithoutProducto_baseInput = {
    where: ProductoPersonalizableScalarWhereInput
    data: XOR<ProductoPersonalizableUpdateManyMutationInput, ProductoPersonalizableUncheckedUpdateManyWithoutProducto_baseInput>
  }

  export type ProductoCreateWithoutImagenesInput = {
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    promedio_valoracion?: number
    activo?: boolean
    categoria: CategoriaCreateNestedOneWithoutProductosInput
    etiquetas?: ProductoEtiquetaCreateNestedManyWithoutProductoInput
    resenas?: ResenaCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    promociones?: PromocionCreateNestedManyWithoutProductoInput
    productosPersonalizables?: ProductoPersonalizableCreateNestedManyWithoutProducto_baseInput
  }

  export type ProductoUncheckedCreateWithoutImagenesInput = {
    id?: number
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    categoria_id: number
    promedio_valoracion?: number
    activo?: boolean
    etiquetas?: ProductoEtiquetaUncheckedCreateNestedManyWithoutProductoInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutProductoInput
    productosPersonalizables?: ProductoPersonalizableUncheckedCreateNestedManyWithoutProducto_baseInput
  }

  export type ProductoCreateOrConnectWithoutImagenesInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutImagenesInput, ProductoUncheckedCreateWithoutImagenesInput>
  }

  export type ProductoUpsertWithoutImagenesInput = {
    update: XOR<ProductoUpdateWithoutImagenesInput, ProductoUncheckedUpdateWithoutImagenesInput>
    create: XOR<ProductoCreateWithoutImagenesInput, ProductoUncheckedCreateWithoutImagenesInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutImagenesInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutImagenesInput, ProductoUncheckedUpdateWithoutImagenesInput>
  }

  export type ProductoUpdateWithoutImagenesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductosNestedInput
    etiquetas?: ProductoEtiquetaUpdateManyWithoutProductoNestedInput
    resenas?: ResenaUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    promociones?: PromocionUpdateManyWithoutProductoNestedInput
    productosPersonalizables?: ProductoPersonalizableUpdateManyWithoutProducto_baseNestedInput
  }

  export type ProductoUncheckedUpdateWithoutImagenesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    etiquetas?: ProductoEtiquetaUncheckedUpdateManyWithoutProductoNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutProductoNestedInput
    productosPersonalizables?: ProductoPersonalizableUncheckedUpdateManyWithoutProducto_baseNestedInput
  }

  export type ProductoCreateWithoutEtiquetasInput = {
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    promedio_valoracion?: number
    activo?: boolean
    categoria: CategoriaCreateNestedOneWithoutProductosInput
    imagenes?: ImagenProductoCreateNestedManyWithoutProductoInput
    resenas?: ResenaCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    promociones?: PromocionCreateNestedManyWithoutProductoInput
    productosPersonalizables?: ProductoPersonalizableCreateNestedManyWithoutProducto_baseInput
  }

  export type ProductoUncheckedCreateWithoutEtiquetasInput = {
    id?: number
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    categoria_id: number
    promedio_valoracion?: number
    activo?: boolean
    imagenes?: ImagenProductoUncheckedCreateNestedManyWithoutProductoInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutProductoInput
    productosPersonalizables?: ProductoPersonalizableUncheckedCreateNestedManyWithoutProducto_baseInput
  }

  export type ProductoCreateOrConnectWithoutEtiquetasInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutEtiquetasInput, ProductoUncheckedCreateWithoutEtiquetasInput>
  }

  export type EtiquetaCreateWithoutProductosInput = {
    nombre: string
  }

  export type EtiquetaUncheckedCreateWithoutProductosInput = {
    id?: number
    nombre: string
  }

  export type EtiquetaCreateOrConnectWithoutProductosInput = {
    where: EtiquetaWhereUniqueInput
    create: XOR<EtiquetaCreateWithoutProductosInput, EtiquetaUncheckedCreateWithoutProductosInput>
  }

  export type ProductoUpsertWithoutEtiquetasInput = {
    update: XOR<ProductoUpdateWithoutEtiquetasInput, ProductoUncheckedUpdateWithoutEtiquetasInput>
    create: XOR<ProductoCreateWithoutEtiquetasInput, ProductoUncheckedCreateWithoutEtiquetasInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutEtiquetasInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutEtiquetasInput, ProductoUncheckedUpdateWithoutEtiquetasInput>
  }

  export type ProductoUpdateWithoutEtiquetasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductosNestedInput
    imagenes?: ImagenProductoUpdateManyWithoutProductoNestedInput
    resenas?: ResenaUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    promociones?: PromocionUpdateManyWithoutProductoNestedInput
    productosPersonalizables?: ProductoPersonalizableUpdateManyWithoutProducto_baseNestedInput
  }

  export type ProductoUncheckedUpdateWithoutEtiquetasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    imagenes?: ImagenProductoUncheckedUpdateManyWithoutProductoNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutProductoNestedInput
    productosPersonalizables?: ProductoPersonalizableUncheckedUpdateManyWithoutProducto_baseNestedInput
  }

  export type EtiquetaUpsertWithoutProductosInput = {
    update: XOR<EtiquetaUpdateWithoutProductosInput, EtiquetaUncheckedUpdateWithoutProductosInput>
    create: XOR<EtiquetaCreateWithoutProductosInput, EtiquetaUncheckedCreateWithoutProductosInput>
    where?: EtiquetaWhereInput
  }

  export type EtiquetaUpdateToOneWithWhereWithoutProductosInput = {
    where?: EtiquetaWhereInput
    data: XOR<EtiquetaUpdateWithoutProductosInput, EtiquetaUncheckedUpdateWithoutProductosInput>
  }

  export type EtiquetaUpdateWithoutProductosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type EtiquetaUncheckedUpdateWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioCreateWithoutResenasInput = {
    nombre_usuario: string
    correo: string
    contraseña: string
    rol: $Enums.Rol
    ultimo_inicio_sesion?: Date | string | null
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    transiciones_estado?: TransicionEstadoPedidoCreateNestedManyWithoutAdminInput
    reportes_resena?: ReporteResenaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutResenasInput = {
    id?: number
    nombre_usuario: string
    correo: string
    contraseña: string
    rol: $Enums.Rol
    ultimo_inicio_sesion?: Date | string | null
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    transiciones_estado?: TransicionEstadoPedidoUncheckedCreateNestedManyWithoutAdminInput
    reportes_resena?: ReporteResenaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutResenasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutResenasInput, UsuarioUncheckedCreateWithoutResenasInput>
  }

  export type ProductoCreateWithoutResenasInput = {
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    promedio_valoracion?: number
    activo?: boolean
    categoria: CategoriaCreateNestedOneWithoutProductosInput
    imagenes?: ImagenProductoCreateNestedManyWithoutProductoInput
    etiquetas?: ProductoEtiquetaCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    promociones?: PromocionCreateNestedManyWithoutProductoInput
    productosPersonalizables?: ProductoPersonalizableCreateNestedManyWithoutProducto_baseInput
  }

  export type ProductoUncheckedCreateWithoutResenasInput = {
    id?: number
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    categoria_id: number
    promedio_valoracion?: number
    activo?: boolean
    imagenes?: ImagenProductoUncheckedCreateNestedManyWithoutProductoInput
    etiquetas?: ProductoEtiquetaUncheckedCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutProductoInput
    productosPersonalizables?: ProductoPersonalizableUncheckedCreateNestedManyWithoutProducto_baseInput
  }

  export type ProductoCreateOrConnectWithoutResenasInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutResenasInput, ProductoUncheckedCreateWithoutResenasInput>
  }

  export type ReporteResenaCreateWithoutResenaInput = {
    comentario: string
    usuario: UsuarioCreateNestedOneWithoutReportes_resenaInput
  }

  export type ReporteResenaUncheckedCreateWithoutResenaInput = {
    id?: number
    usuario_id: number
    comentario: string
  }

  export type ReporteResenaCreateOrConnectWithoutResenaInput = {
    where: ReporteResenaWhereUniqueInput
    create: XOR<ReporteResenaCreateWithoutResenaInput, ReporteResenaUncheckedCreateWithoutResenaInput>
  }

  export type ReporteResenaCreateManyResenaInputEnvelope = {
    data: ReporteResenaCreateManyResenaInput | ReporteResenaCreateManyResenaInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutResenasInput = {
    update: XOR<UsuarioUpdateWithoutResenasInput, UsuarioUncheckedUpdateWithoutResenasInput>
    create: XOR<UsuarioCreateWithoutResenasInput, UsuarioUncheckedCreateWithoutResenasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutResenasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutResenasInput, UsuarioUncheckedUpdateWithoutResenasInput>
  }

  export type UsuarioUpdateWithoutResenasInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contraseña?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ultimo_inicio_sesion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    transiciones_estado?: TransicionEstadoPedidoUpdateManyWithoutAdminNestedInput
    reportes_resena?: ReporteResenaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutResenasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contraseña?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ultimo_inicio_sesion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    transiciones_estado?: TransicionEstadoPedidoUncheckedUpdateManyWithoutAdminNestedInput
    reportes_resena?: ReporteResenaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type ProductoUpsertWithoutResenasInput = {
    update: XOR<ProductoUpdateWithoutResenasInput, ProductoUncheckedUpdateWithoutResenasInput>
    create: XOR<ProductoCreateWithoutResenasInput, ProductoUncheckedCreateWithoutResenasInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutResenasInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutResenasInput, ProductoUncheckedUpdateWithoutResenasInput>
  }

  export type ProductoUpdateWithoutResenasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductosNestedInput
    imagenes?: ImagenProductoUpdateManyWithoutProductoNestedInput
    etiquetas?: ProductoEtiquetaUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    promociones?: PromocionUpdateManyWithoutProductoNestedInput
    productosPersonalizables?: ProductoPersonalizableUpdateManyWithoutProducto_baseNestedInput
  }

  export type ProductoUncheckedUpdateWithoutResenasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    imagenes?: ImagenProductoUncheckedUpdateManyWithoutProductoNestedInput
    etiquetas?: ProductoEtiquetaUncheckedUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutProductoNestedInput
    productosPersonalizables?: ProductoPersonalizableUncheckedUpdateManyWithoutProducto_baseNestedInput
  }

  export type ReporteResenaUpsertWithWhereUniqueWithoutResenaInput = {
    where: ReporteResenaWhereUniqueInput
    update: XOR<ReporteResenaUpdateWithoutResenaInput, ReporteResenaUncheckedUpdateWithoutResenaInput>
    create: XOR<ReporteResenaCreateWithoutResenaInput, ReporteResenaUncheckedCreateWithoutResenaInput>
  }

  export type ReporteResenaUpdateWithWhereUniqueWithoutResenaInput = {
    where: ReporteResenaWhereUniqueInput
    data: XOR<ReporteResenaUpdateWithoutResenaInput, ReporteResenaUncheckedUpdateWithoutResenaInput>
  }

  export type ReporteResenaUpdateManyWithWhereWithoutResenaInput = {
    where: ReporteResenaScalarWhereInput
    data: XOR<ReporteResenaUpdateManyMutationInput, ReporteResenaUncheckedUpdateManyWithoutResenaInput>
  }

  export type CategoriaCreateWithoutProductosPersonalizablesInput = {
    nombre: string
    descripcion: string
    productos?: ProductoCreateNestedManyWithoutCategoriaInput
    promociones?: PromocionCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateWithoutProductosPersonalizablesInput = {
    id?: number
    nombre: string
    descripcion: string
    productos?: ProductoUncheckedCreateNestedManyWithoutCategoriaInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaCreateOrConnectWithoutProductosPersonalizablesInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutProductosPersonalizablesInput, CategoriaUncheckedCreateWithoutProductosPersonalizablesInput>
  }

  export type ProductoCreateWithoutProductosPersonalizablesInput = {
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    promedio_valoracion?: number
    activo?: boolean
    categoria: CategoriaCreateNestedOneWithoutProductosInput
    imagenes?: ImagenProductoCreateNestedManyWithoutProductoInput
    etiquetas?: ProductoEtiquetaCreateNestedManyWithoutProductoInput
    resenas?: ResenaCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    promociones?: PromocionCreateNestedManyWithoutProductoInput
  }

  export type ProductoUncheckedCreateWithoutProductosPersonalizablesInput = {
    id?: number
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    categoria_id: number
    promedio_valoracion?: number
    activo?: boolean
    imagenes?: ImagenProductoUncheckedCreateNestedManyWithoutProductoInput
    etiquetas?: ProductoEtiquetaUncheckedCreateNestedManyWithoutProductoInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoCreateOrConnectWithoutProductosPersonalizablesInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutProductosPersonalizablesInput, ProductoUncheckedCreateWithoutProductosPersonalizablesInput>
  }

  export type PedidoItemCreateWithoutProducto_personalizadoInput = {
    cantidad: number
    pedido: PedidoCreateNestedOneWithoutItemsInput
    producto: ProductoCreateNestedOneWithoutPedidoItemsInput
  }

  export type PedidoItemUncheckedCreateWithoutProducto_personalizadoInput = {
    pedido_id: number
    producto_id: number
    cantidad: number
  }

  export type PedidoItemCreateOrConnectWithoutProducto_personalizadoInput = {
    where: PedidoItemWhereUniqueInput
    create: XOR<PedidoItemCreateWithoutProducto_personalizadoInput, PedidoItemUncheckedCreateWithoutProducto_personalizadoInput>
  }

  export type PedidoItemCreateManyProducto_personalizadoInputEnvelope = {
    data: PedidoItemCreateManyProducto_personalizadoInput | PedidoItemCreateManyProducto_personalizadoInput[]
    skipDuplicates?: boolean
  }

  export type VarianteDetalleCreateWithoutProductoPersonalizableInput = {
    valor: ValorAtributoCreateNestedOneWithoutVarianteDetallesInput
  }

  export type VarianteDetalleUncheckedCreateWithoutProductoPersonalizableInput = {
    id_valor: number
  }

  export type VarianteDetalleCreateOrConnectWithoutProductoPersonalizableInput = {
    where: VarianteDetalleWhereUniqueInput
    create: XOR<VarianteDetalleCreateWithoutProductoPersonalizableInput, VarianteDetalleUncheckedCreateWithoutProductoPersonalizableInput>
  }

  export type VarianteDetalleCreateManyProductoPersonalizableInputEnvelope = {
    data: VarianteDetalleCreateManyProductoPersonalizableInput | VarianteDetalleCreateManyProductoPersonalizableInput[]
    skipDuplicates?: boolean
  }

  export type CategoriaUpsertWithoutProductosPersonalizablesInput = {
    update: XOR<CategoriaUpdateWithoutProductosPersonalizablesInput, CategoriaUncheckedUpdateWithoutProductosPersonalizablesInput>
    create: XOR<CategoriaCreateWithoutProductosPersonalizablesInput, CategoriaUncheckedCreateWithoutProductosPersonalizablesInput>
    where?: CategoriaWhereInput
  }

  export type CategoriaUpdateToOneWithWhereWithoutProductosPersonalizablesInput = {
    where?: CategoriaWhereInput
    data: XOR<CategoriaUpdateWithoutProductosPersonalizablesInput, CategoriaUncheckedUpdateWithoutProductosPersonalizablesInput>
  }

  export type CategoriaUpdateWithoutProductosPersonalizablesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    productos?: ProductoUpdateManyWithoutCategoriaNestedInput
    promociones?: PromocionUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateWithoutProductosPersonalizablesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    productos?: ProductoUncheckedUpdateManyWithoutCategoriaNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type ProductoUpsertWithoutProductosPersonalizablesInput = {
    update: XOR<ProductoUpdateWithoutProductosPersonalizablesInput, ProductoUncheckedUpdateWithoutProductosPersonalizablesInput>
    create: XOR<ProductoCreateWithoutProductosPersonalizablesInput, ProductoUncheckedCreateWithoutProductosPersonalizablesInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutProductosPersonalizablesInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutProductosPersonalizablesInput, ProductoUncheckedUpdateWithoutProductosPersonalizablesInput>
  }

  export type ProductoUpdateWithoutProductosPersonalizablesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductosNestedInput
    imagenes?: ImagenProductoUpdateManyWithoutProductoNestedInput
    etiquetas?: ProductoEtiquetaUpdateManyWithoutProductoNestedInput
    resenas?: ResenaUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    promociones?: PromocionUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateWithoutProductosPersonalizablesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    imagenes?: ImagenProductoUncheckedUpdateManyWithoutProductoNestedInput
    etiquetas?: ProductoEtiquetaUncheckedUpdateManyWithoutProductoNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type PedidoItemUpsertWithWhereUniqueWithoutProducto_personalizadoInput = {
    where: PedidoItemWhereUniqueInput
    update: XOR<PedidoItemUpdateWithoutProducto_personalizadoInput, PedidoItemUncheckedUpdateWithoutProducto_personalizadoInput>
    create: XOR<PedidoItemCreateWithoutProducto_personalizadoInput, PedidoItemUncheckedCreateWithoutProducto_personalizadoInput>
  }

  export type PedidoItemUpdateWithWhereUniqueWithoutProducto_personalizadoInput = {
    where: PedidoItemWhereUniqueInput
    data: XOR<PedidoItemUpdateWithoutProducto_personalizadoInput, PedidoItemUncheckedUpdateWithoutProducto_personalizadoInput>
  }

  export type PedidoItemUpdateManyWithWhereWithoutProducto_personalizadoInput = {
    where: PedidoItemScalarWhereInput
    data: XOR<PedidoItemUpdateManyMutationInput, PedidoItemUncheckedUpdateManyWithoutProducto_personalizadoInput>
  }

  export type VarianteDetalleUpsertWithWhereUniqueWithoutProductoPersonalizableInput = {
    where: VarianteDetalleWhereUniqueInput
    update: XOR<VarianteDetalleUpdateWithoutProductoPersonalizableInput, VarianteDetalleUncheckedUpdateWithoutProductoPersonalizableInput>
    create: XOR<VarianteDetalleCreateWithoutProductoPersonalizableInput, VarianteDetalleUncheckedCreateWithoutProductoPersonalizableInput>
  }

  export type VarianteDetalleUpdateWithWhereUniqueWithoutProductoPersonalizableInput = {
    where: VarianteDetalleWhereUniqueInput
    data: XOR<VarianteDetalleUpdateWithoutProductoPersonalizableInput, VarianteDetalleUncheckedUpdateWithoutProductoPersonalizableInput>
  }

  export type VarianteDetalleUpdateManyWithWhereWithoutProductoPersonalizableInput = {
    where: VarianteDetalleScalarWhereInput
    data: XOR<VarianteDetalleUpdateManyMutationInput, VarianteDetalleUncheckedUpdateManyWithoutProductoPersonalizableInput>
  }

  export type VarianteDetalleScalarWhereInput = {
    AND?: VarianteDetalleScalarWhereInput | VarianteDetalleScalarWhereInput[]
    OR?: VarianteDetalleScalarWhereInput[]
    NOT?: VarianteDetalleScalarWhereInput | VarianteDetalleScalarWhereInput[]
    id_productoPersonalizable?: IntFilter<"VarianteDetalle"> | number
    id_valor?: IntFilter<"VarianteDetalle"> | number
  }

  export type ValorAtributoCreateWithoutAtributoInput = {
    valor: string
    precio_extra?: number
    varianteDetalles?: VarianteDetalleCreateNestedManyWithoutValorInput
  }

  export type ValorAtributoUncheckedCreateWithoutAtributoInput = {
    id_valor?: number
    valor: string
    precio_extra?: number
    varianteDetalles?: VarianteDetalleUncheckedCreateNestedManyWithoutValorInput
  }

  export type ValorAtributoCreateOrConnectWithoutAtributoInput = {
    where: ValorAtributoWhereUniqueInput
    create: XOR<ValorAtributoCreateWithoutAtributoInput, ValorAtributoUncheckedCreateWithoutAtributoInput>
  }

  export type ValorAtributoCreateManyAtributoInputEnvelope = {
    data: ValorAtributoCreateManyAtributoInput | ValorAtributoCreateManyAtributoInput[]
    skipDuplicates?: boolean
  }

  export type ValorAtributoUpsertWithWhereUniqueWithoutAtributoInput = {
    where: ValorAtributoWhereUniqueInput
    update: XOR<ValorAtributoUpdateWithoutAtributoInput, ValorAtributoUncheckedUpdateWithoutAtributoInput>
    create: XOR<ValorAtributoCreateWithoutAtributoInput, ValorAtributoUncheckedCreateWithoutAtributoInput>
  }

  export type ValorAtributoUpdateWithWhereUniqueWithoutAtributoInput = {
    where: ValorAtributoWhereUniqueInput
    data: XOR<ValorAtributoUpdateWithoutAtributoInput, ValorAtributoUncheckedUpdateWithoutAtributoInput>
  }

  export type ValorAtributoUpdateManyWithWhereWithoutAtributoInput = {
    where: ValorAtributoScalarWhereInput
    data: XOR<ValorAtributoUpdateManyMutationInput, ValorAtributoUncheckedUpdateManyWithoutAtributoInput>
  }

  export type ValorAtributoScalarWhereInput = {
    AND?: ValorAtributoScalarWhereInput | ValorAtributoScalarWhereInput[]
    OR?: ValorAtributoScalarWhereInput[]
    NOT?: ValorAtributoScalarWhereInput | ValorAtributoScalarWhereInput[]
    id_valor?: IntFilter<"ValorAtributo"> | number
    id_atributo?: IntFilter<"ValorAtributo"> | number
    valor?: StringFilter<"ValorAtributo"> | string
    precio_extra?: FloatFilter<"ValorAtributo"> | number
  }

  export type AtributoCreateWithoutValoresInput = {
    nombre: string
    tipo: string
  }

  export type AtributoUncheckedCreateWithoutValoresInput = {
    id_atributo?: number
    nombre: string
    tipo: string
  }

  export type AtributoCreateOrConnectWithoutValoresInput = {
    where: AtributoWhereUniqueInput
    create: XOR<AtributoCreateWithoutValoresInput, AtributoUncheckedCreateWithoutValoresInput>
  }

  export type VarianteDetalleCreateWithoutValorInput = {
    productoPersonalizable: ProductoPersonalizableCreateNestedOneWithoutVariantesInput
  }

  export type VarianteDetalleUncheckedCreateWithoutValorInput = {
    id_productoPersonalizable: number
  }

  export type VarianteDetalleCreateOrConnectWithoutValorInput = {
    where: VarianteDetalleWhereUniqueInput
    create: XOR<VarianteDetalleCreateWithoutValorInput, VarianteDetalleUncheckedCreateWithoutValorInput>
  }

  export type VarianteDetalleCreateManyValorInputEnvelope = {
    data: VarianteDetalleCreateManyValorInput | VarianteDetalleCreateManyValorInput[]
    skipDuplicates?: boolean
  }

  export type AtributoUpsertWithoutValoresInput = {
    update: XOR<AtributoUpdateWithoutValoresInput, AtributoUncheckedUpdateWithoutValoresInput>
    create: XOR<AtributoCreateWithoutValoresInput, AtributoUncheckedCreateWithoutValoresInput>
    where?: AtributoWhereInput
  }

  export type AtributoUpdateToOneWithWhereWithoutValoresInput = {
    where?: AtributoWhereInput
    data: XOR<AtributoUpdateWithoutValoresInput, AtributoUncheckedUpdateWithoutValoresInput>
  }

  export type AtributoUpdateWithoutValoresInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type AtributoUncheckedUpdateWithoutValoresInput = {
    id_atributo?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type VarianteDetalleUpsertWithWhereUniqueWithoutValorInput = {
    where: VarianteDetalleWhereUniqueInput
    update: XOR<VarianteDetalleUpdateWithoutValorInput, VarianteDetalleUncheckedUpdateWithoutValorInput>
    create: XOR<VarianteDetalleCreateWithoutValorInput, VarianteDetalleUncheckedCreateWithoutValorInput>
  }

  export type VarianteDetalleUpdateWithWhereUniqueWithoutValorInput = {
    where: VarianteDetalleWhereUniqueInput
    data: XOR<VarianteDetalleUpdateWithoutValorInput, VarianteDetalleUncheckedUpdateWithoutValorInput>
  }

  export type VarianteDetalleUpdateManyWithWhereWithoutValorInput = {
    where: VarianteDetalleScalarWhereInput
    data: XOR<VarianteDetalleUpdateManyMutationInput, VarianteDetalleUncheckedUpdateManyWithoutValorInput>
  }

  export type ValorAtributoCreateWithoutVarianteDetallesInput = {
    valor: string
    precio_extra?: number
    atributo: AtributoCreateNestedOneWithoutValoresInput
  }

  export type ValorAtributoUncheckedCreateWithoutVarianteDetallesInput = {
    id_valor?: number
    id_atributo: number
    valor: string
    precio_extra?: number
  }

  export type ValorAtributoCreateOrConnectWithoutVarianteDetallesInput = {
    where: ValorAtributoWhereUniqueInput
    create: XOR<ValorAtributoCreateWithoutVarianteDetallesInput, ValorAtributoUncheckedCreateWithoutVarianteDetallesInput>
  }

  export type ProductoPersonalizableCreateWithoutVariantesInput = {
    nombre: string
    descripcion_general: string
    activo?: boolean
    categoria: CategoriaCreateNestedOneWithoutProductosPersonalizablesInput
    producto_base: ProductoCreateNestedOneWithoutProductosPersonalizablesInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProducto_personalizadoInput
  }

  export type ProductoPersonalizableUncheckedCreateWithoutVariantesInput = {
    id?: number
    nombre: string
    descripcion_general: string
    id_categoria: number
    id_producto_base: number
    activo?: boolean
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProducto_personalizadoInput
  }

  export type ProductoPersonalizableCreateOrConnectWithoutVariantesInput = {
    where: ProductoPersonalizableWhereUniqueInput
    create: XOR<ProductoPersonalizableCreateWithoutVariantesInput, ProductoPersonalizableUncheckedCreateWithoutVariantesInput>
  }

  export type ValorAtributoUpsertWithoutVarianteDetallesInput = {
    update: XOR<ValorAtributoUpdateWithoutVarianteDetallesInput, ValorAtributoUncheckedUpdateWithoutVarianteDetallesInput>
    create: XOR<ValorAtributoCreateWithoutVarianteDetallesInput, ValorAtributoUncheckedCreateWithoutVarianteDetallesInput>
    where?: ValorAtributoWhereInput
  }

  export type ValorAtributoUpdateToOneWithWhereWithoutVarianteDetallesInput = {
    where?: ValorAtributoWhereInput
    data: XOR<ValorAtributoUpdateWithoutVarianteDetallesInput, ValorAtributoUncheckedUpdateWithoutVarianteDetallesInput>
  }

  export type ValorAtributoUpdateWithoutVarianteDetallesInput = {
    valor?: StringFieldUpdateOperationsInput | string
    precio_extra?: FloatFieldUpdateOperationsInput | number
    atributo?: AtributoUpdateOneRequiredWithoutValoresNestedInput
  }

  export type ValorAtributoUncheckedUpdateWithoutVarianteDetallesInput = {
    id_valor?: IntFieldUpdateOperationsInput | number
    id_atributo?: IntFieldUpdateOperationsInput | number
    valor?: StringFieldUpdateOperationsInput | string
    precio_extra?: FloatFieldUpdateOperationsInput | number
  }

  export type ProductoPersonalizableUpsertWithoutVariantesInput = {
    update: XOR<ProductoPersonalizableUpdateWithoutVariantesInput, ProductoPersonalizableUncheckedUpdateWithoutVariantesInput>
    create: XOR<ProductoPersonalizableCreateWithoutVariantesInput, ProductoPersonalizableUncheckedCreateWithoutVariantesInput>
    where?: ProductoPersonalizableWhereInput
  }

  export type ProductoPersonalizableUpdateToOneWithWhereWithoutVariantesInput = {
    where?: ProductoPersonalizableWhereInput
    data: XOR<ProductoPersonalizableUpdateWithoutVariantesInput, ProductoPersonalizableUncheckedUpdateWithoutVariantesInput>
  }

  export type ProductoPersonalizableUpdateWithoutVariantesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion_general?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductosPersonalizablesNestedInput
    producto_base?: ProductoUpdateOneRequiredWithoutProductosPersonalizablesNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProducto_personalizadoNestedInput
  }

  export type ProductoPersonalizableUncheckedUpdateWithoutVariantesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion_general?: StringFieldUpdateOperationsInput | string
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_producto_base?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProducto_personalizadoNestedInput
  }

  export type ProductoCreateWithoutPromocionesInput = {
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    promedio_valoracion?: number
    activo?: boolean
    categoria: CategoriaCreateNestedOneWithoutProductosInput
    imagenes?: ImagenProductoCreateNestedManyWithoutProductoInput
    etiquetas?: ProductoEtiquetaCreateNestedManyWithoutProductoInput
    resenas?: ResenaCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemCreateNestedManyWithoutProductoInput
    productosPersonalizables?: ProductoPersonalizableCreateNestedManyWithoutProducto_baseInput
  }

  export type ProductoUncheckedCreateWithoutPromocionesInput = {
    id?: number
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    categoria_id: number
    promedio_valoracion?: number
    activo?: boolean
    imagenes?: ImagenProductoUncheckedCreateNestedManyWithoutProductoInput
    etiquetas?: ProductoEtiquetaUncheckedCreateNestedManyWithoutProductoInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutProductoInput
    pedidoItems?: PedidoItemUncheckedCreateNestedManyWithoutProductoInput
    productosPersonalizables?: ProductoPersonalizableUncheckedCreateNestedManyWithoutProducto_baseInput
  }

  export type ProductoCreateOrConnectWithoutPromocionesInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutPromocionesInput, ProductoUncheckedCreateWithoutPromocionesInput>
  }

  export type CategoriaCreateWithoutPromocionesInput = {
    nombre: string
    descripcion: string
    productos?: ProductoCreateNestedManyWithoutCategoriaInput
    productosPersonalizables?: ProductoPersonalizableCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateWithoutPromocionesInput = {
    id?: number
    nombre: string
    descripcion: string
    productos?: ProductoUncheckedCreateNestedManyWithoutCategoriaInput
    productosPersonalizables?: ProductoPersonalizableUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaCreateOrConnectWithoutPromocionesInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutPromocionesInput, CategoriaUncheckedCreateWithoutPromocionesInput>
  }

  export type HistorialPromocionAplicadaCreateWithoutPromocionInput = {
    fecha: Date | string
    pedido: PedidoCreateNestedOneWithoutPromociones_aplicadasInput
  }

  export type HistorialPromocionAplicadaUncheckedCreateWithoutPromocionInput = {
    id?: number
    pedido_id: number
    fecha: Date | string
  }

  export type HistorialPromocionAplicadaCreateOrConnectWithoutPromocionInput = {
    where: HistorialPromocionAplicadaWhereUniqueInput
    create: XOR<HistorialPromocionAplicadaCreateWithoutPromocionInput, HistorialPromocionAplicadaUncheckedCreateWithoutPromocionInput>
  }

  export type HistorialPromocionAplicadaCreateManyPromocionInputEnvelope = {
    data: HistorialPromocionAplicadaCreateManyPromocionInput | HistorialPromocionAplicadaCreateManyPromocionInput[]
    skipDuplicates?: boolean
  }

  export type ProductoUpsertWithoutPromocionesInput = {
    update: XOR<ProductoUpdateWithoutPromocionesInput, ProductoUncheckedUpdateWithoutPromocionesInput>
    create: XOR<ProductoCreateWithoutPromocionesInput, ProductoUncheckedCreateWithoutPromocionesInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutPromocionesInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutPromocionesInput, ProductoUncheckedUpdateWithoutPromocionesInput>
  }

  export type ProductoUpdateWithoutPromocionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductosNestedInput
    imagenes?: ImagenProductoUpdateManyWithoutProductoNestedInput
    etiquetas?: ProductoEtiquetaUpdateManyWithoutProductoNestedInput
    resenas?: ResenaUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    productosPersonalizables?: ProductoPersonalizableUpdateManyWithoutProducto_baseNestedInput
  }

  export type ProductoUncheckedUpdateWithoutPromocionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    imagenes?: ImagenProductoUncheckedUpdateManyWithoutProductoNestedInput
    etiquetas?: ProductoEtiquetaUncheckedUpdateManyWithoutProductoNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
    productosPersonalizables?: ProductoPersonalizableUncheckedUpdateManyWithoutProducto_baseNestedInput
  }

  export type CategoriaUpsertWithoutPromocionesInput = {
    update: XOR<CategoriaUpdateWithoutPromocionesInput, CategoriaUncheckedUpdateWithoutPromocionesInput>
    create: XOR<CategoriaCreateWithoutPromocionesInput, CategoriaUncheckedCreateWithoutPromocionesInput>
    where?: CategoriaWhereInput
  }

  export type CategoriaUpdateToOneWithWhereWithoutPromocionesInput = {
    where?: CategoriaWhereInput
    data: XOR<CategoriaUpdateWithoutPromocionesInput, CategoriaUncheckedUpdateWithoutPromocionesInput>
  }

  export type CategoriaUpdateWithoutPromocionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    productos?: ProductoUpdateManyWithoutCategoriaNestedInput
    productosPersonalizables?: ProductoPersonalizableUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateWithoutPromocionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    productos?: ProductoUncheckedUpdateManyWithoutCategoriaNestedInput
    productosPersonalizables?: ProductoPersonalizableUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type HistorialPromocionAplicadaUpsertWithWhereUniqueWithoutPromocionInput = {
    where: HistorialPromocionAplicadaWhereUniqueInput
    update: XOR<HistorialPromocionAplicadaUpdateWithoutPromocionInput, HistorialPromocionAplicadaUncheckedUpdateWithoutPromocionInput>
    create: XOR<HistorialPromocionAplicadaCreateWithoutPromocionInput, HistorialPromocionAplicadaUncheckedCreateWithoutPromocionInput>
  }

  export type HistorialPromocionAplicadaUpdateWithWhereUniqueWithoutPromocionInput = {
    where: HistorialPromocionAplicadaWhereUniqueInput
    data: XOR<HistorialPromocionAplicadaUpdateWithoutPromocionInput, HistorialPromocionAplicadaUncheckedUpdateWithoutPromocionInput>
  }

  export type HistorialPromocionAplicadaUpdateManyWithWhereWithoutPromocionInput = {
    where: HistorialPromocionAplicadaScalarWhereInput
    data: XOR<HistorialPromocionAplicadaUpdateManyMutationInput, HistorialPromocionAplicadaUncheckedUpdateManyWithoutPromocionInput>
  }

  export type HistorialPromocionAplicadaScalarWhereInput = {
    AND?: HistorialPromocionAplicadaScalarWhereInput | HistorialPromocionAplicadaScalarWhereInput[]
    OR?: HistorialPromocionAplicadaScalarWhereInput[]
    NOT?: HistorialPromocionAplicadaScalarWhereInput | HistorialPromocionAplicadaScalarWhereInput[]
    id?: IntFilter<"HistorialPromocionAplicada"> | number
    promocion_id?: IntFilter<"HistorialPromocionAplicada"> | number
    pedido_id?: IntFilter<"HistorialPromocionAplicada"> | number
    fecha?: DateTimeFilter<"HistorialPromocionAplicada"> | Date | string
  }

  export type PromocionCreateWithoutHistorialInput = {
    nombre: string
    tipo: $Enums.TipoPromocion
    valor: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
    producto?: ProductoCreateNestedOneWithoutPromocionesInput
    categoria?: CategoriaCreateNestedOneWithoutPromocionesInput
  }

  export type PromocionUncheckedCreateWithoutHistorialInput = {
    id?: number
    nombre: string
    tipo: $Enums.TipoPromocion
    referencia_id_producto?: number | null
    referencia_id_categoria?: number | null
    valor: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
  }

  export type PromocionCreateOrConnectWithoutHistorialInput = {
    where: PromocionWhereUniqueInput
    create: XOR<PromocionCreateWithoutHistorialInput, PromocionUncheckedCreateWithoutHistorialInput>
  }

  export type PedidoCreateWithoutPromociones_aplicadasInput = {
    fecha_pedido: Date | string
    direccion_envio: string
    metodo_pago: $Enums.MetodoPago
    subtotal: number
    total: number
    impuestos: number
    estado_carrito?: boolean
    usuario: UsuarioCreateNestedOneWithoutPedidosInput
    items?: PedidoItemCreateNestedManyWithoutPedidoInput
    transiciones?: TransicionEstadoPedidoCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutPromociones_aplicadasInput = {
    id?: number
    usuario_id: number
    fecha_pedido: Date | string
    direccion_envio: string
    metodo_pago: $Enums.MetodoPago
    subtotal: number
    total: number
    impuestos: number
    estado_carrito?: boolean
    items?: PedidoItemUncheckedCreateNestedManyWithoutPedidoInput
    transiciones?: TransicionEstadoPedidoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutPromociones_aplicadasInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutPromociones_aplicadasInput, PedidoUncheckedCreateWithoutPromociones_aplicadasInput>
  }

  export type PromocionUpsertWithoutHistorialInput = {
    update: XOR<PromocionUpdateWithoutHistorialInput, PromocionUncheckedUpdateWithoutHistorialInput>
    create: XOR<PromocionCreateWithoutHistorialInput, PromocionUncheckedCreateWithoutHistorialInput>
    where?: PromocionWhereInput
  }

  export type PromocionUpdateToOneWithWhereWithoutHistorialInput = {
    where?: PromocionWhereInput
    data: XOR<PromocionUpdateWithoutHistorialInput, PromocionUncheckedUpdateWithoutHistorialInput>
  }

  export type PromocionUpdateWithoutHistorialInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoPromocionFieldUpdateOperationsInput | $Enums.TipoPromocion
    valor?: FloatFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: ProductoUpdateOneWithoutPromocionesNestedInput
    categoria?: CategoriaUpdateOneWithoutPromocionesNestedInput
  }

  export type PromocionUncheckedUpdateWithoutHistorialInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoPromocionFieldUpdateOperationsInput | $Enums.TipoPromocion
    referencia_id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    referencia_id_categoria?: NullableIntFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUpsertWithoutPromociones_aplicadasInput = {
    update: XOR<PedidoUpdateWithoutPromociones_aplicadasInput, PedidoUncheckedUpdateWithoutPromociones_aplicadasInput>
    create: XOR<PedidoCreateWithoutPromociones_aplicadasInput, PedidoUncheckedCreateWithoutPromociones_aplicadasInput>
    where?: PedidoWhereInput
  }

  export type PedidoUpdateToOneWithWhereWithoutPromociones_aplicadasInput = {
    where?: PedidoWhereInput
    data: XOR<PedidoUpdateWithoutPromociones_aplicadasInput, PedidoUncheckedUpdateWithoutPromociones_aplicadasInput>
  }

  export type PedidoUpdateWithoutPromociones_aplicadasInput = {
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion_envio?: StringFieldUpdateOperationsInput | string
    metodo_pago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    subtotal?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    impuestos?: FloatFieldUpdateOperationsInput | number
    estado_carrito?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
    items?: PedidoItemUpdateManyWithoutPedidoNestedInput
    transiciones?: TransicionEstadoPedidoUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutPromociones_aplicadasInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion_envio?: StringFieldUpdateOperationsInput | string
    metodo_pago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    subtotal?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    impuestos?: FloatFieldUpdateOperationsInput | number
    estado_carrito?: BoolFieldUpdateOperationsInput | boolean
    items?: PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput
    transiciones?: TransicionEstadoPedidoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type UsuarioCreateWithoutPedidosInput = {
    nombre_usuario: string
    correo: string
    contraseña: string
    rol: $Enums.Rol
    ultimo_inicio_sesion?: Date | string | null
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
    transiciones_estado?: TransicionEstadoPedidoCreateNestedManyWithoutAdminInput
    reportes_resena?: ReporteResenaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPedidosInput = {
    id?: number
    nombre_usuario: string
    correo: string
    contraseña: string
    rol: $Enums.Rol
    ultimo_inicio_sesion?: Date | string | null
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
    transiciones_estado?: TransicionEstadoPedidoUncheckedCreateNestedManyWithoutAdminInput
    reportes_resena?: ReporteResenaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPedidosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
  }

  export type PedidoItemCreateWithoutPedidoInput = {
    cantidad: number
    producto: ProductoCreateNestedOneWithoutPedidoItemsInput
    producto_personalizado?: ProductoPersonalizableCreateNestedOneWithoutPedidoItemsInput
  }

  export type PedidoItemUncheckedCreateWithoutPedidoInput = {
    producto_id: number
    cantidad: number
    producto_personalizado_id?: number | null
  }

  export type PedidoItemCreateOrConnectWithoutPedidoInput = {
    where: PedidoItemWhereUniqueInput
    create: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput>
  }

  export type PedidoItemCreateManyPedidoInputEnvelope = {
    data: PedidoItemCreateManyPedidoInput | PedidoItemCreateManyPedidoInput[]
    skipDuplicates?: boolean
  }

  export type TransicionEstadoPedidoCreateWithoutPedidoInput = {
    estado: $Enums.EstadoPedido
    fecha_hora: Date | string
    admin: UsuarioCreateNestedOneWithoutTransiciones_estadoInput
  }

  export type TransicionEstadoPedidoUncheckedCreateWithoutPedidoInput = {
    id?: number
    estado: $Enums.EstadoPedido
    fecha_hora: Date | string
    admin_id: number
  }

  export type TransicionEstadoPedidoCreateOrConnectWithoutPedidoInput = {
    where: TransicionEstadoPedidoWhereUniqueInput
    create: XOR<TransicionEstadoPedidoCreateWithoutPedidoInput, TransicionEstadoPedidoUncheckedCreateWithoutPedidoInput>
  }

  export type TransicionEstadoPedidoCreateManyPedidoInputEnvelope = {
    data: TransicionEstadoPedidoCreateManyPedidoInput | TransicionEstadoPedidoCreateManyPedidoInput[]
    skipDuplicates?: boolean
  }

  export type HistorialPromocionAplicadaCreateWithoutPedidoInput = {
    fecha: Date | string
    promocion: PromocionCreateNestedOneWithoutHistorialInput
  }

  export type HistorialPromocionAplicadaUncheckedCreateWithoutPedidoInput = {
    id?: number
    promocion_id: number
    fecha: Date | string
  }

  export type HistorialPromocionAplicadaCreateOrConnectWithoutPedidoInput = {
    where: HistorialPromocionAplicadaWhereUniqueInput
    create: XOR<HistorialPromocionAplicadaCreateWithoutPedidoInput, HistorialPromocionAplicadaUncheckedCreateWithoutPedidoInput>
  }

  export type HistorialPromocionAplicadaCreateManyPedidoInputEnvelope = {
    data: HistorialPromocionAplicadaCreateManyPedidoInput | HistorialPromocionAplicadaCreateManyPedidoInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutPedidosInput = {
    update: XOR<UsuarioUpdateWithoutPedidosInput, UsuarioUncheckedUpdateWithoutPedidosInput>
    create: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPedidosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPedidosInput, UsuarioUncheckedUpdateWithoutPedidosInput>
  }

  export type UsuarioUpdateWithoutPedidosInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contraseña?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ultimo_inicio_sesion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
    transiciones_estado?: TransicionEstadoPedidoUpdateManyWithoutAdminNestedInput
    reportes_resena?: ReporteResenaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contraseña?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ultimo_inicio_sesion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
    transiciones_estado?: TransicionEstadoPedidoUncheckedUpdateManyWithoutAdminNestedInput
    reportes_resena?: ReporteResenaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type PedidoItemUpsertWithWhereUniqueWithoutPedidoInput = {
    where: PedidoItemWhereUniqueInput
    update: XOR<PedidoItemUpdateWithoutPedidoInput, PedidoItemUncheckedUpdateWithoutPedidoInput>
    create: XOR<PedidoItemCreateWithoutPedidoInput, PedidoItemUncheckedCreateWithoutPedidoInput>
  }

  export type PedidoItemUpdateWithWhereUniqueWithoutPedidoInput = {
    where: PedidoItemWhereUniqueInput
    data: XOR<PedidoItemUpdateWithoutPedidoInput, PedidoItemUncheckedUpdateWithoutPedidoInput>
  }

  export type PedidoItemUpdateManyWithWhereWithoutPedidoInput = {
    where: PedidoItemScalarWhereInput
    data: XOR<PedidoItemUpdateManyMutationInput, PedidoItemUncheckedUpdateManyWithoutPedidoInput>
  }

  export type TransicionEstadoPedidoUpsertWithWhereUniqueWithoutPedidoInput = {
    where: TransicionEstadoPedidoWhereUniqueInput
    update: XOR<TransicionEstadoPedidoUpdateWithoutPedidoInput, TransicionEstadoPedidoUncheckedUpdateWithoutPedidoInput>
    create: XOR<TransicionEstadoPedidoCreateWithoutPedidoInput, TransicionEstadoPedidoUncheckedCreateWithoutPedidoInput>
  }

  export type TransicionEstadoPedidoUpdateWithWhereUniqueWithoutPedidoInput = {
    where: TransicionEstadoPedidoWhereUniqueInput
    data: XOR<TransicionEstadoPedidoUpdateWithoutPedidoInput, TransicionEstadoPedidoUncheckedUpdateWithoutPedidoInput>
  }

  export type TransicionEstadoPedidoUpdateManyWithWhereWithoutPedidoInput = {
    where: TransicionEstadoPedidoScalarWhereInput
    data: XOR<TransicionEstadoPedidoUpdateManyMutationInput, TransicionEstadoPedidoUncheckedUpdateManyWithoutPedidoInput>
  }

  export type HistorialPromocionAplicadaUpsertWithWhereUniqueWithoutPedidoInput = {
    where: HistorialPromocionAplicadaWhereUniqueInput
    update: XOR<HistorialPromocionAplicadaUpdateWithoutPedidoInput, HistorialPromocionAplicadaUncheckedUpdateWithoutPedidoInput>
    create: XOR<HistorialPromocionAplicadaCreateWithoutPedidoInput, HistorialPromocionAplicadaUncheckedCreateWithoutPedidoInput>
  }

  export type HistorialPromocionAplicadaUpdateWithWhereUniqueWithoutPedidoInput = {
    where: HistorialPromocionAplicadaWhereUniqueInput
    data: XOR<HistorialPromocionAplicadaUpdateWithoutPedidoInput, HistorialPromocionAplicadaUncheckedUpdateWithoutPedidoInput>
  }

  export type HistorialPromocionAplicadaUpdateManyWithWhereWithoutPedidoInput = {
    where: HistorialPromocionAplicadaScalarWhereInput
    data: XOR<HistorialPromocionAplicadaUpdateManyMutationInput, HistorialPromocionAplicadaUncheckedUpdateManyWithoutPedidoInput>
  }

  export type PedidoCreateWithoutItemsInput = {
    fecha_pedido: Date | string
    direccion_envio: string
    metodo_pago: $Enums.MetodoPago
    subtotal: number
    total: number
    impuestos: number
    estado_carrito?: boolean
    usuario: UsuarioCreateNestedOneWithoutPedidosInput
    transiciones?: TransicionEstadoPedidoCreateNestedManyWithoutPedidoInput
    promociones_aplicadas?: HistorialPromocionAplicadaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutItemsInput = {
    id?: number
    usuario_id: number
    fecha_pedido: Date | string
    direccion_envio: string
    metodo_pago: $Enums.MetodoPago
    subtotal: number
    total: number
    impuestos: number
    estado_carrito?: boolean
    transiciones?: TransicionEstadoPedidoUncheckedCreateNestedManyWithoutPedidoInput
    promociones_aplicadas?: HistorialPromocionAplicadaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutItemsInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutItemsInput, PedidoUncheckedCreateWithoutItemsInput>
  }

  export type ProductoCreateWithoutPedidoItemsInput = {
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    promedio_valoracion?: number
    activo?: boolean
    categoria: CategoriaCreateNestedOneWithoutProductosInput
    imagenes?: ImagenProductoCreateNestedManyWithoutProductoInput
    etiquetas?: ProductoEtiquetaCreateNestedManyWithoutProductoInput
    resenas?: ResenaCreateNestedManyWithoutProductoInput
    promociones?: PromocionCreateNestedManyWithoutProductoInput
    productosPersonalizables?: ProductoPersonalizableCreateNestedManyWithoutProducto_baseInput
  }

  export type ProductoUncheckedCreateWithoutPedidoItemsInput = {
    id?: number
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    categoria_id: number
    promedio_valoracion?: number
    activo?: boolean
    imagenes?: ImagenProductoUncheckedCreateNestedManyWithoutProductoInput
    etiquetas?: ProductoEtiquetaUncheckedCreateNestedManyWithoutProductoInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutProductoInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutProductoInput
    productosPersonalizables?: ProductoPersonalizableUncheckedCreateNestedManyWithoutProducto_baseInput
  }

  export type ProductoCreateOrConnectWithoutPedidoItemsInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutPedidoItemsInput, ProductoUncheckedCreateWithoutPedidoItemsInput>
  }

  export type ProductoPersonalizableCreateWithoutPedidoItemsInput = {
    nombre: string
    descripcion_general: string
    activo?: boolean
    categoria: CategoriaCreateNestedOneWithoutProductosPersonalizablesInput
    producto_base: ProductoCreateNestedOneWithoutProductosPersonalizablesInput
    variantes?: VarianteDetalleCreateNestedManyWithoutProductoPersonalizableInput
  }

  export type ProductoPersonalizableUncheckedCreateWithoutPedidoItemsInput = {
    id?: number
    nombre: string
    descripcion_general: string
    id_categoria: number
    id_producto_base: number
    activo?: boolean
    variantes?: VarianteDetalleUncheckedCreateNestedManyWithoutProductoPersonalizableInput
  }

  export type ProductoPersonalizableCreateOrConnectWithoutPedidoItemsInput = {
    where: ProductoPersonalizableWhereUniqueInput
    create: XOR<ProductoPersonalizableCreateWithoutPedidoItemsInput, ProductoPersonalizableUncheckedCreateWithoutPedidoItemsInput>
  }

  export type PedidoUpsertWithoutItemsInput = {
    update: XOR<PedidoUpdateWithoutItemsInput, PedidoUncheckedUpdateWithoutItemsInput>
    create: XOR<PedidoCreateWithoutItemsInput, PedidoUncheckedCreateWithoutItemsInput>
    where?: PedidoWhereInput
  }

  export type PedidoUpdateToOneWithWhereWithoutItemsInput = {
    where?: PedidoWhereInput
    data: XOR<PedidoUpdateWithoutItemsInput, PedidoUncheckedUpdateWithoutItemsInput>
  }

  export type PedidoUpdateWithoutItemsInput = {
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion_envio?: StringFieldUpdateOperationsInput | string
    metodo_pago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    subtotal?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    impuestos?: FloatFieldUpdateOperationsInput | number
    estado_carrito?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
    transiciones?: TransicionEstadoPedidoUpdateManyWithoutPedidoNestedInput
    promociones_aplicadas?: HistorialPromocionAplicadaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion_envio?: StringFieldUpdateOperationsInput | string
    metodo_pago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    subtotal?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    impuestos?: FloatFieldUpdateOperationsInput | number
    estado_carrito?: BoolFieldUpdateOperationsInput | boolean
    transiciones?: TransicionEstadoPedidoUncheckedUpdateManyWithoutPedidoNestedInput
    promociones_aplicadas?: HistorialPromocionAplicadaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type ProductoUpsertWithoutPedidoItemsInput = {
    update: XOR<ProductoUpdateWithoutPedidoItemsInput, ProductoUncheckedUpdateWithoutPedidoItemsInput>
    create: XOR<ProductoCreateWithoutPedidoItemsInput, ProductoUncheckedCreateWithoutPedidoItemsInput>
    where?: ProductoWhereInput
  }

  export type ProductoUpdateToOneWithWhereWithoutPedidoItemsInput = {
    where?: ProductoWhereInput
    data: XOR<ProductoUpdateWithoutPedidoItemsInput, ProductoUncheckedUpdateWithoutPedidoItemsInput>
  }

  export type ProductoUpdateWithoutPedidoItemsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductosNestedInput
    imagenes?: ImagenProductoUpdateManyWithoutProductoNestedInput
    etiquetas?: ProductoEtiquetaUpdateManyWithoutProductoNestedInput
    resenas?: ResenaUpdateManyWithoutProductoNestedInput
    promociones?: PromocionUpdateManyWithoutProductoNestedInput
    productosPersonalizables?: ProductoPersonalizableUpdateManyWithoutProducto_baseNestedInput
  }

  export type ProductoUncheckedUpdateWithoutPedidoItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    categoria_id?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    imagenes?: ImagenProductoUncheckedUpdateManyWithoutProductoNestedInput
    etiquetas?: ProductoEtiquetaUncheckedUpdateManyWithoutProductoNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutProductoNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutProductoNestedInput
    productosPersonalizables?: ProductoPersonalizableUncheckedUpdateManyWithoutProducto_baseNestedInput
  }

  export type ProductoPersonalizableUpsertWithoutPedidoItemsInput = {
    update: XOR<ProductoPersonalizableUpdateWithoutPedidoItemsInput, ProductoPersonalizableUncheckedUpdateWithoutPedidoItemsInput>
    create: XOR<ProductoPersonalizableCreateWithoutPedidoItemsInput, ProductoPersonalizableUncheckedCreateWithoutPedidoItemsInput>
    where?: ProductoPersonalizableWhereInput
  }

  export type ProductoPersonalizableUpdateToOneWithWhereWithoutPedidoItemsInput = {
    where?: ProductoPersonalizableWhereInput
    data: XOR<ProductoPersonalizableUpdateWithoutPedidoItemsInput, ProductoPersonalizableUncheckedUpdateWithoutPedidoItemsInput>
  }

  export type ProductoPersonalizableUpdateWithoutPedidoItemsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion_general?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductosPersonalizablesNestedInput
    producto_base?: ProductoUpdateOneRequiredWithoutProductosPersonalizablesNestedInput
    variantes?: VarianteDetalleUpdateManyWithoutProductoPersonalizableNestedInput
  }

  export type ProductoPersonalizableUncheckedUpdateWithoutPedidoItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion_general?: StringFieldUpdateOperationsInput | string
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_producto_base?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    variantes?: VarianteDetalleUncheckedUpdateManyWithoutProductoPersonalizableNestedInput
  }

  export type PedidoCreateWithoutTransicionesInput = {
    fecha_pedido: Date | string
    direccion_envio: string
    metodo_pago: $Enums.MetodoPago
    subtotal: number
    total: number
    impuestos: number
    estado_carrito?: boolean
    usuario: UsuarioCreateNestedOneWithoutPedidosInput
    items?: PedidoItemCreateNestedManyWithoutPedidoInput
    promociones_aplicadas?: HistorialPromocionAplicadaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutTransicionesInput = {
    id?: number
    usuario_id: number
    fecha_pedido: Date | string
    direccion_envio: string
    metodo_pago: $Enums.MetodoPago
    subtotal: number
    total: number
    impuestos: number
    estado_carrito?: boolean
    items?: PedidoItemUncheckedCreateNestedManyWithoutPedidoInput
    promociones_aplicadas?: HistorialPromocionAplicadaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutTransicionesInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutTransicionesInput, PedidoUncheckedCreateWithoutTransicionesInput>
  }

  export type UsuarioCreateWithoutTransiciones_estadoInput = {
    nombre_usuario: string
    correo: string
    contraseña: string
    rol: $Enums.Rol
    ultimo_inicio_sesion?: Date | string | null
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    reportes_resena?: ReporteResenaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutTransiciones_estadoInput = {
    id?: number
    nombre_usuario: string
    correo: string
    contraseña: string
    rol: $Enums.Rol
    ultimo_inicio_sesion?: Date | string | null
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    reportes_resena?: ReporteResenaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutTransiciones_estadoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutTransiciones_estadoInput, UsuarioUncheckedCreateWithoutTransiciones_estadoInput>
  }

  export type PedidoUpsertWithoutTransicionesInput = {
    update: XOR<PedidoUpdateWithoutTransicionesInput, PedidoUncheckedUpdateWithoutTransicionesInput>
    create: XOR<PedidoCreateWithoutTransicionesInput, PedidoUncheckedCreateWithoutTransicionesInput>
    where?: PedidoWhereInput
  }

  export type PedidoUpdateToOneWithWhereWithoutTransicionesInput = {
    where?: PedidoWhereInput
    data: XOR<PedidoUpdateWithoutTransicionesInput, PedidoUncheckedUpdateWithoutTransicionesInput>
  }

  export type PedidoUpdateWithoutTransicionesInput = {
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion_envio?: StringFieldUpdateOperationsInput | string
    metodo_pago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    subtotal?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    impuestos?: FloatFieldUpdateOperationsInput | number
    estado_carrito?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
    items?: PedidoItemUpdateManyWithoutPedidoNestedInput
    promociones_aplicadas?: HistorialPromocionAplicadaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutTransicionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion_envio?: StringFieldUpdateOperationsInput | string
    metodo_pago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    subtotal?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    impuestos?: FloatFieldUpdateOperationsInput | number
    estado_carrito?: BoolFieldUpdateOperationsInput | boolean
    items?: PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput
    promociones_aplicadas?: HistorialPromocionAplicadaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type UsuarioUpsertWithoutTransiciones_estadoInput = {
    update: XOR<UsuarioUpdateWithoutTransiciones_estadoInput, UsuarioUncheckedUpdateWithoutTransiciones_estadoInput>
    create: XOR<UsuarioCreateWithoutTransiciones_estadoInput, UsuarioUncheckedCreateWithoutTransiciones_estadoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutTransiciones_estadoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutTransiciones_estadoInput, UsuarioUncheckedUpdateWithoutTransiciones_estadoInput>
  }

  export type UsuarioUpdateWithoutTransiciones_estadoInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contraseña?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ultimo_inicio_sesion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    reportes_resena?: ReporteResenaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutTransiciones_estadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contraseña?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ultimo_inicio_sesion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    reportes_resena?: ReporteResenaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type ResenaCreateWithoutReportesInput = {
    comentario: string
    valoracion: number
    fecha: Date | string
    visible?: boolean
    usuario: UsuarioCreateNestedOneWithoutResenasInput
    producto: ProductoCreateNestedOneWithoutResenasInput
  }

  export type ResenaUncheckedCreateWithoutReportesInput = {
    id?: number
    usuario_id: number
    producto_id: number
    comentario: string
    valoracion: number
    fecha: Date | string
    visible?: boolean
  }

  export type ResenaCreateOrConnectWithoutReportesInput = {
    where: ResenaWhereUniqueInput
    create: XOR<ResenaCreateWithoutReportesInput, ResenaUncheckedCreateWithoutReportesInput>
  }

  export type UsuarioCreateWithoutReportes_resenaInput = {
    nombre_usuario: string
    correo: string
    contraseña: string
    rol: $Enums.Rol
    ultimo_inicio_sesion?: Date | string | null
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
    transiciones_estado?: TransicionEstadoPedidoCreateNestedManyWithoutAdminInput
  }

  export type UsuarioUncheckedCreateWithoutReportes_resenaInput = {
    id?: number
    nombre_usuario: string
    correo: string
    contraseña: string
    rol: $Enums.Rol
    ultimo_inicio_sesion?: Date | string | null
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    transiciones_estado?: TransicionEstadoPedidoUncheckedCreateNestedManyWithoutAdminInput
  }

  export type UsuarioCreateOrConnectWithoutReportes_resenaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutReportes_resenaInput, UsuarioUncheckedCreateWithoutReportes_resenaInput>
  }

  export type ResenaUpsertWithoutReportesInput = {
    update: XOR<ResenaUpdateWithoutReportesInput, ResenaUncheckedUpdateWithoutReportesInput>
    create: XOR<ResenaCreateWithoutReportesInput, ResenaUncheckedCreateWithoutReportesInput>
    where?: ResenaWhereInput
  }

  export type ResenaUpdateToOneWithWhereWithoutReportesInput = {
    where?: ResenaWhereInput
    data: XOR<ResenaUpdateWithoutReportesInput, ResenaUncheckedUpdateWithoutReportesInput>
  }

  export type ResenaUpdateWithoutReportesInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    valoracion?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUpdateOneRequiredWithoutResenasNestedInput
    producto?: ProductoUpdateOneRequiredWithoutResenasNestedInput
  }

  export type ResenaUncheckedUpdateWithoutReportesInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    producto_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    valoracion?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioUpsertWithoutReportes_resenaInput = {
    update: XOR<UsuarioUpdateWithoutReportes_resenaInput, UsuarioUncheckedUpdateWithoutReportes_resenaInput>
    create: XOR<UsuarioCreateWithoutReportes_resenaInput, UsuarioUncheckedCreateWithoutReportes_resenaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutReportes_resenaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutReportes_resenaInput, UsuarioUncheckedUpdateWithoutReportes_resenaInput>
  }

  export type UsuarioUpdateWithoutReportes_resenaInput = {
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contraseña?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ultimo_inicio_sesion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
    transiciones_estado?: TransicionEstadoPedidoUpdateManyWithoutAdminNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutReportes_resenaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_usuario?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contraseña?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ultimo_inicio_sesion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    transiciones_estado?: TransicionEstadoPedidoUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type ResenaCreateManyUsuarioInput = {
    id?: number
    producto_id: number
    comentario: string
    valoracion: number
    fecha: Date | string
    visible?: boolean
  }

  export type PedidoCreateManyUsuarioInput = {
    id?: number
    fecha_pedido: Date | string
    direccion_envio: string
    metodo_pago: $Enums.MetodoPago
    subtotal: number
    total: number
    impuestos: number
    estado_carrito?: boolean
  }

  export type TransicionEstadoPedidoCreateManyAdminInput = {
    id?: number
    pedido_id: number
    estado: $Enums.EstadoPedido
    fecha_hora: Date | string
  }

  export type ReporteResenaCreateManyUsuarioInput = {
    id?: number
    resena_id: number
    comentario: string
  }

  export type ResenaUpdateWithoutUsuarioInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    valoracion?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    producto?: ProductoUpdateOneRequiredWithoutResenasNestedInput
    reportes?: ReporteResenaUpdateManyWithoutResenaNestedInput
  }

  export type ResenaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    producto_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    valoracion?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    reportes?: ReporteResenaUncheckedUpdateManyWithoutResenaNestedInput
  }

  export type ResenaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    producto_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    valoracion?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PedidoUpdateWithoutUsuarioInput = {
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion_envio?: StringFieldUpdateOperationsInput | string
    metodo_pago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    subtotal?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    impuestos?: FloatFieldUpdateOperationsInput | number
    estado_carrito?: BoolFieldUpdateOperationsInput | boolean
    items?: PedidoItemUpdateManyWithoutPedidoNestedInput
    transiciones?: TransicionEstadoPedidoUpdateManyWithoutPedidoNestedInput
    promociones_aplicadas?: HistorialPromocionAplicadaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion_envio?: StringFieldUpdateOperationsInput | string
    metodo_pago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    subtotal?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    impuestos?: FloatFieldUpdateOperationsInput | number
    estado_carrito?: BoolFieldUpdateOperationsInput | boolean
    items?: PedidoItemUncheckedUpdateManyWithoutPedidoNestedInput
    transiciones?: TransicionEstadoPedidoUncheckedUpdateManyWithoutPedidoNestedInput
    promociones_aplicadas?: HistorialPromocionAplicadaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_pedido?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion_envio?: StringFieldUpdateOperationsInput | string
    metodo_pago?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    subtotal?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    impuestos?: FloatFieldUpdateOperationsInput | number
    estado_carrito?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransicionEstadoPedidoUpdateWithoutAdminInput = {
    estado?: EnumEstadoPedidoFieldUpdateOperationsInput | $Enums.EstadoPedido
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutTransicionesNestedInput
  }

  export type TransicionEstadoPedidoUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedido_id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoPedidoFieldUpdateOperationsInput | $Enums.EstadoPedido
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransicionEstadoPedidoUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedido_id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoPedidoFieldUpdateOperationsInput | $Enums.EstadoPedido
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReporteResenaUpdateWithoutUsuarioInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    resena?: ResenaUpdateOneRequiredWithoutReportesNestedInput
  }

  export type ReporteResenaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    resena_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
  }

  export type ReporteResenaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    resena_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoCreateManyCategoriaInput = {
    id?: number
    nombre: string
    descripcion: string
    precio_base: number
    stock: number
    promedio_valoracion?: number
    activo?: boolean
  }

  export type PromocionCreateManyCategoriaInput = {
    id?: number
    nombre: string
    tipo: $Enums.TipoPromocion
    referencia_id_producto?: number | null
    valor: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
  }

  export type ProductoPersonalizableCreateManyCategoriaInput = {
    id?: number
    nombre: string
    descripcion_general: string
    id_producto_base: number
    activo?: boolean
  }

  export type ProductoUpdateWithoutCategoriaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    imagenes?: ImagenProductoUpdateManyWithoutProductoNestedInput
    etiquetas?: ProductoEtiquetaUpdateManyWithoutProductoNestedInput
    resenas?: ResenaUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProductoNestedInput
    promociones?: PromocionUpdateManyWithoutProductoNestedInput
    productosPersonalizables?: ProductoPersonalizableUpdateManyWithoutProducto_baseNestedInput
  }

  export type ProductoUncheckedUpdateWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    imagenes?: ImagenProductoUncheckedUpdateManyWithoutProductoNestedInput
    etiquetas?: ProductoEtiquetaUncheckedUpdateManyWithoutProductoNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutProductoNestedInput
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProductoNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutProductoNestedInput
    productosPersonalizables?: ProductoPersonalizableUncheckedUpdateManyWithoutProducto_baseNestedInput
  }

  export type ProductoUncheckedUpdateManyWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio_base?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    promedio_valoracion?: FloatFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromocionUpdateWithoutCategoriaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoPromocionFieldUpdateOperationsInput | $Enums.TipoPromocion
    valor?: FloatFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: ProductoUpdateOneWithoutPromocionesNestedInput
    historial?: HistorialPromocionAplicadaUpdateManyWithoutPromocionNestedInput
  }

  export type PromocionUncheckedUpdateWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoPromocionFieldUpdateOperationsInput | $Enums.TipoPromocion
    referencia_id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    historial?: HistorialPromocionAplicadaUncheckedUpdateManyWithoutPromocionNestedInput
  }

  export type PromocionUncheckedUpdateManyWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoPromocionFieldUpdateOperationsInput | $Enums.TipoPromocion
    referencia_id_producto?: NullableIntFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductoPersonalizableUpdateWithoutCategoriaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion_general?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    producto_base?: ProductoUpdateOneRequiredWithoutProductosPersonalizablesNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProducto_personalizadoNestedInput
    variantes?: VarianteDetalleUpdateManyWithoutProductoPersonalizableNestedInput
  }

  export type ProductoPersonalizableUncheckedUpdateWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion_general?: StringFieldUpdateOperationsInput | string
    id_producto_base?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProducto_personalizadoNestedInput
    variantes?: VarianteDetalleUncheckedUpdateManyWithoutProductoPersonalizableNestedInput
  }

  export type ProductoPersonalizableUncheckedUpdateManyWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion_general?: StringFieldUpdateOperationsInput | string
    id_producto_base?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductoEtiquetaCreateManyEtiquetaInput = {
    producto_id: number
  }

  export type ProductoEtiquetaUpdateWithoutEtiquetaInput = {
    producto?: ProductoUpdateOneRequiredWithoutEtiquetasNestedInput
  }

  export type ProductoEtiquetaUncheckedUpdateWithoutEtiquetaInput = {
    producto_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProductoEtiquetaUncheckedUpdateManyWithoutEtiquetaInput = {
    producto_id?: IntFieldUpdateOperationsInput | number
  }

  export type ImagenProductoCreateManyProductoInput = {
    id?: number
    url?: string
  }

  export type ProductoEtiquetaCreateManyProductoInput = {
    etiqueta_id: number
  }

  export type ResenaCreateManyProductoInput = {
    id?: number
    usuario_id: number
    comentario: string
    valoracion: number
    fecha: Date | string
    visible?: boolean
  }

  export type PedidoItemCreateManyProductoInput = {
    pedido_id: number
    cantidad: number
    producto_personalizado_id?: number | null
  }

  export type PromocionCreateManyProductoInput = {
    id?: number
    nombre: string
    tipo: $Enums.TipoPromocion
    referencia_id_categoria?: number | null
    valor: number
    fecha_inicio: Date | string
    fecha_fin: Date | string
  }

  export type ProductoPersonalizableCreateManyProducto_baseInput = {
    id?: number
    nombre: string
    descripcion_general: string
    id_categoria: number
    activo?: boolean
  }

  export type ImagenProductoUpdateWithoutProductoInput = {
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ImagenProductoUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ImagenProductoUncheckedUpdateManyWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoEtiquetaUpdateWithoutProductoInput = {
    etiqueta?: EtiquetaUpdateOneRequiredWithoutProductosNestedInput
  }

  export type ProductoEtiquetaUncheckedUpdateWithoutProductoInput = {
    etiqueta_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProductoEtiquetaUncheckedUpdateManyWithoutProductoInput = {
    etiqueta_id?: IntFieldUpdateOperationsInput | number
  }

  export type ResenaUpdateWithoutProductoInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    valoracion?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    usuario?: UsuarioUpdateOneRequiredWithoutResenasNestedInput
    reportes?: ReporteResenaUpdateManyWithoutResenaNestedInput
  }

  export type ResenaUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    valoracion?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
    reportes?: ReporteResenaUncheckedUpdateManyWithoutResenaNestedInput
  }

  export type ResenaUncheckedUpdateManyWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    valoracion?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PedidoItemUpdateWithoutProductoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    pedido?: PedidoUpdateOneRequiredWithoutItemsNestedInput
    producto_personalizado?: ProductoPersonalizableUpdateOneWithoutPedidoItemsNestedInput
  }

  export type PedidoItemUncheckedUpdateWithoutProductoInput = {
    pedido_id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    producto_personalizado_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PedidoItemUncheckedUpdateManyWithoutProductoInput = {
    pedido_id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    producto_personalizado_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PromocionUpdateWithoutProductoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoPromocionFieldUpdateOperationsInput | $Enums.TipoPromocion
    valor?: FloatFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    categoria?: CategoriaUpdateOneWithoutPromocionesNestedInput
    historial?: HistorialPromocionAplicadaUpdateManyWithoutPromocionNestedInput
  }

  export type PromocionUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoPromocionFieldUpdateOperationsInput | $Enums.TipoPromocion
    referencia_id_categoria?: NullableIntFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    historial?: HistorialPromocionAplicadaUncheckedUpdateManyWithoutPromocionNestedInput
  }

  export type PromocionUncheckedUpdateManyWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoPromocionFieldUpdateOperationsInput | $Enums.TipoPromocion
    referencia_id_categoria?: NullableIntFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductoPersonalizableUpdateWithoutProducto_baseInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion_general?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    categoria?: CategoriaUpdateOneRequiredWithoutProductosPersonalizablesNestedInput
    pedidoItems?: PedidoItemUpdateManyWithoutProducto_personalizadoNestedInput
    variantes?: VarianteDetalleUpdateManyWithoutProductoPersonalizableNestedInput
  }

  export type ProductoPersonalizableUncheckedUpdateWithoutProducto_baseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion_general?: StringFieldUpdateOperationsInput | string
    id_categoria?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
    pedidoItems?: PedidoItemUncheckedUpdateManyWithoutProducto_personalizadoNestedInput
    variantes?: VarianteDetalleUncheckedUpdateManyWithoutProductoPersonalizableNestedInput
  }

  export type ProductoPersonalizableUncheckedUpdateManyWithoutProducto_baseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion_general?: StringFieldUpdateOperationsInput | string
    id_categoria?: IntFieldUpdateOperationsInput | number
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReporteResenaCreateManyResenaInput = {
    id?: number
    usuario_id: number
    comentario: string
  }

  export type ReporteResenaUpdateWithoutResenaInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutReportes_resenaNestedInput
  }

  export type ReporteResenaUncheckedUpdateWithoutResenaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
  }

  export type ReporteResenaUncheckedUpdateManyWithoutResenaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoItemCreateManyProducto_personalizadoInput = {
    pedido_id: number
    producto_id: number
    cantidad: number
  }

  export type VarianteDetalleCreateManyProductoPersonalizableInput = {
    id_valor: number
  }

  export type PedidoItemUpdateWithoutProducto_personalizadoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    pedido?: PedidoUpdateOneRequiredWithoutItemsNestedInput
    producto?: ProductoUpdateOneRequiredWithoutPedidoItemsNestedInput
  }

  export type PedidoItemUncheckedUpdateWithoutProducto_personalizadoInput = {
    pedido_id?: IntFieldUpdateOperationsInput | number
    producto_id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoItemUncheckedUpdateManyWithoutProducto_personalizadoInput = {
    pedido_id?: IntFieldUpdateOperationsInput | number
    producto_id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type VarianteDetalleUpdateWithoutProductoPersonalizableInput = {
    valor?: ValorAtributoUpdateOneRequiredWithoutVarianteDetallesNestedInput
  }

  export type VarianteDetalleUncheckedUpdateWithoutProductoPersonalizableInput = {
    id_valor?: IntFieldUpdateOperationsInput | number
  }

  export type VarianteDetalleUncheckedUpdateManyWithoutProductoPersonalizableInput = {
    id_valor?: IntFieldUpdateOperationsInput | number
  }

  export type ValorAtributoCreateManyAtributoInput = {
    id_valor?: number
    valor: string
    precio_extra?: number
  }

  export type ValorAtributoUpdateWithoutAtributoInput = {
    valor?: StringFieldUpdateOperationsInput | string
    precio_extra?: FloatFieldUpdateOperationsInput | number
    varianteDetalles?: VarianteDetalleUpdateManyWithoutValorNestedInput
  }

  export type ValorAtributoUncheckedUpdateWithoutAtributoInput = {
    id_valor?: IntFieldUpdateOperationsInput | number
    valor?: StringFieldUpdateOperationsInput | string
    precio_extra?: FloatFieldUpdateOperationsInput | number
    varianteDetalles?: VarianteDetalleUncheckedUpdateManyWithoutValorNestedInput
  }

  export type ValorAtributoUncheckedUpdateManyWithoutAtributoInput = {
    id_valor?: IntFieldUpdateOperationsInput | number
    valor?: StringFieldUpdateOperationsInput | string
    precio_extra?: FloatFieldUpdateOperationsInput | number
  }

  export type VarianteDetalleCreateManyValorInput = {
    id_productoPersonalizable: number
  }

  export type VarianteDetalleUpdateWithoutValorInput = {
    productoPersonalizable?: ProductoPersonalizableUpdateOneRequiredWithoutVariantesNestedInput
  }

  export type VarianteDetalleUncheckedUpdateWithoutValorInput = {
    id_productoPersonalizable?: IntFieldUpdateOperationsInput | number
  }

  export type VarianteDetalleUncheckedUpdateManyWithoutValorInput = {
    id_productoPersonalizable?: IntFieldUpdateOperationsInput | number
  }

  export type HistorialPromocionAplicadaCreateManyPromocionInput = {
    id?: number
    pedido_id: number
    fecha: Date | string
  }

  export type HistorialPromocionAplicadaUpdateWithoutPromocionInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutPromociones_aplicadasNestedInput
  }

  export type HistorialPromocionAplicadaUncheckedUpdateWithoutPromocionInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedido_id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialPromocionAplicadaUncheckedUpdateManyWithoutPromocionInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedido_id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoItemCreateManyPedidoInput = {
    producto_id: number
    cantidad: number
    producto_personalizado_id?: number | null
  }

  export type TransicionEstadoPedidoCreateManyPedidoInput = {
    id?: number
    estado: $Enums.EstadoPedido
    fecha_hora: Date | string
    admin_id: number
  }

  export type HistorialPromocionAplicadaCreateManyPedidoInput = {
    id?: number
    promocion_id: number
    fecha: Date | string
  }

  export type PedidoItemUpdateWithoutPedidoInput = {
    cantidad?: IntFieldUpdateOperationsInput | number
    producto?: ProductoUpdateOneRequiredWithoutPedidoItemsNestedInput
    producto_personalizado?: ProductoPersonalizableUpdateOneWithoutPedidoItemsNestedInput
  }

  export type PedidoItemUncheckedUpdateWithoutPedidoInput = {
    producto_id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    producto_personalizado_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PedidoItemUncheckedUpdateManyWithoutPedidoInput = {
    producto_id?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    producto_personalizado_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransicionEstadoPedidoUpdateWithoutPedidoInput = {
    estado?: EnumEstadoPedidoFieldUpdateOperationsInput | $Enums.EstadoPedido
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UsuarioUpdateOneRequiredWithoutTransiciones_estadoNestedInput
  }

  export type TransicionEstadoPedidoUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoPedidoFieldUpdateOperationsInput | $Enums.EstadoPedido
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_id?: IntFieldUpdateOperationsInput | number
  }

  export type TransicionEstadoPedidoUncheckedUpdateManyWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoPedidoFieldUpdateOperationsInput | $Enums.EstadoPedido
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_id?: IntFieldUpdateOperationsInput | number
  }

  export type HistorialPromocionAplicadaUpdateWithoutPedidoInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    promocion?: PromocionUpdateOneRequiredWithoutHistorialNestedInput
  }

  export type HistorialPromocionAplicadaUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    promocion_id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialPromocionAplicadaUncheckedUpdateManyWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    promocion_id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}